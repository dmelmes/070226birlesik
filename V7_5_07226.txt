//@version=5
indicator(title="V7-5", shorttitle="V7-5",  overlay=true,  max_labels_count=500, max_lines_count=500, max_boxes_count=200,
     dynamic_requests=true)


// ---
// 0) GENEL — Stabil Başlık, Versiyon Etiketi, Safe Boot, Anchor Plot
// ---
grpGEN = "Genel"
versionLabel   = input.string("2.6-sqz-pro", "Versiyon Etiketi", group=grpGEN)
safeBoot       = input.bool(false, "SAFE BOOT", group=grpGEN)
showAnchorPlot = input.bool(true, "Anchor Plot", group=grpGEN)
// Görsel ölçek sabitleyici (grafikte görünmez)
plot(showAnchorPlot ? close : na, title="ANCHOR_PRICE", display=display.none)

// ---
// 1) INPUTS
// ---
grpST = "Supertrend"
atrLen          = input.int(10,   "ATR Period", group=grpST, minval=1)
atrMult         = input.float(3.0,"ATR Multiplier", group=grpST, step=0.1)
altAtrMethod    = input.bool(true,"Alt ATR", group=grpST)
showSTSignals   = input.bool(true,"ST Labels", group=grpST)
stHighlight     = input.bool(true,"Highlight Background", group=grpST)

grpEMA = "SlingShot"
emaFastLen = input.int(38,"EMA Fast", group=grpEMA, minval=1)
emaSlowLen = input.int(62,"EMA Slow", group=grpEMA, minval=1)
showEMAs   = input.bool(true,"Show EMA+Fill", group=grpEMA)

grpSS = "SlingShot Bars"
showConservative        = input.bool(true,"Cons Bars", group=grpSS)
showAggressive          = input.bool(true,"Agg Pullback Bars", group=grpSS)
hideAggressiveWhenConservative = input.bool(true,"Hide Agg if Cons", group=grpSS)

grpHTF = "HTF Trend Filtresi"
enableHTF        = input.bool(true, "HTF EMA200", group=grpHTF)
htf_tf           = input.timeframe("D", "HTF TF", group=grpHTF)
showHTFLine      = input.bool(true, "HTF çizgi", group=grpHTF)
htfSlopeConfirm  = input.bool(true,"HTF eğim şartı", group=grpHTF)
htfSlopeLen      = input.int(5,"HTF eğim bar", group=grpHTF, minval=1)

htfModeLabels    = input.string("Strict", "HTF Mode (Labels)", options=["Strict","Soft","Off"], group=grpHTF)
htfModeAlerts    = input.string("Strict", "HTF Mode (Alerts)", options=["Strict","Soft","Off"], group=grpHTF)
htfSoftTolType   = input.string("Percent", "Soft Tol. Type", options=["Percent","ATRx"], group=grpHTF)
htfSoftTolPct    = input.float(0.8, "Soft Tol. %", step=0.1, minval=0.0, group=grpHTF)
htfSoftTolATRx   = input.float(0.25, "Soft Tol. ATRx", step=0.05, minval=0.0, group=grpHTF)
htfATRlen        = input.int(14, "Soft Tol. ATR Length (HTF)", minval=1, group=grpHTF)
htfSoftSlopeEps  = input.float(0.0, "Soft Slope epsilon", step=0.01, minval=0.0, group=grpHTF)

// Uygulama kapsamları
htfApplyToBuyEntries  = input.bool(true,  "HTF: BUY entries",  group=grpHTF)
htfApplyToSellEntries = input.bool(false, "HTF: SELL entries", group=grpHTF)
htfApplyToBuyLabels   = input.bool(true,  "HTF: BUY labels",   group=grpHTF)
htfApplyToSellLabels  = input.bool(false, "HTF: SELL labels",  group=grpHTF)
htfApplyToBuyAlerts   = input.bool(true,  "HTF: BUY alerts",   group=grpHTF)
htfApplyToSellAlerts  = input.bool(true,  "HTF: SELL alerts",  group=grpHTF)
htfApplyToExits       = input.bool(false, "HTF: Exits",        group=grpHTF)

buyHTFGraceEnabled        = input.bool(true,  "BUY HTF Grace override", group=grpHTF)
buyHTFGraceBars           = input.int(12,     "BUY Grace window (bars after SAT)", group=grpHTF, minval=1)
buyHTFGraceUseChartEMA200 = input.bool(true,  "BUY Grace: chart EMA200 above", group=grpHTF)
buyHTFGraceChartBars      = input.int(48,     "BUY Grace (EMA200 üstü) en fazla X bar", group=grpHTF, minval=1)

grpIntersect = "Intersection"
enableIntersection = input.bool(true,"ST Flip + Cons", group=grpIntersect)
confirmWindow      = input.int(3,"Cons Window (bars)", group=grpIntersect, minval=0)
confirmOnClose     = input.bool(false,"Confirm on Close", group=grpIntersect)

grpRisk = "Risk & Targets"
showRTargets         = input.bool(true,"Show R1/R2", group=grpRisk)
showRTargetLabels    = input.bool(true,"Show R1/R2 text", group=grpRisk)
r1Multiple           = input.float(1.0,"R1 Multiple", step=0.25, group=grpRisk)
r2Multiple           = input.float(2.0,"R2 Multiple", step=0.25, group=grpRisk)
useFlipIfNoIntersect = input.bool(true,"ST Flip if no Int", group=grpRisk)
trailStopEnabled     = input.bool(false,"Trail Stop ST", group=grpRisk)
stopBufferPct        = input.float(0.0,"Stop Buffer %", step=0.1, minval=0)
applyBufferToStop    = input.bool(true,"Buffer initial+trail", group=grpRisk)
minRiskTicks         = input.int(0,"Min Risk ticks", group=grpRisk, minval=0)
showPrevStructureLvl = input.bool(false,"Prev Structure", group=grpRisk)
structureLookbackBars= input.int(60,"Struct Lookback", group=grpRisk, minval=5)
showRiskBox          = input.bool(false,"Risk Box", group=grpRisk)

grpColors = "Colors"
entryLineColor       = input.color(color.new(color.teal,40),"Entry Line", group=grpColors)
stopLineColorTargets = input.color(color.new(color.red,60),"Stop Line", group=grpColors)
r1Color              = input.color(color.new(color.orange,0),"Hedef1 Line", group=grpColors)
r2Color              = input.color(color.new(color.fuchsia,0),"Hedef2 Line", group=grpColors)
structColor          = input.color(color.new(color.purple,0),"Structure Line", group=grpColors)
riskBoxOpacity       = input.int(85,"Risk Box Opacity", group=grpColors, minval=0, maxval=100)

grpResSup = "Destek/Direnç (Pivot)"
showPivotRes          = input.bool(true,  "Pivot Direnç", group=grpResSup)
showPivotSup          = input.bool(true,  "Pivot Destek", group=grpResSup)
showPivotLabels       = input.bool(true,  "R/S etiket", group=grpResSup)
pivotLeft             = input.int(5,      "Pivot Left", group=grpResSup, minval=1)
pivotRight            = input.int(5,      "Pivot Right", group=grpResSup, minval=1)
maxPivotLevels        = input.int(6,      "Max seviye", group=grpResSup, minval=1, maxval=20)
pivotExtendBars       = input.int(180,    "Uzatma bar", group=grpResSup, minval=20, maxval=2000)
pivotResColor         = input.color(color.new(color.red, 40),   "Direnç rengi", group=grpResSup)
pivotSupColor         = input.color(color.new(color.green,40),  "Destek rengi", group=grpResSup)

grpUA = "Toplu Alarm"
enableUnifiedAlert = input.bool(false,"Enable Unified Alert", group=grpUA)
useCustomJsonAlert = input.bool(true,"JSON (Telegram) format", group=grpUA)
telegramChatId     = input.string("-1003015889970","Telegram chat_id (DEFAULT)", group=grpUA)
telegramChatIdBuy  = input.string("-1003015889970", "Telegram chat_id (BUY)",  group=grpUA)
telegramChatIdSell = input.string("-1002587291984", "Telegram chat_id (SELL)", group=grpUA)
telegramChatIdMtfBanko = input.string("-1002781417418", "Telegram chat_id (MTF BANKO KESİŞME)", group=grpUA)
dailyOnce          = input.bool(true,"Daily once per event (CONFIRMED only)", group=grpUA)
cooldownMinutes    = input.int(30,"Cooldown (minutes) (CONFIRMED only)", group=grpUA, minval=0)
includeBuyFlip        = input.bool(true,"BUY Flip", group=grpUA)
includeSellFlip       = input.bool(true,"SELL Flip", group=grpUA)
includeLongIntersect  = input.bool(true,"Long Kesişme", group=grpUA)
includeShortIntersect = input.bool(true,"Short Kesişme", group=grpUA)
includeHitR1          = input.bool(true,"Include Hedef1 Hit", group=grpUA)
includeHitR2          = input.bool(true,"Include Hedef2 Hit", group=grpUA)
includeTrailMove      = input.bool(false,"Include Trail Move", group=grpUA)
includeExit           = input.bool(true,"Include Exit / Poz Çıkış", group=grpUA)

grpHybrid = "Hybrid (Potansiyel + Onay)"
enableHybrid           = input.bool(true,  "Hybrid Mod (POT + CONF)", group=grpHybrid)
hybMinProgressPct      = input.float(30.0, "POT: Minimum Bar İlerlemesi (%)", step=5, group=grpHybrid)
hybStabilityTicks      = input.int(2,      "POT: Stabilite Sayaç (>=)", minval=1, group=grpHybrid)
hybCooldownMinutes     = input.int(20,     "POT: Cooldown (dakika)", minval=0, group=grpHybrid)
hybShowPotentialLabel  = input.bool(true,  "Grafikte Potansiyel Label Göster", group=grpHybrid)
hybUseSeparateAlerts   = input.bool(false,  "POT İçin Ayrı Alert Mesajı", group=grpHybrid)

grpProfiles = "Profil (Hızlı Ön ayar)"
profilePreset = input.string("Off (manual)", "Profil", options=["Off (manual)", "Aggressive (Early)", "Balanced (Early)", "Safe"], group=grpProfiles)
etiketDil = input.string("TR","Dil / Language", options=["TR","EN"])

grpExtra = "Extra Filters"
suppressBuyIfDailyUp = input.bool(true,  "AL Engel: Günlük ≥ %", group=grpExtra)
dailyUpPctThreshold  = input.float(8.0,  "Eşik (%)", step=0.5, minval=0.0, group=grpExtra)

grpBuyQG = "BQG"
buyQG_enable            = input.bool(true,  "On", group=grpBuyQG)
buyQG_overext_5d_pct    = input.float(20.0, "5D%", step=1.0, minval=0.0, group=grpBuyQG)
buyQG_overext_20d_pct   = input.float(50.0, "20D%", step=5.0, minval=0.0, group=grpBuyQG)
buyQG_overext_126d_pct  = input.float(250.0, "126D%", step=10.0, minval=0.0, group=grpBuyQG)
buyQG_donchian_len      = input.int(20, "Don", minval=5, group=grpBuyQG)
buyQG_breakout_req      = input.bool(true, "BreakReq", group=grpBuyQG)
buyQG_retest_window     = input.int(5, "Retest", minval=0, group=grpBuyQG)
buyQG_min_score         = input.int(3, "MinScr", minval=0, maxval=10, group=grpBuyQG)
buyQG_score_trend       = input.bool(true, "Trend", group=grpBuyQG)
buyQG_score_adx         = input.bool(true, "ADX", group=grpBuyQG)
buyQG_adx_threshold     = input.int(22, "ADX≥", minval=10, group=grpBuyQG)
buyQG_score_cmf         = input.bool(true, "CMF", group=grpBuyQG)
buyQG_cmf_threshold     = input.float(0.0, "CMF≥", step=0.01, group=grpBuyQG)
buyQG_score_breakout    = input.bool(true, "Break", group=grpBuyQG)
buyQG_apply_sqz         = input.bool(true, "SQZ", group=grpBuyQG)
buyQG_apply_mg          = input.bool(true, "MG", group=grpBuyQG)
buyQG_apply_m2          = input.bool(true, "M2", group=grpBuyQG)
buyQG_apply_banko       = input.bool(false, "BANKO", group=grpBuyQG)

grpSellQG = "SQG"
sellQG_enable            = input.bool(true,  "On", group=grpSellQG)
sellQG_overext_5d_pct    = input.float(20.0, "5D%", step=1.0, minval=0.0, group=grpSellQG)
sellQG_overext_20d_pct   = input.float(50.0, "20D%", step=5.0, minval=0.0, group=grpSellQG)
sellQG_overext_126d_pct  = input.float(250.0, "126D%", step=10.0, minval=0.0, group=grpSellQG)
sellQG_donchian_len      = input.int(20, "Don", minval=5, group=grpSellQG)
sellQG_breakout_req      = input.bool(true, "BreakReq", group=grpSellQG)
sellQG_min_score         = input.int(3, "MinScr", minval=0, maxval=10, group=grpSellQG)
sellQG_score_trend       = input.bool(true, "Trend", group=grpSellQG)
sellQG_score_adx         = input.bool(true, "ADX", group=grpSellQG)
sellQG_adx_threshold     = input.int(22, "ADX≥", minval=10, group=grpSellQG)
sellQG_score_cmf         = input.bool(true, "CMF", group=grpSellQG)
sellQG_cmf_threshold     = input.float(0.0, "CMF≤", step=0.01, group=grpSellQG)
sellQG_score_breakout    = input.bool(true, "Break", group=grpSellQG)
sellQG_apply_sqz         = input.bool(true, "SQZ", group=grpSellQG)

grpAlertSafe = "Alert Güvenlik"
alertsRealtimeOnly = input.bool(true, "Realtime only", group=grpAlertSafe)
tr_ascii_upper = input.bool(true, "TR ASCII üst harf", group=grpAlertSafe)

grpMT = "Modül 2 — MesutTrend 4H + MG"
includeModule2          = input.bool(true, "M2 aktif", group=grpMT)
mt_coeff                = input.float(1.0,'MT Multiplier',step=0.1,group=grpMT)
mt_AP                   = input.int(14,'MT Common Period',minval=1,group=grpMT)
mt_useRSI_noVolume      = input.bool(false,'MT Use RSI if no volume?',group=grpMT)
mt_cooldown_minutes     = input.int(1440,'MT Alarm Cooldown (min;0=off)',minval=0,group=grpMT)
mt_enableSellAlerts     = input.bool(true,"MT SELL onay aktif?",group=grpMT)
mt_tpATRmult            = input.float(1.0,'MT TP ATR Mult',step=0.1,minval=0.1,group=grpMT)
mt_stopBufferPct        = input.float(0.0,'MT Stop buffer %',step=0.1,minval=0.0,group=grpMT)
mt_roundToMintick       = input.bool(true,"MT Round target/stop to mintick",group=grpMT)
mt_useOriginalATR       = input.bool(false,"MT Orijinal ATR (sma(tr))",group=grpMT)
mt_includeCandleCloseBuy= input.bool(false,"MT Candle Close Buy sinyali",group=grpMT)
mt_sendCombinedAlerts   = input.bool(true,  "M2 Kombine", group=grpMT)
mt_sendConfirmedAlerts  = input.bool(true,  "M2 Onaylı", group=grpMT)
mt_sendCandleAlerts     = input.bool(true,  "M2 Candle", group=grpMT)
mt_enableEarlyAlerts    = input.bool(false,  "M2 Erken", group=grpMT)

grpMG = "Modül 2 — MG Multi Güçlü AL"
mg_periodMACD   = input.int(12,"MACD Fast",group=grpMG)
mg_slowMACD     = input.int(26,"MACD Slow",group=grpMG)
mg_signalMACD   = input.int(9,"MACD Signal",group=grpMG)
mg_macdTF       = input.timeframe("60","MACD TF",group=grpMG)
mg_maLen        = input.int(20,"MA Length",group=grpMG)
mg_maType       = input.string("EMA","MA Type",options=["SMA","EMA","WMA","HullMA","VWMA","RMA","TEMA","TilsonT3"],group=grpMG)
mg_maTF         = input.timeframe("60","MA TF",group=grpMG)
mg_alphaCoeff   = input.float(1.0,"AlphaTrend Mult",group=grpMG,step=0.1)
mg_alphaPeriod  = input.int(14,"AlphaTrend Period",group=grpMG)
mg_useRSIConfirm= input.bool(true,"Add RSI Confirm?",group=grpMG)
mg_rsiTF        = input.timeframe("60","RSI TF",group=grpMG)
mg_rsiLen       = input.int(14,"RSI Len",group=grpMG)
mg_rsiThresh    = input.int(50,"Min RSI",group=grpMG)
showStrongShapeFiltered= input.bool(false,"Strong Buy shape uses daily filter (M2)",group=grpMG)
mg_enableAlertsChart = input.bool(false,  "MG: Chart TF kapanışında mesaj", group=grpMG)
mg_enableAlertsMTF   = input.bool(true,  "MG: 1H/4H/1D kapanışlarında mesaj", group=grpMG)

// PG grupları
pg_groupSig  = "PG — Sinyal"
pg_groupVA   = "PG — Değer Alanı"
pg_groupInfo = "PG — Raporlama"
pg_groupHTF  = "PG — HTF Filtre"
pg_groupAL   = "PG — Alarm"
pg_groupEX   = "PG — Ek Filtre"
pg_groupMTF  = "PG — MTF (1H/4H/1D)"
pg_groupHC   = "PG — Yüksek Güven (Uzman Filtreler)"

// PG — temel
pg_enable = input.bool(true, "PG Modülü Aktif", group=pg_groupSig)
pg_use_close_confirm = input.bool(true, "Bar kapanışında teyit (PG)", group=pg_groupSig)
pg_chart_also_send   = input.bool(true, "PG Chart TF mesajlarını da gönder (MTF açıksa ek)", group=pg_groupSig)

pg_use_zscore_vol  = input.bool(true,  "Hacimde Z-Score (PG)", group=pg_groupSig)
pg_vol_period      = input.int(20,     "Hacim Periyodu (PG)", minval=5, group=pg_groupSig)
pg_vol_multiplier  = input.float(2.0,  "Hacim Çarpanı SMA (PG)", step=0.1, group=pg_groupSig)
pg_vol_z_threshold = input.float(2.0,  "Z-Score Eşiği (PG)", step=0.1, group=pg_groupSig)
pg_cmf_period      = input.int(20,  "CMF Periyodu (PG)", minval=5, group=pg_groupSig)
pg_cmf_pos_th      = input.float(0.05,  "CMF Pozitif (AL) (PG)", step=0.01, group=pg_groupSig)
pg_cmf_neg_th      = input.float(-0.05, "CMF Negatif (SAT) (PG)", step=0.01, group=pg_groupSig)

// PG — Değer alanı
pg_va_mode       = input.string("VWAP","Değer Alanı (PG)", options=["VWAP","Anchored VWAP","MA+Bollinger"], group=pg_groupVA)
pg_vwap_source   = input.source(hlc3,  "VWAP Kaynağı (PG)", group=pg_groupVA)
pg_anchor_use_session = input.bool(false,"Her seans başı anchor (PG)", group=pg_groupVA)
pg_use_anchor_by_time = input.bool(true, "Anchor'ı tarih/saat ile seç (PG)", group=pg_groupVA)
pg_anchor_time        = input.time(timestamp("2024-01-01T00:00:00"), "Anchor Tarihi (UTC) (PG)", group=pg_groupVA)
pg_bb_src     = input.source(close, "BB Kaynağı (PG)", group=pg_groupVA)
pg_bb_length  = input.int(20,"BB MA Periyodu (PG)", minval=5, group=pg_groupVA)
pg_bb_mult    = input.float(2.0,"BB Std Sapma (PG)", step=0.1, group=pg_groupVA)
pg_bb_ma_type = input.string("SMA","BB MA Türü (PG)", options=["SMA","EMA"], group=pg_groupVA)

// PG — raporlama
pg_trend_len     = input.int(50, "Trend EMA (PG)", minval=5, group=pg_groupInfo)
pg_fast_len      = input.int(12, "MACD Hızlı (PG)",  minval=1, group=pg_groupInfo)
pg_slow_len      = input.int(26, "MACD Yavaş (PG)",  minval=2, group=pg_groupInfo)
pg_signal_len    = input.int(9,  "MACD Sinyal (PG)", minval=1, group=pg_groupInfo)
pg_adx_len       = input.int(14,"ADX Periyodu (PG)", minval=5, group=pg_groupInfo)
pg_adx_threshold = input.int(22,"ADX Güçlü Eşik (PG)", minval=5, group=pg_groupInfo)
pg_atr_len       = input.int(14,"ATR Periyodu (PG)", minval=5, group=pg_groupInfo)

// PG — HTF
pg_enable_htf_cmf = input.bool(false, "HTF CMF yön filtresi (PG)", group=pg_groupHTF)
pg_htf_cmf_tf     = input.timeframe("60","HTF CMF TF (PG)", group=pg_groupHTF)
pg_htf_cmf_pos_th = input.float(0.0,"HTF CMF Pozitif (AL) (PG)", step=0.01, group=pg_groupHTF)
pg_htf_cmf_neg_th = input.float(0.0,"HTF CMF Negatif (SAT) (PG)", step=0.01, group=pg_groupHTF)

// PG — alarm
pg_enable_alerts     = input.bool(true,  "PG Alert aktif (Chart TF)", group=pg_groupAL)
pg_use_json_telegram = input.bool(false, "Telegram JSON (PG’ye özgü) — Global ile OR", group=pg_groupAL)
pg_chat_buy          = input.string("",  "chat_id (PG BUY) (boş=global)", group=pg_groupAL)
pg_chat_sell         = input.string("",  "chat_id (PG SELL) (boş=global)", group=pg_groupAL)
pg_daily_once        = input.bool(true,  "Aynı gün bir kez (PG)", group=pg_groupAL)
pg_cooldown_minutes  = input.int(15,      "Cooldown (dk) (PG)", minval=0, group=pg_groupAL)
pg_window_enable     = input.bool(true,  "PG Window Enable (son X TF barda PG varsa gönder)", group=pg_groupAL)
pg_window_bars       = input.int(3,      "PG Window Bars (TF)", minval=1, group=pg_groupAL)

// PG — ek filtre
pg_suppress_buy_if_daily_up = input.bool(false, "Günlük değişim ≥ %X ise PG-AL engelle", group=pg_groupEX)
pg_daily_up_pct_threshold   = input.float(8.0, "Günlük % eşiği (PG)", step=0.5, minval=0.0, group=pg_groupEX)
pg_require_di_align         = input.bool(true, "PG: Yön için DI hizası şart", group=pg_groupEX)
pg_require_ad_confirm       = input.bool(true, "PG: AKD (Acc/Dist) eğim onayı gerekli", group=pg_groupEX)
pg_ad_slope_len             = input.int(5, "PG: AKD eğim periyodu", minval=1, group=pg_groupEX)

// PG — Yüksek Güven (Uzman) — yeni
pg_hc_enable            = input.bool(true,  "PG High-Confidence (Uzman filtreler)", group=pg_groupHC)
pg_hc_cmf_pos           = input.float(0.10, "HC: CMF pozitif eşiği (AL)", step=0.01, group=pg_groupHC)
pg_hc_cmf_neg           = input.float(-0.10,"HC: CMF negatif eşiği (SAT)", step=0.01, group=pg_groupHC)
pg_hc_min_adx           = input.int(18,     "HC: Min ADX", minval=5, group=pg_groupHC)
pg_hc_min_di_diff       = input.float(3.0,  "HC: Min DI fark puanı", step=0.5, group=pg_groupHC)
pg_hc_vwap_dist_pct     = input.float(0.05, "HC: Min VWAP mesafe %", step=0.05, minval=0.0, group=pg_groupHC)
pg_hc_min_body_pct      = input.float(50.0, "HC: Min gövde/oran %", step=5.0, minval=0.0, maxval=100.0, group=pg_groupHC)
pg_hc_close_near_pct    = input.float(25.0, "HC: Kapanışın range ucuna yakın %", step=5.0, minval=0.0, maxval=50.0, group=pg_groupHC)
pg_hc_neg_day_rule      = input.bool(true,  "HC: Gün negatifken inflow kapat; güçlü akümülasyon istisna", group=pg_groupHC)
pg_hc_limit_down_guard  = input.bool(true,  "HC: Taban-kilit koruması (AL'i bastır)", group=pg_groupHC)
pg_hc_limit_down_len    = input.int(5,      "HC: Taban-kilit pencere (bar)", minval=3, group=pg_groupHC)

// MTF Alerts (1H/2H/4H/1D)
grpMTF = "MTF Alerts (1H/2H/4H/1D)"
mtf_enable      = input.bool(true,  "MTF Alert Paketi Aktif", group=grpMTF)
mtf_use_1h      = input.bool(true,  "1H (60)", group=grpMTF)
mtf_use_2h      = input.bool(true,  "2H (120)", group=grpMTF)
mtf_use_4h      = input.bool(true,  "4H (240)", group=grpMTF)
mtf_use_1d      = input.bool(true,  "1D (D)", group=grpMTF)
mtf_send_if_any = input.bool(true,  "Kapanan TF’te sinyal varsa gönder", group=grpMTF)
mtf_only_banko  = input.bool(true,  "MTF mesajları: yalnız BANKO KESİŞME", group=grpMTF)

// Refactor ekleri
grpRef = "Refactor Ek"
combinePotAndConfirm = input.bool(false, "Hybrid: POT + Confirm tek mesaj", group=grpRef)
unifiedIncludePG     = input.bool(true,  "Unified mesajına PG özeti ekle", group=grpRef)
showDebugFlags       = input.bool(false, "Debug Event ID Label", group=grpRef)

// Early (intra-bar) — BANKO
grpEarly = "Early Alerts"
earlyBankoEnabled        = input.bool(true,  "ERKEN BANKO (intra-bar) aktif", group=grpEarly)
earlyBankoMinProgressPct = input.float(25.0, "ERKEN BANKO: min bar ilerleme (%)", step=5.0, minval=0.0, maxval=100.0, group=grpEarly)
earlyBankoCooldownMin    = input.int(15,     "ERKEN BANKO: cooldown (dakika)", minval=0, group=grpEarly)

// Önceki gün özeti (Berlin 09:00)
grpPrev = "Önceki Gün Özeti"
prevAppendEnabled = input.bool(true, "Bugünkü AL mesajlarına dünkü olumlu sinyali ekle", group=grpPrev)
prevTz            = input.string("Europe/Berlin", "Saat Dilimi (DST otomatik)", group=grpPrev)
prevSessionHour   = input.int(9, "Seans açılışı saat (yerel TZ)", minval=0, maxval=23, group=grpPrev)
prevSessionMinute = input.int(0, "Seans açılışı dakika", minval=0, maxval=59, group=grpPrev)

// SQZ (LazyBear)
grpSQZ = "SQZ (LazyBear)"
//sqz_enable        = input.bool(false, "SQZ Modülü Aktif", group=grpSQZ)
//sqz_mode          = input.string("Off", "Kullanım Modu", options=["Off","Filter","Signal"], group=grpSQZ)
//sqz_filter_mode   = input.string("Strict", "Filter Sıkılığı", options=["Strict","Soft"], group=grpSQZ)
sqz_enable        = input.bool(true, "SQZ Modülü Aktif", group=grpSQZ)
sqz_mode          = input.string("Signal", "Kullanım Modu", options=["Off","Filter","Signal"], group=grpSQZ)
sqz_filter_mode   = input.string("Strict", "Filter Sıkılığı", options=["Strict","Soft"], group=grpSQZ)
sqz_lenBB         = input.int(20, "BB Length", group=grpSQZ, minval=1)
sqz_multBB        = input.float(2.0, "BB MultFactor", group=grpSQZ, step=0.1)
sqz_lenKC         = input.int(20, "KC Length", group=grpSQZ, minval=1)
sqz_multKC        = input.float(1.5, "KC MultFactor", group=grpSQZ, step=0.1)
sqz_useTR         = input.bool(true, "Use TrueRange (KC)", group=grpSQZ)
sqz_add_to_unified= input.bool(false, "Unified mesaja SQZ olayı ekle", group=grpSQZ)

// ---
// SAFE BOOT — etkin bayraklar
// ---
eff_pg_enable           = pg_enable           and not safeBoot
eff_includeModule2      = includeModule2      and not safeBoot
eff_mg_enableAlertsMTF  = mg_enableAlertsMTF  and not safeBoot
eff_mtf_enable          = mtf_enable          and not safeBoot
eff_prevAppendEnabled   = prevAppendEnabled   and not safeBoot

// Profil türevleri
useProfile    = profilePreset != "Off (manual)"
isAggProfile  = profilePreset == "Aggressive (Early)"
isBalProfile  = profilePreset == "Balanced (Early)"
isSafeProfile = profilePreset == "Safe"

eff_htfBuyEntries  = useProfile ? (isAggProfile ? false : isBalProfile ? true  : true)  : htfApplyToBuyEntries
eff_htfBuyLabels   = useProfile ? (isAggProfile ? false : isBalProfile ? false : true) : htfApplyToBuyLabels
eff_htfBuyAlerts   = useProfile ? (isAggProfile ? false : isBalProfile ? false : true) : htfApplyToBuyAlerts
eff_htfSellAlerts  = useProfile ? (isAggProfile ? true  : isBalProfile ? true  : true) : htfApplyToSellAlerts

eff_buyGraceEnabled        = useProfile ? (isSafeProfile ? false : true) : buyHTFGraceEnabled
eff_buyGraceBars           = useProfile ? (isAggProfile ? 14 : isBalProfile ? 9 : 12) : buyHTFGraceBars
eff_buyGraceUseChartEMA200 = useProfile ? (isSafeProfile ? false : true) : buyHTFGraceUseChartEMA200

eff_confirmWindow          = useProfile ? (isAggProfile ? 0 : isBalProfile ? 1 : 2) : confirmWindow
eff_useFlipIfNoIntersect   = useProfile ? true : useFlipIfNoIntersect

eff_hybMinProgressPct      = useProfile ? (isAggProfile ? 22 : isBalProfile ? 30 : 50) : hybMinProgressPct
eff_hybStabilityTicks      = useProfile ? (isAggProfile ? 1  : isBalProfile ? 2  : 3 ) : hybStabilityTicks
eff_hybCooldownMinutes     = useProfile ? (isAggProfile ? 10 : isBalProfile ? 20 : 45) : hybCooldownMinutes

eff_dailyOnce              = useProfile ? (isAggProfile ? false : true) : dailyOnce
eff_cooldownMinutes        = useProfile ? (isAggProfile ? 5 : isBalProfile ? 15 : 30) : cooldownMinutes

useCloseConfirm = enableHybrid ? true : confirmOnClose

// ---
// 2) HELPERS & TEXTS
// ---
fTxt(tr, en) => etiketDil == "TR" ? tr : en
TXT_BUY       = fTxt("K - AL","Buy")
TXT_SELL      = fTxt("K - SAT","Sell")
TXT_LINT      = fTxt("K - BANKO KESİŞME AL","BANKO LONG INTERSECT")
TXT_SINT      = fTxt("K - BANKO KESİŞME SAT","BANKO SHORT INTERSECT")
TXT_HIT_R1    = fTxt("K - Hedef1 Ulaşıldı (Hedef2 için izle)","Target1 Hit (watch Target2)")
TXT_HIT_R2    = fTxt("K - Hedef2 Ulaşıldı (Kar Al / Devam?)","Target2 Hit (TP or Continue?)")
TXT_TRAIL_UP  = fTxt("K - Trail Stop Yükseldi","Trail Stop Up")
TXT_EXIT      = fTxt("K - Poz Çıkış","Exit Position")
TXT_RES       = fTxt("K - Direnç","Res")
TXT_SUP       = fTxt("K - Destek","Sup")

var string PG_CTX_TR = ""
var string PG_CTX_EN = ""
var string pg_ctx_for_unified_buy = ""
var string tech_ctx_for_unified_buy = ""
TXT_MG_BUY    = fTxt("K - MULTI GÜÇLÜ AL","Multi Strong Buy")

fmtMint(x) => str.tostring(x, format.mintick)
f_fmt_time(t)=> str.format("{0,date,yyyy-MM-dd} {0,time,HH:mm}", t)
f_tf_label(tf) => tf == "60" ? "1H" : tf == "120" ? "2H" : tf == "240" ? "4H" : tf == "D" ? "1D" : tf

// Timeframe comparison helper - converts TF string to minutes
f_tf_to_minutes(tf) =>
    tf == "1" ? 1 : tf == "3" ? 3 : tf == "5" ? 5 : tf == "15" ? 15 : tf == "30" ? 30 : tf == "45" ? 45 : tf == "60" ? 60 : tf == "120" ? 120 : tf == "180" ? 180 : tf == "240" ? 240 : tf == "D" ? 1440 : tf == "W" ? 10080 : tf == "M" ? 43200 : 1440

// Check if requested TF is higher than chart TF (for MTF safety)
f_is_higher_tf(requestedTf) =>
    chartMins = f_tf_to_minutes(timeframe.period)
    reqMins = f_tf_to_minutes(requestedTf)
    reqMins > chartMins

// Önceki gün kayıt
var int   lastBullishTime    = na
var float lastBullishPrice   = na
var string lastBullishTextTR = ""
var string lastBullishTextEN = ""
var string lastBullishTF     = ""

// Targets helpers
f_build_buy_targets(_entry, _stUpLine) =>
    float stopCand = na(_stUpLine) ? na : (applyBufferToStop ? _stUpLine * (1 - stopBufferPct/100) : _stUpLine)
    float risk = na(stopCand) ? na : (_entry - stopCand)
    string entryStr = fmtMint(_entry)
    string stopStr  = na(stopCand) ? "NA" : fmtMint(stopCand)
    string riskStr  = na(risk) or risk<=0 ? "NA" : fmtMint(risk)
    string r1Str = "NA", r2Str = "NA"
    if not na(risk) and risk>0
        if r1Multiple>0
            r1Str := fmtMint(_entry + r1Multiple*risk)
        if r2Multiple>0
            r2Str := fmtMint(_entry + r2Multiple*risk)
    [entryStr, stopStr, riskStr, r1Str, r2Str]

f_build_sell_targets(_entry, _stDnLine) =>
    float stopCand = na(_stDnLine) ? na : (applyBufferToStop ? _stDnLine * (1 + stopBufferPct/100) : _stDnLine)
    float risk = na(stopCand) ? na : (stopCand - _entry)
    string entryStr = fmtMint(_entry)
    string stopStr  = na(stopCand) ? "NA" : fmtMint(stopCand)
    string riskStr  = na(risk) or risk<=0 ? "NA" : fmtMint(risk)
    string r1Str = "NA", r2Str = "NA"
    if not na(risk) and risk>0
        if r1Multiple>0
            r1Str := fmtMint(_entry - r1Multiple*risk)
        if r2Multiple>0
            r2Str := fmtMint(_entry - r2Multiple*risk)
    [entryStr, stopStr, riskStr, r1Str, r2Str]

f_target_block_buy(_entry, _stUpLine)=>
    [eS,sS,rS,r1S,r2S] = f_build_buy_targets(_entry, _stUpLine)
    tr = "\nGiriş: " + eS + "\nStop: " + sS + "\nRisk Mesafe: " + rS + (showRTargets ? ("\nHedef1: " + r1S + "   Hedef2: " + r2S) : "")
    en = "\nEntry: " + eS + "\nStop: " + sS + "\nRisk Distance: " + rS + (showRTargets ? ("\nTarget1: " + r1S + "   Target2: " + r2S) : "")
    [tr, en]

f_target_block_sell(_entry, _stDnLine)=>
    [eS,sS,rS,r1S,r2S] = f_build_sell_targets(_entry, _stDnLine)
    tr = "\nGiriş: " + eS + "\nStop: " + sS + "\nRisk Mesafe: " + rS + (showRTargets ? ("\nHedef1: " + r1S + "   Hedef2: " + r2S) : "")
    en = "\nEntry: " + eS + "\nStop: " + sS + "\nRisk Distance: " + rS + (showRTargets ? ("\nTarget1: " + r1S + "   Target2: " + r2S) : "")
    [tr, en]

fEscape(strIn) =>
    s = strIn
    s := str.replace_all(s, "\\", "\\\\")
    s := str.replace_all(s, "\"", "\\\"")
    s := str.replace_all(s, "\n", "\\n")
    s := str.replace_all(s, "\r", "")
    s := str.replace_all(s, "\t", "\\t")
    s := str.replace_all(s, "\u2028", "")
    s := str.replace_all(s, "\u2029", "")
    s

// TR -> ASCII + BÜYÜK
f_tr_ascii_upper(s) =>
    x = s
    x := str.replace_all(x, "ç", "c"),  x := str.replace_all(x, "Ç", "C")
    x := str.replace_all(x, "ğ", "g"),  x := str.replace_all(x, "Ğ", "G")
    x := str.replace_all(x, "ı", "i"),  x := str.replace_all(x, "I", "I")
    x := str.replace_all(x, "i", "i"),  x := str.replace_all(x, "İ", "I")
    x := str.replace_all(x, "ö", "o"),  x := str.replace_all(x, "Ö", "O")
    x := str.replace_all(x, "ş", "s"),  x := str.replace_all(x, "Ş", "S")
    x := str.replace_all(x, "ü", "u"),  x := str.replace_all(x, "Ü", "U")
    str.upper(x)

// DEDUP + Realtime guard
var sentEventIdsArr = array.new_string()
f_sent_contains(_id) =>
    _found = false
    _n = array.size(sentEventIdsArr)
    if _n > 0
        for i = 0 to _n - 1
            if array.get(sentEventIdsArr, i) == _id
                _found := true
    _found
f_rt_ok() => (not alertsRealtimeOnly) or barstate.isrealtime

send_event(id, msg, chatId, freq) =>
    if not f_sent_contains(id) and f_rt_ok()
        msgToSend = (etiketDil=="TR" and tr_ascii_upper) ? f_tr_ascii_upper(msg) : msg
        if useCustomJsonAlert
            alert("{\"chat_id\":\"" + chatId + "\",\"text\":\"" + fEscape(msgToSend) + "\"}", freq)
        else
            alert(msgToSend, freq)
        array.push(sentEventIdsArr, id)
        if array.size(sentEventIdsArr) > 800
            for _i = 0 to 99
                if array.size(sentEventIdsArr) > 700
                    array.shift(sentEventIdsArr)

// Günlük değişim
dCloseNow  = request.security(syminfo.tickerid, "D", close,    barmerge.gaps_off, barmerge.lookahead_off)
dClosePrev = request.security(syminfo.tickerid, "D", close[1], barmerge.gaps_off, barmerge.lookahead_off)
dayChangePct = na(dClosePrev) or dClosePrev==0 ? 0.0 : (dCloseNow - dClosePrev) / dClosePrev * 100.0
buyBlockedByPct = suppressBuyIfDailyUp and dayChangePct >= dailyUpPctThreshold

// ---
// QG — Overextension Filter (Daily lookbacks)
// ---
// Pack daily closes into single request for efficiency
f_buyqg_daily_pack() => [close, close[5], close[20], close[126]]
[buyqg_d_close, buyqg_d_close5, buyqg_d_close20, buyqg_d_close126] =    request.security(syminfo.tickerid, "D", f_buyqg_daily_pack(), barmerge.gaps_off, barmerge.lookahead_off)

// Calculate % changes
buyqg_pct_5d   = na(buyqg_d_close5) or buyqg_d_close5 <= 0 ? 0.0 : (buyqg_d_close - buyqg_d_close5) / buyqg_d_close5 * 100.0
buyqg_pct_20d  = na(buyqg_d_close20) or buyqg_d_close20 <= 0 ? 0.0 : (buyqg_d_close - buyqg_d_close20) / buyqg_d_close20 * 100.0
buyqg_pct_126d = na(buyqg_d_close126) or buyqg_d_close126 <= 0 ? 0.0 : (buyqg_d_close - buyqg_d_close126) / buyqg_d_close126 * 100.0

// Overextension check
buyqg_overext_blocked = buyQG_enable and ((buyqg_pct_5d >= buyQG_overext_5d_pct) or  (buyqg_pct_20d >= buyQG_overext_20d_pct) or  (buyqg_pct_126d >= buyQG_overext_126d_pct))

fChatId(isBuyEvent, isSellEvent) =>
    _def  = telegramChatId
    _buy  = telegramChatIdBuy  != "" ? telegramChatIdBuy  : _def
    _sell = telegramChatIdSell != "" ? telegramChatIdSell : _def
    isBuyEvent ? _buy : isSellEvent ? _sell : _def

f_pg_chat(isBuy) =>
    isBuy ? (pg_chat_buy  != "" ? pg_chat_buy  : telegramChatIdBuy)
          : (pg_chat_sell != "" ? pg_chat_sell : telegramChatIdSell)

// Günlük + cooldown (PG)
f_pg_allow(ev, dayRef, tRef, daily_once, cooldown_minutes, nowTime, currDayStr) =>
    _ok = ev
    if _ok and daily_once
        _ok := dayRef != currDayStr
    if _ok and cooldown_minutes > 0
        _ok := na(tRef) or (nowTime - tRef > cooldown_minutes * 60 * 1000)
    _ok

// Önceki gün notu (Berlin 09:00)
f_is_leap(y) => (y % 4 == 0 and y % 100 != 0) or (y % 400 == 0)
f_dim(y, m) =>
    m==1 or m==3 or m==5 or m==7 or m==8 or m==10 or m==12 ? 31 :  m==4 or m==6 or m==9  or m==11 ? 30 :  (f_is_leap(y) ? 29 : 28)
f_prev_ymd(y, m, d) =>
    py = y, pm = m, pd = d-1
    if pd <= 0
        pm := m-1
        if pm <= 0
            pm := 12
            py := y-1
        pd := f_dim(py, pm)
    [py, pm, pd]
f_prev_threshold_berlin() =>
    y = year(time), m = month(time), d = dayofmonth(time)
    [py, pm, pd] = f_prev_ymd(y, m, d)
    timestamp(prevTz, py, pm, pd, prevSessionHour, prevSessionMinute)

f_record_bullish(_textTR, _textEN, _tfLabel) =>
    [time, close, _textTR, _textEN, _tfLabel]

f_prev_bullish_note() =>
    string s = ""
    if eff_prevAppendEnabled and not na(lastBullishTime)
        thr = f_prev_threshold_berlin()
        if lastBullishTime >= thr
            coreTR = "Dün gelen olumlu sinyal"
            coreEN = "Yesterday's positive signal"
            whatTR = lastBullishTextTR + (lastBullishTF != "" ? " [" + lastBullishTF + "]" : "")
            whatEN = lastBullishTextEN + (lastBullishTF != "" ? " [" + lastBullishTF + "]" : "")
            s := (etiketDil=="TR" ? ("\n" + coreTR + ": " + whatTR + " — " + f_fmt_time(lastBullishTime) + " @ " + fmtMint(lastBullishPrice)) : ("\n" + coreEN + ": " + whatEN + " — " + f_fmt_time(lastBullishTime) + " @ " + fmtMint(lastBullishPrice)))
    s

// ---
// 3) SUPER TREND
// ---
trRange = ta.tr(true)
atrAlt  = ta.sma(trRange, atrLen)
atrBase = altAtrMethod ? atrAlt : ta.atr(atrLen)
midSrc  = hl2
_up = midSrc - atrMult * atrBase
_dn = midSrc + atrMult * atrBase
var float stUp = na
var float stDn = na
upPrev = nz(stUp[1], _up)
dnPrev = nz(stDn[1], _dn)
stUp := close[1] > upPrev ? math.max(_up, upPrev) : _up
stDn := close[1] < dnPrev ? math.min(_dn, dnPrev) : _dn
var int stDir = 1
stDir := stDir == -1 and close > dnPrev ? 1 :
         stDir ==  1 and close < upPrev ? -1 : stDir
flipUp   = stDir == 1 and stDir[1] == -1
flipDown = stDir == -1 and stDir[1] ==  1
buySignal  = flipUp
sellSignal = flipDown

plot(stDir==1?stUp:na,  "ST Up",   color=color.new(color.green,0), linewidth=2, style=plot.style_linebr)
plot(stDir==-1?stDn:na, "ST Down", color=color.new(color.red,0),   linewidth=2, style=plot.style_linebr)
bgcolor(stHighlight ? (stDir==1 ? color.new(color.green,88) : color.new(color.red,88)) : na)

// ---
// 4) SLINGSHOT / EMAs
// ---
emaFast = ta.ema(close, emaFastLen)
emaSlow = ta.ema(close, emaSlowLen)
consUp  = emaFast > emaSlow and close[1] < emaFast[1] and close > emaFast
consDn  = emaFast < emaSlow and close[1] > emaFast[1] and close < emaFast
pullUp  = emaFast > emaSlow and close < emaFast
pullDn  = emaFast < emaSlow and close > emaFast
isCons   = consUp or consDn
isAggBar = pullUp or pullDn
useCons  = showConservative and isCons
useAgg   = showAggressive and isAggBar and not (hideAggressiveWhenConservative and useCons)
barcolor(useCons ? color.aqua : useAgg ? color.yellow : na)
pSlow = plot(showEMAs ? emaSlow : na, "EMA Slow", color=color.new(color.gray,35), linewidth=4, style=plot.style_linebr)
pFast = plot(showEMAs ? emaFast : na, "EMA Fast", color=color.new(color.gray,0),  linewidth=2, style=plot.style_linebr)
fill(pSlow, pFast, color = showEMAs ? color.new(color.silver,70) : na)

// ---
// 4.7) SQZ (LazyBear) — hesaplama
// ---
sqz_source = close
sqz_basis  = ta.sma(sqz_source, sqz_lenBB)
sqz_dev    = sqz_multBB * ta.stdev(sqz_source, sqz_lenBB)
sqz_upperBB = sqz_basis + sqz_dev
sqz_lowerBB = sqz_basis - sqz_dev

sqz_range   = sqz_useTR ? ta.tr(true) : (high - low)
sqz_rangema = ta.sma(sqz_range, sqz_lenKC)
sqz_ma      = ta.sma(sqz_source, sqz_lenKC)
sqz_upperKC = sqz_ma + sqz_rangema * sqz_multKC
sqz_lowerKC = sqz_ma - sqz_rangema * sqz_multKC

sqzOn  = (sqz_lowerBB > sqz_lowerKC) and (sqz_upperBB < sqz_upperKC)
sqzOff = (sqz_lowerBB < sqz_lowerKC) and (sqz_upperBB > sqz_upperKC)
sqzNo  = not sqzOn and not sqzOff

sqz_base = close - math.avg(math.avg(ta.highest(high, sqz_lenKC), ta.lowest(low, sqz_lenKC)), ta.sma(close, sqz_lenKC))
sqz_val  = ta.linreg(sqz_base, sqz_lenKC, 0)

// ---
// 5) HTF EMA200
// ---
f_htf_pack(_slopeLen, _atrLen) =>
    _ema200 = ta.ema(close, 200)
    _slope  = ta.sma(ta.change(_ema200), _slopeLen)
    _atrHtf = ta.atr(_atrLen)
    [close, _ema200, _slope, _atrHtf]

[htfClose, htfEMA200, htfSlope, htfATRhtf] = request.security(syminfo.tickerid, htf_tf,
     f_htf_pack(htfSlopeLen, htfATRlen), barmerge.gaps_off, barmerge.lookahead_off)

htfUpRaw   = htfClose > htfEMA200
htfDnRaw   = htfClose < htfEMA200
htfUp      = enableHTF ? (htfSlopeConfirm ? (htfUpRaw and htfSlope >= 0) : htfUpRaw) : true
htfDn      = enableHTF ? (htfSlopeConfirm ? (htfDnRaw and htfSlope <= 0) : htfDnRaw) : true

softTolVal = htfSoftTolType=="Percent" ? (htfEMA200 * (htfSoftTolPct/100.0)) : (htfATRhtf * htfSoftTolATRx)
htfSoftUp  = enableHTF ? (htfSlopeConfirm ? (htfClose >= (htfEMA200 - softTolVal) and htfSlope >= -htfSoftSlopeEps) : (htfClose >= (htfEMA200 - softTolVal))) : true
htfSoftDn  = enableHTF ? (htfSlopeConfirm ? (htfClose <= (htfEMA200 + softTolVal) and htfSlope <=  htfSoftSlopeEps) : (htfClose <= (htfEMA200 + softTolVal))) : true

modePassLongLabels  = htfModeLabels=="Off"  ? true : htfModeLabels=="Soft"  ? htfSoftUp : htfUp
modePassShortLabels = htfModeLabels=="Off"  ? true : htfModeLabels=="Soft"  ? htfSoftDn : htfDn
modePassLongAlerts  = htfModeAlerts=="Off"  ? true : htfModeAlerts=="Soft"  ? htfSoftUp : htfUp
modePassShortAlerts = htfModeAlerts=="Off"  ? true : htfModeAlerts=="Soft"  ? htfSoftDn : htfDn

plot(showHTFLine ? htfEMA200 : na, title="HTF EMA200", color=color.new(color.blue,0), linewidth=2, style=plot.style_linebr)

chartEMA200 = ta.ema(close, 200)
var int lastSellFlipBar = na
if sellSignal
    lastSellFlipBar := bar_index
barsSinceSellFlip = na(lastSellFlipBar) ? 1000000 : bar_index - lastSellFlipBar

var int lastSellFlipBarForEMA = na
if sellSignal
    lastSellFlipBarForEMA := bar_index
barsSinceSellFlipForEMA = na(lastSellFlipBarForEMA) ? 1000000 : bar_index - lastSellFlipBarForEMA

buyGrace = (eff_buyGraceEnabled) and ((flipUp and emaFast > emaSlow and barsSinceSellFlip <= eff_buyGraceBars)  or (eff_buyGraceUseChartEMA200 and close > chartEMA200 and barsSinceSellFlipForEMA <= buyHTFGraceChartBars))

htfOkLongEntry  = (not enableHTF) or (not eff_htfBuyEntries)  or htfUp or buyGrace
htfOkShortEntry = (not enableHTF) or (not htfApplyToSellEntries) or htfDn
htfOkLongLabel  = (not enableHTF) or (not eff_htfBuyLabels)  or modePassLongLabels or buyGrace
htfOkShortLabel = (not enableHTF) or (not htfApplyToSellLabels) or modePassShortLabels
htfOkLongAlert  = (not enableHTF) or (not eff_htfBuyAlerts)  or modePassLongAlerts or buyGrace
htfOkShortAlert = (not enableHTF) or (not eff_htfSellAlerts) or modePassShortAlerts

// QG — MTF Function
f_buyqg_check() =>
    _s = 0
    if buyQG_score_trend
        _s := (close > ta.ema(close, 50) or htfUp) ? _s + 1 : _s
    if buyQG_score_adx
        _l = 14
        _a = ta.rma(ta.tr(true), _l)
        _u = ta.change(high)
        _d = -ta.change(low)
        _p = na(_u) ? na : (_u > _d and _u > 0 ? _u : 0)
        _m = na(_d) ? na : (_d > _u and _d > 0 ? _d : 0)
        _adx = ta.rma(100 * math.abs(100 * ta.rma(_p, _l) / _a - 100 * ta.rma(_m, _l) / _a) / (100 * ta.rma(_p, _l) / _a + 100 * ta.rma(_m, _l) / _a), _l)
        _s := _adx >= buyQG_adx_threshold ? _s + 1 : _s
    if buyQG_score_cmf
        _mf = ((close - low) - (high - close)) / (high - low) * volume
        _s := (ta.sma(_mf, 20) / ta.sma(volume, 20)) >= buyQG_cmf_threshold ? _s + 1 : _s
    if buyQG_score_breakout
        _s := high > ta.highest(high, buyQG_donchian_len)[1] ? _s + 1 : _s
    (not buyQG_enable) or ((_s >= buyQG_min_score) and ((not buyQG_breakout_req) or high > ta.highest(high, buyQG_donchian_len)[1]) and not buyqg_overext_blocked)

// QG — Chart TF
// Donchian Channel
buyqg_donch_high = ta.highest(high, buyQG_donchian_len)
buyqg_donch_break = high > buyqg_donch_high[1]

// Pivot resistance break (reuse existing pivot detection)
var int buyqg_last_breakout_bar = na
if buyqg_donch_break
    buyqg_last_breakout_bar := bar_index
buyqg_bars_since_break = na(buyqg_last_breakout_bar) ? 999999 : (bar_index - buyqg_last_breakout_bar)
buyqg_in_retest_window = buyqg_bars_since_break <= buyQG_retest_window

// ---
// QG — Scoring Model
// ---
// EMA50 for trend alignment
buyqg_ema50 = ta.ema(close, 50)

buyqg_score = 0

// Score 1: Trend alignment (close above EMA50 or HTF EMA200 up)
if buyQG_score_trend
    buyqg_trend_ok = (close > buyqg_ema50) or htfUp
    buyqg_score := buyqg_trend_ok ? buyqg_score + 1 : buyqg_score

// Score 2: ADX strength
if buyQG_score_adx
    // Proper ADX calculation
    buyqg_adx_len = 14
    buyqg_tr = ta.tr(true)
    buyqg_atr = ta.rma(buyqg_tr, buyqg_adx_len)
    buyqg_up = ta.change(high)
    buyqg_down = -ta.change(low)
    buyqg_plusDM = na(buyqg_up) ? na : (buyqg_up > buyqg_down and buyqg_up > 0 ? buyqg_up : 0)
    buyqg_minusDM = na(buyqg_down) ? na : (buyqg_down > buyqg_up and buyqg_down > 0 ? buyqg_down : 0)
    buyqg_plusDI = 100 * ta.rma(buyqg_plusDM, buyqg_adx_len) / buyqg_atr
    buyqg_minusDI = 100 * ta.rma(buyqg_minusDM, buyqg_adx_len) / buyqg_atr
    buyqg_dx = 100 * math.abs(buyqg_plusDI - buyqg_minusDI) / (buyqg_plusDI + buyqg_minusDI)
    buyqg_adx_val = ta.rma(buyqg_dx, buyqg_adx_len)
    buyqg_adx_ok = buyqg_adx_val >= buyQG_adx_threshold
    buyqg_score := buyqg_adx_ok ? buyqg_score + 1 : buyqg_score

// Score 3: CMF (reuse pg_cmf if available)
if buyQG_score_cmf
    buyqg_cmf_len = 20
    buyqg_mfm = ((close - low) - (high - close)) / (high - low)
    buyqg_mfv = buyqg_mfm * volume
    buyqg_cmf = ta.sma(buyqg_mfv, buyqg_cmf_len) / ta.sma(volume, buyqg_cmf_len)
    buyqg_cmf_ok = buyqg_cmf >= buyQG_cmf_threshold
    buyqg_score := buyqg_cmf_ok ? buyqg_score + 1 : buyqg_score

// Score 4: Breakout or retest
if buyQG_score_breakout
    buyqg_break_ok = buyqg_donch_break or buyqg_in_retest_window
    buyqg_score := buyqg_break_ok ? buyqg_score + 1 : buyqg_score

// Final quality check
buyqg_breakout_pass = (not buyQG_breakout_req) or buyqg_donch_break or buyqg_in_retest_window
buyqg_score_pass = buyqg_score >= buyQG_min_score
buyqg_quality_pass = (not buyQG_enable) or (buyqg_score_pass and buyqg_breakout_pass and not buyqg_overext_blocked)

// ---
// SELL QG - Overext Filter
// Calc neg % change
sellqg_pct_5d   = na(buyqg_d_close5) or buyqg_d_close5 <= 0 ? 0.0 : -(buyqg_d_close - buyqg_d_close5) / buyqg_d_close5 * 100.0
sellqg_pct_20d  = na(buyqg_d_close20) or buyqg_d_close20 <= 0 ? 0.0 : -(buyqg_d_close - buyqg_d_close20) / buyqg_d_close20 * 100.0
sellqg_pct_126d = na(buyqg_d_close126) or buyqg_d_close126 <= 0 ? 0.0 : -(buyqg_d_close - buyqg_d_close126) / buyqg_d_close126 * 100.0

// Overext check
sellqg_ox_block = sellQG_enable and ((sellqg_pct_5d >= sellQG_overext_5d_pct) or   (sellqg_pct_20d >= sellQG_overext_20d_pct) or  (sellqg_pct_126d >= sellQG_overext_126d_pct))

// SELL QG - Chart TF
sellqg_donch_low = ta.lowest(low, sellQG_donchian_len)
sellqg_donch_break = low < sellqg_donch_low[1]

// SELL QG - Score
sellqg_ema50 = ta.ema(close, 50)
sellqg_score = 0

// Score 1: Trend (close<EMA50 or HTF down)
if sellQG_score_trend
    sellqg_trend_ok = (close < sellqg_ema50) or htfDn
    sellqg_score := sellqg_trend_ok ? sellqg_score + 1 : sellqg_score

// Score 2: ADX (same calc as BUY)
if sellQG_score_adx
    sellqg_adx_len = 14
    sellqg_tr = ta.tr(true)
    sellqg_atr = ta.rma(sellqg_tr, sellqg_adx_len)
    sellqg_up = ta.change(high)
    sellqg_down = -ta.change(low)
    sellqg_plusDM = na(sellqg_up) ? na : (sellqg_up > sellqg_down and sellqg_up > 0 ? sellqg_up : 0)
    sellqg_minusDM = na(sellqg_down) ? na : (sellqg_down > sellqg_up and sellqg_down > 0 ? sellqg_down : 0)
    sellqg_plusDI = 100 * ta.rma(sellqg_plusDM, sellqg_adx_len) / sellqg_atr
    sellqg_minusDI = 100 * ta.rma(sellqg_minusDM, sellqg_adx_len) / sellqg_atr
    sellqg_dx = 100 * math.abs(sellqg_plusDI - sellqg_minusDI) / (sellqg_plusDI + sellqg_minusDI)
    sellqg_adx_val = ta.rma(sellqg_dx, sellqg_adx_len)
    sellqg_adx_ok = sellqg_adx_val >= sellQG_adx_threshold
    sellqg_score := sellqg_adx_ok ? sellqg_score + 1 : sellqg_score

// Score 3: CMF (neg = sell)
if sellQG_score_cmf
    sellqg_cmf_len = 20
    sellqg_mfm = ((close - low) - (high - close)) / (high - low)
    sellqg_mfv = sellqg_mfm * volume
    sellqg_cmf = ta.sma(sellqg_mfv, sellqg_cmf_len) / ta.sma(volume, sellqg_cmf_len)
    sellqg_cmf_ok = sellqg_cmf <= sellQG_cmf_threshold
    sellqg_score := sellqg_cmf_ok ? sellqg_score + 1 : sellqg_score

// Score 4: Breakdown
if sellQG_score_breakout
    sellqg_break_ok = sellqg_donch_break
    sellqg_score := sellqg_break_ok ? sellqg_score + 1 : sellqg_score

// Final QG check
sellqg_breakout_pass = (not sellQG_breakout_req) or sellqg_donch_break
sellqg_score_pass = sellqg_score >= sellQG_min_score
sellqg_qpass = (not sellQG_enable) or (sellqg_score_pass and sellqg_breakout_pass and not sellqg_ox_block)

// ---
// 6) INTERSECTION + Quick Tech Fallback
// ---
var int lastFlipBar = na
var int lastFlipDir = 0
if buySignal
    lastFlipBar := bar_index
    lastFlipDir := 1
if sellSignal
    lastFlipBar := bar_index
    lastFlipDir := -1

barsSinceFlip = na(lastFlipBar) ? na : bar_index - lastFlipBar
inWindow = na(barsSinceFlip) ? false : (eff_confirmWindow==0 ? barsSinceFlip==0 : barsSinceFlip <= eff_confirmWindow)
longIntersect_raw  = enableIntersection and lastFlipDir==1  and inWindow and consUp
shortIntersect_raw = enableIntersection and lastFlipDir==-1 and inWindow and consDn

longIntersectEntry  = longIntersect_raw  and htfOkLongEntry
shortIntersectEntry = shortIntersect_raw and htfOkShortEntry
longIntersectLabel  = longIntersect_raw  and htfOkLongLabel
shortIntersectLabel = shortIntersect_raw and htfOkShortLabel
longIntersectAlert  = longIntersect_raw  and htfOkLongAlert
shortIntersectAlert = shortIntersect_raw and htfOkShortAlert

f_quick_tech_ctx() =>
    htfDirStr = etiketDil=="TR" ? (htfUp ? "Yukarı" : htfDn ? "Aşağı" : "Yatay") : (htfUp ? "Up"    : htfDn ? "Down"  : "Flat")
    slopeStr = ""
    if htfSlopeConfirm
        slopeLabel = etiketDil=="TR" ? " (Eğim " : " (Slope "
        slopeSign  = htfSlope >= 0 ? ">=0" : "<0"
        slopeStr   := slopeLabel + slopeSign + ")"
    t = "HTF:" + htfDirStr + slopeStr + " [" + htfModeAlerts + "]"
    if consUp
        t := t + "\n" + (etiketDil=="TR" ? "SS: Con Up" : "SS: Con Up")
    else if consDn
        t := t + "\n" + (etiketDil=="TR" ? "SS: Con Down" : "SS: Con Down")
    t

// ---
// 7) POSITION STATE + Çizimler
// ---
var float lastEntryPrice = na
var float initialStop    = na
var float liveStop       = na
var int   lastEntryDir   = 0
var int   lastEntryBar   = na
var int   entryId        = 0
var line  lineEntry      = na
var line  lineStop       = na
var line  lineR1         = na
var line  lineR2         = na
var line  lineStruct     = na
var label labelR1        = na
var label labelR2        = na
var label labelStruct    = na
var box   riskBox        = na
var bool  r1HitForEntry  = false
var bool  r2HitForEntry  = false

entryConfirmed(c)=> c and (not useCloseConfirm or barstate.isconfirmed)

useFlipLongEntry  = eff_useFlipIfNoIntersect and buySignal  and not longIntersectEntry
useFlipShortEntry = eff_useFlipIfNoIntersect and sellSignal and not shortIntersectEntry
newLongEntry  = (longIntersectEntry or useFlipLongEntry)  and htfOkLongEntry
newShortEntry = (shortIntersectEntry or useFlipShortEntry) and htfOkShortEntry

// SQZ kapısı (Filter)
sqz_long_ok_strict = sqzOff and (sqz_val > 0)
sqz_short_ok_strict= sqzOff and (sqz_val < 0)
sqz_long_ok_soft   = (not sqzOn) and (sqz_val > 0)
sqz_short_ok_soft  = (not sqzOn) and (sqz_val < 0)

_useLongSQZ  = sqz_filter_mode=="Strict" ? sqz_long_ok_strict  : sqz_long_ok_soft
_useShortSQZ = sqz_filter_mode=="Strict" ? sqz_short_ok_strict : sqz_short_ok_soft

sqzGateLong  = (not sqz_enable) or (sqz_mode!="Filter") or _useLongSQZ
sqzGateShort = (not sqz_enable) or (sqz_mode!="Filter") or _useShortSQZ

longIntersectEntry  := longIntersectEntry  and sqzGateLong
shortIntersectEntry := shortIntersectEntry and sqzGateShort
newLongEntry        := newLongEntry        and sqzGateLong
newShortEntry       := newShortEntry       and sqzGateShort

// Apply QG to BANKO signals (optional)
if buyQG_enable and buyQG_apply_banko
    longIntersectEntry  := longIntersectEntry  and buyqg_quality_pass
    longIntersectLabel  := longIntersectLabel  and buyqg_quality_pass
    longIntersectAlert  := longIntersectAlert  and buyqg_quality_pass
    newLongEntry        := newLongEntry        and buyqg_quality_pass

f_delete_all() =>
    if not na(lineEntry)
        line.delete(lineEntry)
    if not na(lineStop)
        line.delete(lineStop)
    if not na(lineR1)
        line.delete(lineR1)
    if not na(lineR2)
        line.delete(lineR2)
    if not na(lineStruct)
        line.delete(lineStruct)
    if not na(labelR1)
        label.delete(labelR1)
    if not na(labelR2)
        label.delete(labelR2)
    if not na(riskBox)
        box.delete(riskBox)

if entryConfirmed(newLongEntry)
    f_delete_all()
    lastEntryPrice := close
    baseStop = stUp
    if applyBufferToStop
        baseStop *= (1 - stopBufferPct/100)
    initialStop := baseStop
    liveStop    := baseStop
    lastEntryDir := 1
    lastEntryBar := bar_index
    r1HitForEntry := false
    r2HitForEntry := false
    entryId += 1

if entryConfirmed(newShortEntry)
    f_delete_all()
    lastEntryPrice := close
    baseStop = stDn
    if applyBufferToStop
        baseStop *= (1 + stopBufferPct/100)
    initialStop := baseStop
    liveStop    := baseStop
    lastEntryDir := -1
    lastEntryBar := bar_index
    r1HitForEntry := false
    r2HitForEntry := false
    entryId += 1

havePosition = not na(lastEntryPrice) and lastEntryDir!=0
baseStopForTargets = havePosition ? (trailStopEnabled and not na(liveStop) ? liveStop : initialStop) : na
riskDist = havePosition and not na(baseStopForTargets) ? (lastEntryDir==1 ? (lastEntryPrice - baseStopForTargets) : (baseStopForTargets - lastEntryPrice)) : na

if havePosition and minRiskTicks>0 and riskDist < syminfo.mintick * minRiskTicks
    f_delete_all()
    lastEntryPrice := na
    initialStop := na
    liveStop := na
    lastEntryDir := 0
    lastEntryBar := na
    r1HitForEntry := false
    r2HitForEntry := false

trailMoved = false
if havePosition and trailStopEnabled and riskDist>0
    if lastEntryDir==1
        cand = stUp
        if applyBufferToStop
            cand *= (1 - stopBufferPct/100)
        if cand > liveStop
            liveStop := cand
            trailMoved := true
    else
        cand = stDn
        if applyBufferToStop
            cand *= (1 + stopBufferPct/100)
        if cand < liveStop
            liveStop := cand
            trailMoved := true

if havePosition and riskDist>0
    if na(lineEntry)
        lineEntry := line.new(lastEntryBar, lastEntryPrice, bar_index+60, lastEntryPrice, color=entryLineColor, width=2)
    if na(lineStop)
        lineStop := line.new(lastEntryBar, liveStop, bar_index+60, liveStop, color=stopLineColorTargets, style=line.style_dashed)
    line.set_x2(lineEntry, bar_index+60)
    line.set_x2(lineStop, bar_index+60)
    line.set_y1(lineStop, liveStop)
    line.set_y2(lineStop, liveStop)

    r1Price = lastEntryDir==1 ? lastEntryPrice + r1Multiple*riskDist : lastEntryPrice - r1Multiple*riskDist
    r2Price = lastEntryDir==1 ? lastEntryPrice + r2Multiple*riskDist : lastEntryPrice - r2Multiple*riskDist

    if showRTargets
        if na(lineR1) and r1Multiple>0
            lineR1 := line.new(lastEntryBar, r1Price, bar_index+60, r1Price, color=r1Color, style=line.style_dotted)
        if na(lineR2) and r2Multiple>0
            lineR2 := line.new(lastEntryBar, r2Price, bar_index+60, r2Price, color=r2Color, style=line.style_dotted)
        if not na(lineR1)
            line.set_x2(lineR1, bar_index+60)
            line.set_y1(lineR1, r1Price)
            line.set_y2(lineR1, r1Price)
        if not na(lineR2)
            line.set_x2(lineR2, bar_index+60)
            line.set_y1(lineR2, r2Price)
            line.set_y2(lineR2, r2Price)

    if showRTargets and showRTargetLabels
        if na(labelR1) and r1Multiple>0
            labelR1 := label.new(bar_index, r1Price, "Hedef1: " + fmtMint(r1Price), style=label.style_label_left, color=color.new(r1Color,0), textcolor=color.white, size=size.tiny)
        if na(labelR2) and r2Multiple>0
            labelR2 := label.new(bar_index, r2Price, "Hedef2: " + fmtMint(r2Price), style=label.style_label_left, color=color.new(r2Color,0), textcolor=color.white, size=size.tiny)
        if not na(labelR1)
            label.set_x(labelR1, bar_index)
            label.set_y(labelR1, r1Price)
            label.set_text(labelR1, "Hedef1: " + fmtMint(r1Price))
        if not na(labelR2)
            label.set_x(labelR2, bar_index)
            label.set_y(labelR2, r2Price)
            label.set_text(labelR2, "Hedef2: " + fmtMint(r2Price))

// R hedefleri
hitR1 = false
hitR2 = false
if havePosition and showRTargets and riskDist>0
    r1Val = not na(lineR1) ? line.get_y1(lineR1) : na
    r2Val = not na(lineR2) ? line.get_y1(lineR2) : na
    if lastEntryDir==1
        if not r1HitForEntry and not na(r1Val) and high >= r1Val
            hitR1 := true
            r1HitForEntry := true
        if not r2HitForEntry and not na(r2Val) and high >= r2Val
            hitR2 := true
            r2HitForEntry := true
    else
        if not r1HitForEntry and not na(r1Val) and low <= r1Val
            hitR1 := true
            r1HitForEntry := true
        if not r2HitForEntry and not na(r2Val) and low <= r2Val
            hitR2 := true
            r2HitForEntry := true

exitShortIntUsed = htfApplyToExits ? shortIntersectEntry : shortIntersect_raw
exitLongIntUsed  = htfApplyToExits ? longIntersectEntry  : longIntersect_raw
exitLong  = havePosition and lastEntryDir==1  and (exitShortIntUsed or (eff_useFlipIfNoIntersect and sellSignal and entryConfirmed(true)))
exitShort = havePosition and lastEntryDir==-1 and (exitLongIntUsed  or (eff_useFlipIfNoIntersect and buySignal  and entryConfirmed(true)))
if exitLong or exitShort
    f_delete_all()
    lastEntryPrice := na
    initialStop := na
    liveStop := na
    lastEntryDir := 0

// ---
// 7.5) Pivot Destek/Direnç
// ---
var rsResLines  = array.new_line()
var rsResLabels = array.new_label()
var rsSupLines  = array.new_line()
var rsSupLabels = array.new_label()

f_push_line(_arrL, _arrLab, _l, _lab, _max)=>
    array.push(_arrL, _l)
    array.push(_arrLab, _lab)
    while array.size(_arrL) > _max
        oldL = array.shift(_arrL)
        if not na(oldL)
            line.delete(oldL)
    while array.size(_arrLab) > _max
        oldLb = array.shift(_arrLab)
        if not na(oldLb)
            label.delete(oldLb)

// Pivot High (Direnç)
pivotHighVal = ta.pivothigh(high, pivotLeft, pivotRight)
if showPivotRes and not na(pivotHighVal)
    x1 = bar_index - pivotRight
    y1 = pivotHighVal
    x2 = bar_index + pivotExtendBars
    phLine = line.new(x1, y1, x2, y1, extend=extend.none, color=pivotResColor, width=1, style=line.style_solid)
    label lb = na
    if showPivotLabels
        lb := label.new(x1, y1, TXT_RES, style=label.style_label_left, textcolor=color.white, color=color.new(pivotResColor, 0), size=size.tiny)
    f_push_line(rsResLines, rsResLabels, phLine, lb, maxPivotLevels)

// Pivot Low (Destek)
pivotLowVal = ta.pivotlow(low, pivotLeft, pivotRight)
if showPivotSup and not na(pivotLowVal)
    x1s = bar_index - pivotRight
    y1s = pivotLowVal
    x2s = bar_index + pivotExtendBars
    plLine = line.new(x1s, y1s, x2s, y1s, extend=extend.none, color=pivotSupColor, width=1, style=line.style_solid)
    label lbs = na
    if showPivotLabels
        lbs := label.new(x1s, y1s, TXT_SUP, style=label.style_label_left, textcolor=color.white, color=color.new(pivotSupColor, 0), size=size.tiny)
    f_push_line(rsSupLines, rsSupLabels, plLine, lbs, maxPivotLevels)

// ---
// 8) MODULE-2 (MesutTrend + MG) — 4H + 1D
// ---
f_at_mt(_ap,_coeff,_useRSI,_useOriginalATR)=>
    atrUsed = _useOriginalATR ? ta.sma(ta.tr(true),_ap) : ta.atr(_ap)
    upT=low-atrUsed*_coeff
    dnT=high+atrUsed*_coeff
    hasVol = not na(volume) and volume!=0
    cond = (_useRSI or not hasVol) ? ta.rsi(close,_ap)>=50 : ta.mfi(hlc3,_ap)>=50
    var float AT=na
    AT := cond ? math.max(upT,nz(AT[1])) : math.min(dnT,nz(AT[1]))
    buyK = ta.crossover(AT,AT[2])
    sellK= ta.crossunder(AT,AT[2])
    candleBuy     = ta.crossover(low[1], AT[1])
    candleSell    = ta.crossunder(high[1],AT[1])
    _qg_pass = f_buyqg_check()  // Calculate quality gate on this TF
    [AT,AT[2],AT[3],buyK[1],sellK[1],buyK,candleBuy,candleSell,close,atrUsed,_qg_pass]

// 4H “new bar” bayrağı
mt_isNew4h = eff_includeModule2 ? request.security(syminfo.tickerid, "240", barstate.isconfirmed, barmerge.gaps_off, barmerge.lookahead_off) : false

// 4H MT kalıcı değişkenler
var float mt_AT4       = na
var float mt_AT4_2     = na
var float mt_AT4_3     = na
var bool  mt_confirmedBuy4  = na
var bool  mt_confirmedSell4 = na
var bool  mt_earlyBuy4      = na
var bool  mt_candleBuy4     = na
var bool  mt_candleSell4    = na
var float mt_c4        = na
var float mt_atr4h     = na
var bool  mt_qg_pass4h = na

if eff_includeModule2
    [__AT4, __AT4_2, __AT4_3, __cBuy4, __cSell4, __eBuy4, __candBuy4, __candSell4, __c4, __atr4h, __qg4h] =       request.security(syminfo.tickerid, "240", f_at_mt(mt_AP, mt_coeff, mt_useRSI_noVolume, mt_useOriginalATR), barmerge.gaps_off, barmerge.lookahead_off)
    mt_AT4            := __AT4
    mt_AT4_2          := __AT4_2
    mt_AT4_3          := __AT4_3
    mt_confirmedBuy4  := __cBuy4
    mt_confirmedSell4 := __cSell4
    mt_earlyBuy4      := __eBuy4
    mt_candleBuy4     := __candBuy4
    mt_candleSell4    := __candSell4
    mt_c4             := __c4
    mt_atr4h          := __atr4h
    mt_qg_pass4h      := __qg4h

// 4H pulse bayrakları
mt_buyPulseConf      = eff_includeModule2 and mt_isNew4h and nz(mt_confirmedBuy4,  false)
mt_sellPulseConf     = eff_includeModule2 and mt_isNew4h and nz(mt_confirmedSell4, false)
mt_buyPulseEarly     = eff_includeModule2 and ((mt_isNew4h and mt_earlyBuy4) ? false : mt_earlyBuy4)
mt_buyPulseCandle    = eff_includeModule2 and mt_isNew4h and (mt_includeCandleCloseBuy and nz(mt_candleBuy4,  false))
mt_sellPulseCandle   = eff_includeModule2 and mt_isNew4h and nz(mt_candleSell4, false)
mt_buyPulseCombined  = eff_includeModule2 and mt_isNew4h and (nz(mt_confirmedBuy4,  false) and nz(mt_candleBuy4,  false))
mt_sellPulseCombined = eff_includeModule2 and mt_isNew4h and (nz(mt_confirmedSell4, false) and nz(mt_candleSell4, false))

// 4H Cooldown ve izinler
mt_cooldown_ms = mt_cooldown_minutes * 60 * 1000
var int mt_lastBuyTime  = na
var int mt_lastSellTime = na
mt_cooldownOkBuy()  => mt_cooldown_minutes==0 or na(mt_lastBuyTime)  or time - mt_lastBuyTime  > mt_cooldown_ms
mt_cooldownOkSell() => mt_cooldown_minutes==0 or na(mt_lastSellTime) or time - mt_lastSellTime > mt_cooldown_ms

mt_buyAllowedConf      = eff_includeModule2 and mt_buyPulseConf      and mt_cooldownOkBuy()
mt_buyAllowedCombined  = eff_includeModule2 and mt_buyPulseCombined  and mt_cooldownOkBuy()
mt_sellAllowedConf     = eff_includeModule2 and mt_sellPulseConf     and mt_cooldownOkSell() and mt_enableSellAlerts
mt_sellAllowedCombined = eff_includeModule2 and mt_sellPulseCombined and mt_cooldownOkSell()
mt_buyAllowedEarly     = eff_includeModule2 and mt_buyPulseEarly
mt_buyAllowedCandle    = eff_includeModule2 and mt_buyPulseCandle

// Apply QG to M2 4H signals using 4H quality check
mt_buyAllowedConf      := mt_buyAllowedConf      and ((not buyQG_enable) or (not buyQG_apply_m2) or mt_qg_pass4h)
mt_buyAllowedCombined  := mt_buyAllowedCombined  and ((not buyQG_enable) or (not buyQG_apply_m2) or mt_qg_pass4h)
mt_buyAllowedEarly     := mt_buyAllowedEarly     and ((not buyQG_enable) or (not buyQG_apply_m2) or mt_qg_pass4h)
mt_buyAllowedCandle    := mt_buyAllowedCandle    and ((not buyQG_enable) or (not buyQG_apply_m2) or mt_qg_pass4h)

if mt_buyAllowedConf or mt_buyAllowedCombined
    mt_lastBuyTime := time
if mt_sellAllowedConf or mt_sellAllowedCombined
    mt_lastSellTime := time

// 1D “new bar” bayrağı
mt_isNew1d = eff_includeModule2 ? request.security(syminfo.tickerid, "D", barstate.isconfirmed, barmerge.gaps_off, barmerge.lookahead_off) : false

// 1D MT kalıcı değişkenler
var float mt_AT1D       = na
var float mt_AT1D_2     = na
var float mt_AT1D_3     = na
var bool  mt_confirmedBuy1D  = na
var bool  mt_confirmedSell1D = na
var bool  mt_earlyBuy1D      = na
var bool  mt_candleBuy1D     = na
var bool  mt_candleSell1D    = na
var float mt_c1D        = na
var float mt_atr1D      = na
var bool  mt_qg_pass1d  = na

if eff_includeModule2
    [__ATD, __ATD_2, __ATD_3, __cBuyD, __cSellD, __eBuyD, __candBuyD, __candSellD, __cD, __atrD, __qg1d] =     request.security(syminfo.tickerid, "D", f_at_mt(mt_AP, mt_coeff, mt_useRSI_noVolume, mt_useOriginalATR), barmerge.gaps_off, barmerge.lookahead_off)
    mt_AT1D            := __ATD
    mt_AT1D_2          := __ATD_2
    mt_AT1D_3          := __ATD_3
    mt_confirmedBuy1D  := __cBuyD
    mt_confirmedSell1D := __cSellD
    mt_earlyBuy1D      := __eBuyD
    mt_candleBuy1D     := __candBuyD
    mt_candleSell1D    := __candSellD
    mt_c1D             := __cD
    mt_atr1D           := __atrD
    mt_qg_pass1d       := __qg1d

// 1D pulse bayrakları
mt_buyPulseConf1D      = eff_includeModule2 and mt_isNew1d and nz(mt_confirmedBuy1D,  false)
mt_sellPulseConf1D     = eff_includeModule2 and mt_isNew1d and nz(mt_confirmedSell1D, false)
mt_buyPulseEarly1D     = eff_includeModule2 and ((mt_isNew1d and mt_earlyBuy1D) ? false : mt_earlyBuy1D)
mt_buyPulseCandle1D    = eff_includeModule2 and mt_isNew1d and (mt_includeCandleCloseBuy and nz(mt_candleBuy1D,  false))
mt_sellPulseCandle1D   = eff_includeModule2 and mt_isNew1d and nz(mt_candleSell1D, false)
mt_buyPulseCombined1D  = eff_includeModule2 and mt_isNew1d and (nz(mt_confirmedBuy1D,  false) and nz(mt_candleBuy1D,  false))
mt_sellPulseCombined1D = eff_includeModule2 and mt_isNew1d and (nz(mt_confirmedSell1D, false) and nz(mt_candleSell1D, false))

// 1D Cooldown ve izinler
var int mt_lastBuyTime1D  = na
var int mt_lastSellTime1D = na
mt_cooldownOkBuy1D()  => mt_cooldown_minutes==0 or na(mt_lastBuyTime1D)  or time - mt_lastBuyTime1D  > mt_cooldown_ms
mt_cooldownOkSell1D() => mt_cooldown_minutes==0 or na(mt_lastSellTime1D) or time - mt_lastSellTime1D > mt_cooldown_ms

mt_buyAllowedConf1D      = eff_includeModule2 and mt_buyPulseConf1D      and mt_cooldownOkBuy1D()
mt_buyAllowedCombined1D  = eff_includeModule2 and mt_buyPulseCombined1D  and mt_cooldownOkBuy1D()
mt_sellAllowedConf1D     = eff_includeModule2 and mt_sellPulseConf1D     and mt_cooldownOkSell1D() and mt_enableSellAlerts
mt_sellAllowedCombined1D = eff_includeModule2 and mt_sellPulseCombined1D and mt_cooldownOkSell1D()
mt_buyAllowedEarly1D     = eff_includeModule2 and mt_buyPulseEarly1D
mt_buyAllowedCandle1D    = eff_includeModule2 and mt_buyPulseCandle1D

// Apply QG to M2 1D signals using 1D quality check
mt_buyAllowedConf1D      := mt_buyAllowedConf1D      and ((not buyQG_enable) or (not buyQG_apply_m2) or mt_qg_pass1d)
mt_buyAllowedCombined1D  := mt_buyAllowedCombined1D  and ((not buyQG_enable) or (not buyQG_apply_m2) or mt_qg_pass1d)
mt_buyAllowedEarly1D     := mt_buyAllowedEarly1D     and ((not buyQG_enable) or (not buyQG_apply_m2) or mt_qg_pass1d)
mt_buyAllowedCandle1D    := mt_buyAllowedCandle1D    and ((not buyQG_enable) or (not buyQG_apply_m2) or mt_qg_pass1d)

if mt_buyAllowedConf1D or mt_buyAllowedCombined1D
    mt_lastBuyTime1D := time
if mt_sellAllowedConf1D or mt_sellAllowedCombined1D
    mt_lastSellTime1D := time

// MG Chart
f_mg_macd_pack(_fast, _slow, _signal) =>
    _fma  = ta.ema(close, _fast)
    _sma  = ta.ema(close, _slow)
    _macd = _fma - _sma
    _sig  = ta.sma(_macd, _signal)
    _hist = _macd - _sig
    [_macd, _sig, _hist]

[mtf_macd, mtf_signal, mtf_hist] =  request.security(syminfo.tickerid, mg_macdTF, f_mg_macd_pack(mg_periodMACD, mg_slowMACD, mg_signalMACD), barmerge.gaps_off, barmerge.lookahead_off)

ma_src=close
ma_actual =
     mg_maType=="SMA"? ta.sma(ma_src, mg_maLen) :
     mg_maType=="EMA"? ta.ema(ma_src, mg_maLen) :
     mg_maType=="WMA"? ta.wma(ma_src, mg_maLen) :
     mg_maType=="HullMA"? ta.wma(2*ta.wma(ma_src, math.round(mg_maLen/2)) - ta.wma(ma_src, mg_maLen), math.round(math.sqrt(mg_maLen))) :
     mg_maType=="VWMA"? ta.vwma(ma_src, mg_maLen) :
     mg_maType=="RMA"? ta.rma(ma_src, mg_maLen) :
     mg_maType=="TEMA"? 3*(ta.ema(ma_src, mg_maLen)-ta.ema(ta.ema(ma_src, mg_maLen), mg_maLen))+ta.ema(ta.ema(ta.ema(ma_src, mg_maLen), mg_maLen), mg_maLen) :
     mg_maType=="TilsonT3"? ta.ema(ma_src, mg_maLen)*0.7 - ta.ema(ta.ema(ma_src, mg_maLen), mg_maLen)*0.3 :
     ta.ema(ma_src, mg_maLen)

mtf_ma  = request.security(syminfo.tickerid, mg_maTF, ma_actual, barmerge.gaps_off, barmerge.lookahead_off)
ma_up   = mtf_ma >= mtf_ma[1]
ma_is_green = ma_up and close > mtf_ma
alphaATR = ta.sma(ta.tr(true), mg_alphaPeriod)
upTmg = low - alphaATR*mg_alphaCoeff
downTmg = high + alphaATR*mg_alphaCoeff
var float alphaTrendMG=na
alphaTrendMG := ta.rsi(close, mg_alphaPeriod)>=50 ? (upTmg < nz(alphaTrendMG[1]) ? nz(alphaTrendMG[1]) : upTmg)
                                                 : (downTmg > nz(alphaTrendMG[1]) ? nz(alphaTrendMG[1]) : downTmg)
alphaBuyMG = ta.crossover(alphaTrendMG, alphaTrendMG[2])
mtf_rsi = request.security(syminfo.tickerid, mg_rsiTF, ta.rsi(close, mg_rsiLen), barmerge.gaps_off, barmerge.lookahead_off)
score_buy = (alphaBuyMG?1:0) + ((ta.crossover(mtf_macd, mtf_signal) and (mtf_hist>0) )?1:0) + (ma_is_green?1:0) + ((mg_useRSIConfirm and (mtf_rsi > mg_rsiThresh))?1:0)
strong_buy = eff_includeModule2 and (score_buy >= (mg_useRSIConfirm?4:3)) and (showStrongShapeFiltered ? not buyBlockedByPct : true)
// Apply QG to MG signals
strong_buy := strong_buy and ((not buyQG_enable) or (not buyQG_apply_mg) or buyqg_quality_pass)
plotshape(eff_includeModule2 and strong_buy, style=shape.labelup, location=location.belowbar, color=color.green, text="MULTI GÜÇLÜ AL", size=size.normal, title="M2 MULTI GÜÇLÜ AL")

if eff_includeModule2 and mg_enableAlertsChart and barstate.isconfirmed and strong_buy
    id_mg_chart = "MG_CHART_BUY_" + str.tostring(bar_index)
    [tgTR, tgEN] = f_target_block_buy(close, (trailStopEnabled and havePosition and not na(liveStop) ? liveStop : stUp))
    headerTR = "🟢 Multi Güçlü AL [" + syminfo.ticker + "] [" + f_tf_label(timeframe.period) + "]"
    headerEN = "🟢 Multi Strong BUY [" + syminfo.ticker + "] [" + f_tf_label(timeframe.period) + "]"
    pgBlock  = (unifiedIncludePG and eff_pg_enable and pg_ctx_for_unified_buy!="") ? ((etiketDil=="TR" ? "\nPG:\n" : "\nPG\n") + pg_ctx_for_unified_buy) : ""
    techCtx  = tech_ctx_for_unified_buy != "" ? tech_ctx_for_unified_buy : f_quick_tech_ctx()
    techBlock= (etiketDil=="TR" ? "\nTEK\n" : "\nTECH\n") + techCtx
    prevNote = f_prev_bullish_note()
    bodyTR   = "\nFiyat: " + fmtMint(close) + tgTR + pgBlock + techBlock + prevNote
    bodyEN   = "\nPrice: " + fmtMint(close) + tgEN + pgBlock + techBlock + prevNote
    msg_mg_chart = (etiketDil=="TR" ? headerTR + bodyTR : headerEN + bodyEN)
    send_event(id_mg_chart, msg_mg_chart, fChatId(true, false), alert.freq_once_per_bar_close)
    [lastBullishTime, lastBullishPrice, lastBullishTextTR, lastBullishTextEN, lastBullishTF] = f_record_bullish("Multi Güçlü AL","Multi Strong BUY", f_tf_label(timeframe.period))

// MG MTF
f_alpha_buy_for_tf(_p, _k) =>
    aATR = ta.sma(ta.tr(true), _p)
    upT  = low  - aATR*_k
    dnT  = high + aATR*_k
    var float AT = na
    AT := ta.rsi(close, _p)>=50 ? math.max(upT, nz(AT[1])) : math.min(dnT, nz(AT[1]))
    ta.crossover(AT, AT[2])

f_macd_buy_for_tf(_fast, _slow, _signal) =>
    fma  = ta.ema(close, _fast)
    sma_ = ta.ema(close, _slow)
    macd = fma - sma_
    sig  = ta.sma(macd, _signal)
    hist = macd - sig
    (ta.crossover(macd, sig) and hist > 0)

f_ma_green_for_tf(_len, _type) =>
    maVal =
         _type=="SMA"? ta.sma(close, _len) :
         _type=="EMA"? ta.ema(close, _len) :
         _type=="WMA"? ta.wma(close, _len) :
         _type=="HullMA"? ta.wma(2*ta.wma(close, math.round(_len/2)) - ta.wma(close, _len), math.round(math.sqrt(_len))) :
         _type=="VWMA"? ta.vwma(close, _len) :
         _type=="RMA"? ta.rma(close, _len) :
         _type=="TEMA"? 3*(ta.ema(close, _len)-ta.ema(ta.ema(close, _len), _len))+ta.ema(ta.ema(ta.ema(close, _len), _len), _len) :
         _type=="TilsonT3"? ta.ema(close, _len)*0.7 - ta.ema(ta.ema(close, _len), _len)*0.3 :
         ta.ema(close, _len)
    (maVal >= maVal[1]) and (close > maVal)

f_mg_strong_on_tf(_tf) =>
    alphaB = request.security(syminfo.tickerid, _tf, f_alpha_buy_for_tf(mg_alphaPeriod, mg_alphaCoeff), barmerge.gaps_off, barmerge.lookahead_off)
    macdB  = request.security(syminfo.tickerid, _tf, f_macd_buy_for_tf(mg_periodMACD, mg_slowMACD, mg_signalMACD), barmerge.gaps_off, barmerge.lookahead_off)
    maG    = request.security(syminfo.tickerid, _tf, f_ma_green_for_tf(mg_maLen, mg_maType), barmerge.gaps_off, barmerge.lookahead_off)
    rsiOk  = mg_useRSIConfirm ? request.security(syminfo.tickerid, _tf, ta.rsi(close, mg_rsiLen) > mg_rsiThresh, barmerge.gaps_off, barmerge.lookahead_off) : true
    sc = (alphaB?1:0) + (macdB?1:0) + (maG?1:0) + (rsiOk?1:0)
    need = mg_useRSIConfirm ? 4 : 3
    eff_includeModule2 and (sc >= need)

sendMgMtf(tf, tfLabel, useTf)=>
    // Skip if requested timeframe is not higher than chart timeframe (prevents redundant calls and errors)
    if eff_includeModule2 and eff_mg_enableAlertsMTF and useTf and f_is_higher_tf(tf)
        tfClosed = request.security(syminfo.tickerid, tf, barstate.isconfirmed, barmerge.gaps_off, barmerge.lookahead_off)
        mgStrong = f_mg_strong_on_tf(tf)
        // Apply QG
        mgStrong := mgStrong and ((not buyQG_enable) or (not buyQG_apply_mg) or buyqg_quality_pass)
        if tfClosed and mgStrong
            [tgTR, tgEN] = f_target_block_buy(close, (trailStopEnabled and havePosition and not na(liveStop) ? liveStop : stUp))
            id  = "MG_MTF_"+tfLabel+"_BUY_" + str.tostring(bar_index)
            hdrTR = "🟢 MTF Multi Güçlü AL [" + syminfo.ticker + "] " + tfLabel
            hdrEN = "🟢 MTF Multi Strong BUY [" + syminfo.ticker + "] " + tfLabel
            pgBlock  = (unifiedIncludePG and eff_pg_enable and pg_ctx_for_unified_buy!="") ? ((etiketDil=="TR" ? "\nPG:\n" : "\nPG\n") + pg_ctx_for_unified_buy) : ""
            techCtx  = tech_ctx_for_unified_buy != "" ? tech_ctx_for_unified_buy : f_quick_tech_ctx()
            techBlock= (etiketDil=="TR" ? "\nTEK\n" : "\nTECH\n") + techCtx
            prevNote = f_prev_bullish_note()
            bodyTR   = "\nFiyat: " + fmtMint(close) + tgTR + pgBlock + techBlock + prevNote
            bodyEN   = "\nPrice: " + fmtMint(close) + tgEN + pgBlock + techBlock + prevNote
            msg = (etiketDil=="TR" ? hdrTR + bodyTR : hdrEN + bodyEN)
            send_event(id, msg, fChatId(true,false), alert.freq_once_per_bar_close)
            [lastBullishTime, lastBullishPrice, lastBullishTextTR, lastBullishTextEN, lastBullishTF] = f_record_bullish("MTF Multi Güçlü AL","MTF Multi Strong BUY", tfLabel)

sendMgMtf("60","1H", mtf_use_1h)
sendMgMtf("240","4H", mtf_use_4h)
sendMgMtf("D","1D", mtf_use_1d)

// ---
// 9) PG MODÜL (Chart TF) + Yüksek Güven
// ---
var bool buyHC = na
var bool selHC = na
var bool pg_buy_sig_base = na
var bool pg_sell_sig_base = na

f_pg_cmf(h,l,c,v,len)=>
    hhll=h-l
    mfm=hhll!=0?((c-l)-(h-c))/hhll:0.0
    mfv=mfm*v
    sum_mfv=ta.sma(mfv,len)*len
    sum_vol=ta.sma(v,len)*len
    sum_vol!=0?sum_mfv/sum_vol:0.0

f_pg_dmi(len)=>
    upMove=high-high[1]
    downMove=low[1]-low
    plusDM=(upMove>downMove and upMove>0)?upMove:0.0
    minusDM=(downMove>upMove and downMove>0)?downMove:0.0
    tr1=high-low
    tr2=math.abs(high-close[1])
    tr3=math.abs(low -close[1])
    tr =math.max(tr1,math.max(tr2,tr3))
    atr=ta.rma(tr,len)
    plusDI = atr!=0?100*ta.rma(plusDM,len)/atr:0.0
    minusDI= atr!=0?100*ta.rma(minusDM,len)/atr:0.0
    dx=(plusDI+minusDI!=0)?100*math.abs(plusDI-minusDI)/(plusDI+minusDI):0.0
    adx=ta.rma(dx,len)
    [plusDI,minusDI,adx]

f_ad_slope(h,l,c,v,len)=>
    hhll=h-l
    mfm=hhll!=0?((c-l)-(h-c))/hhll:0.0
    mfv=mfm*v
    ta.sma(mfv, len)

pg_json_global = useCustomJsonAlert
pg_json_local  = pg_use_json_telegram
pg_json = pg_json_local or pg_json_global

var string pg_dayBuy  = ""
// var string pg_daySell = ""
var int    pg_tBuy    = na
// var int    pg_tSell   = na
pg_cool_ms = pg_cooldown_minutes * 60 * 1000

float pg_vol_sma     = na
float pg_vol_stdev   = na
float pg_vol_z       = na
bool  pg_spike       = false
float pg_cmf         = na
bool  pg_money_in    = false
bool  pg_money_out   = false
float pg_htf_cmf     = na

pg_htf_cmf_val = eff_pg_enable ? request.security(syminfo.tickerid, pg_htf_cmf_tf, f_pg_cmf(high,low,close,volume,pg_cmf_period), barmerge.gaps_off, barmerge.lookahead_off) : na

if eff_pg_enable
    pg_vol_sma   := ta.sma(volume, pg_vol_period)
    pg_vol_stdev := ta.stdev(volume, pg_vol_period)
    pg_vol_z     := pg_vol_stdev>0 ? (volume-pg_vol_sma)/pg_vol_stdev : 0.0
    pg_spike_sma = volume > pg_vol_sma * pg_vol_multiplier
    pg_spike_z   = pg_vol_z > pg_vol_z_threshold
    pg_spike     := pg_use_zscore_vol ? pg_spike_z : pg_spike_sma

    pg_cmf       := f_pg_cmf(high,low,close,volume,pg_cmf_period)
    pg_money_in  := pg_cmf > pg_cmf_pos_th
    pg_money_out := pg_cmf < pg_cmf_neg_th

    pg_htf_cmf := pg_enable_htf_cmf ? pg_htf_cmf_val : na
    pg_ok_buy   = not pg_enable_htf_cmf or (pg_htf_cmf >= pg_cmf_pos_th)
    pg_ok_sell  = not pg_enable_htf_cmf or (pg_htf_cmf <= pg_cmf_neg_th)

    pg_vwap = ta.vwap(pg_vwap_source)
    var float pg_cum_pv = na
    var float pg_cum_vol = na
    var bool  pg_anch_on = false
    var float pg_anch_vwap = na
    pg_new_sess = ta.change(time("D")) != 0
    if pg_anchor_use_session and pg_new_sess
        pg_cum_pv := 0.0
        pg_cum_vol := 0.0
        pg_anch_on := true
        pg_anch_vwap := na
    if pg_use_anchor_by_time and not pg_anchor_use_session
        if (time >= pg_anchor_time) and not pg_anch_on
            pg_cum_pv := 0.0
            pg_cum_vol := 0.0
            pg_anch_on := true
            pg_anch_vwap := na
    if pg_anch_on
        pg_cum_pv  := nz(pg_cum_pv)  + (pg_vwap_source * volume)
        pg_cum_vol := nz(pg_cum_vol) + volume
        pg_anch_vwap := pg_cum_vol > 0 ? pg_cum_pv/pg_cum_vol : na
    else
        pg_anch_vwap := na

    pg_ma_mid = pg_bb_ma_type=="SMA" ? ta.sma(pg_bb_src, pg_bb_length) : ta.ema(pg_bb_src, pg_bb_length)
    pg_bb_dev = ta.stdev(pg_bb_src, pg_bb_length)
    pg_bb_up  = pg_ma_mid + pg_bb_mult*pg_bb_dev
    pg_bb_dn  = pg_ma_mid - pg_bb_mult*pg_bb_dev

    float pg_value = na
    string pg_label_val = ""
    if pg_va_mode=="VWAP" or pg_va_mode=="Anchored VWAP"
        pg_value := nz(pg_anch_vwap, pg_vwap)
        pg_label_val := "VW"
    else
        pg_value := pg_ma_mid
        pg_label_val := "BB"

    pg_above = na(pg_value) ? false : close > pg_value
    pg_below = na(pg_value) ? false : close < pg_value

    [pg_di_p, pg_di_m, pg_adx_val] = f_pg_dmi(pg_adx_len)
    ad_slope_val = f_ad_slope(high, low, close, volume, pg_ad_slope_len)

    pg_raw_buy  = pg_spike and pg_money_in  and pg_above and close>open and pg_ok_buy
    pg_raw_sell = pg_spike and pg_money_out and pg_below and close<open and pg_ok_sell
    pg_confirm  = pg_use_close_confirm ? barstate.isconfirmed : true

    pg_buy_sig_base  := pg_raw_buy  and pg_confirm and (not pg_require_di_align or pg_di_p > pg_di_m) and (not pg_require_ad_confirm or ad_slope_val > 0)
    pg_sell_sig_base := pg_raw_sell and pg_confirm and (not pg_require_di_align or pg_di_m > pg_di_p) and (not pg_require_ad_confirm or ad_slope_val < 0)

    rangeV     = math.max(high - low, syminfo.mintick*5)
    bodyRatio  = math.abs(close - open) / rangeV
    closePos   = (close - low) / rangeV
    closePosSell = (high - close) / rangeV
    vwapDistPct = na(pg_value) ? 0.0 : math.abs(close - pg_value) / close * 100.0
    diDiff     = math.abs(pg_di_p - pg_di_m)

    adx_ok     = pg_adx_val >= pg_hc_min_adx
    di_ok      = (not pg_require_di_align) or diDiff >= pg_hc_min_di_diff
    cmf_ok_buy = pg_cmf >= pg_hc_cmf_pos
    cmf_ok_sel = pg_cmf <= pg_hc_cmf_neg
    body_ok_b  = (bodyRatio*100.0 >= pg_hc_min_body_pct) and (closePos*100.0 >= (100.0 - pg_hc_close_near_pct))
    body_ok_s  = (bodyRatio*100.0 >= pg_hc_min_body_pct) and (closePosSell*100.0 >= (100.0 - pg_hc_close_near_pct))
    vwap_ok    = vwapDistPct >= pg_hc_vwap_dist_pct

    strongAccum  = (pg_cmf >= pg_hc_cmf_pos) and (ad_slope_val > 0) and pg_above
    negDayBlock  = pg_hc_neg_day_rule and (dayChangePct < 0) and (not strongAccum)
    buyHC := adx_ok and di_ok and cmf_ok_buy and pg_above and body_ok_b and vwap_ok and not negDayBlock
    selHC := adx_ok and di_ok and cmf_ok_sel and pg_below and body_ok_s and vwap_ok

    pg_buy_sig  = pg_hc_enable ? (pg_buy_sig_base  and buyHC) : pg_buy_sig_base
    pg_sell_sig = pg_hc_enable ? (pg_sell_sig_base and selHC)  : pg_sell_sig_base

    pg_trend_ema = ta.ema(close, pg_trend_len)
    pg_trend_stat= etiketDil=="TR" ? (close>pg_trend_ema ? "YUK" : "DUS") : (close>pg_trend_ema ? "UP" : "DOWN")
    [pg_macd, pg_macd_sig, pg_hist] = ta.macd(close, pg_fast_len, pg_slow_len, pg_signal_len)
    pg_macd_stat = etiketDil=="TR" ? (pg_macd>pg_macd_sig ? "POZ" : "NEG") : (pg_macd>pg_macd_sig ? "POS" : "NEG")
    pg_adx_interp= etiketDil=="TR" ? (pg_adx_val > pg_adx_threshold ? "GT" : "ZAY") : (pg_adx_val > pg_adx_threshold ? "ST" : "WEAK")
    pg_atr       = ta.atr(pg_atr_len)
    pg_vdiff     = na(pg_value)?na:(close-pg_value)

    string pg_bb_pos = ""
    if pg_va_mode=="MA+Bollinger"
        pg_bb_pos := etiketDil=="TR" ? (close > pg_bb_up ? "ÜST" : (close < pg_bb_dn ? "ALT" : "İÇ"))
                                     : (close > pg_bb_up ? "ABOVE" : (close < pg_bb_dn ? "BELOW" : "IN"))

    string __pg_val_line_tr = ""
    string __pg_val_line_en = ""
    if pg_va_mode=="MA+Bollinger"
        __pg_val_line_tr := "\nBB Konumu: " + pg_bb_pos
        __pg_val_line_en := "\nBB Position: " + pg_bb_pos
    else
        __pg_val_line_tr := "\nDeğer: " + pg_label_val + (not na(pg_vdiff) ? "  Δ: " + str.tostring(pg_vdiff, "#.####") : "")
        __pg_val_line_en := "\nValue: " + pg_label_val + (not na(pg_vdiff) ? "  Δ: " + str.tostring(pg_vdiff, "#.####") : "")

    string pg_ctx_tr =
          "TR:" + pg_trend_stat +
          "\nMACD: " + pg_macd_stat +
          "\nADX: " + str.tostring(pg_adx_val, "#.##") + " (" + pg_adx_interp + ")" +
          "\nATR: " + str.tostring(pg_atr, "#.##") +
          "\nCMF: " + str.tostring(pg_cmf, "#.###") +
          __pg_val_line_tr

    string pg_ctx_en =
          "TR:" + pg_trend_stat +
          "\nMACD: " + pg_macd_stat +
          "\nADX: " + str.tostring(pg_adx_val, "#.##") + " (" + pg_adx_interp + ")" +
          "\nATR: " + str.tostring(pg_atr, "#.##") +
          "\nCMF: " + str.tostring(pg_cmf, "#.###") +
          __pg_val_line_en

    pg_ctx_for_unified_buy := (etiketDil=="TR" ? pg_ctx_tr : pg_ctx_en)
    PG_CTX_TR := pg_ctx_tr
    PG_CTX_EN := pg_ctx_en

    string hdrB_tr = "", hdrB_en = "", valueLine_tr = "", valueLine_en = "", body_tr = "", body_en = "", txtB = ""
    // string hdrS_tr = "", hdrS_en = "", body_tr_s = "", body_en_s = "", txtS = ""

    canSendNow = true
    pg_buy_blocked_pct = pg_suppress_buy_if_daily_up and (dayChangePct >= pg_daily_up_pct_threshold)
    pg_currDay = str.format("{0}-{1}-{2}", year(time), month(time), dayofmonth(time))

    allowChartBuy  = f_pg_allow(pg_enable_alerts and pg_chart_also_send and pg_buy_sig  and not pg_buy_blocked_pct, pg_dayBuy,  pg_tBuy,  pg_daily_once, pg_cooldown_minutes, time, pg_currDay)
    // allowChartSell = f_pg_allow(pg_enable_alerts and pg_chart_also_send and pg_sell_sig, pg_daySell, pg_tSell, pg_daily_once, pg_cooldown_minutes, time, pg_currDay)


    if canSendNow and allowChartBuy
        hdrB_tr := "💰 PG GİRİŞ — " + syminfo.ticker + " [" + f_tf_label(timeframe.period) + "]"
        hdrB_en := "💰 PG IN — " + syminfo.ticker + " [" + f_tf_label(timeframe.period) + "]"
        valueLine_tr := pg_va_mode=="MA+Bollinger" ? "\nBB Konumu: " + pg_bb_pos : "\nDeğer: " + pg_label_val + (not na(pg_vdiff) ? "  Δ: " + str.tostring(pg_vdiff, "#.####") : "")
        valueLine_en := pg_va_mode=="MA+Bollinger" ? "\nBB Position: " + pg_bb_pos : "\nValue: " + pg_label_val + (not na(pg_vdiff) ? "  Δ: " + str.tostring(pg_vdiff, "#.####") : "")
        prevNotePG = f_prev_bullish_note()
        body_tr := "\nFiyat: " + fmtMint(close) + "\nTR:" + pg_trend_stat + "\nMACD: " + pg_macd_stat + "\nADX: " + str.tostring(pg_adx_val, "#.##") + " (" + pg_adx_interp + ")\nATR: " + str.tostring(pg_atr, "#.##") + "\nCMF: " + str.tostring(pg_cmf, "#.###") + valueLine_tr + prevNotePG
        body_en := "\nPrice: " + fmtMint(close) + "\nTR:" + pg_trend_stat + "\nMACD: " + pg_macd_stat + "\nADX: " + str.tostring(pg_adx_val, "#.##") + " (" + pg_adx_interp + ")\nATR: " + str.tostring(pg_atr, "#.##") + "\nCMF: " + str.tostring(pg_cmf, "#.###") + valueLine_en + prevNotePG
        txtB := (etiketDil=="TR" ? hdrB_tr + body_tr : hdrB_en + body_en)
        send_event("PG_CHART_BUY_"+str.tostring(bar_index), txtB, f_pg_chat(true), alert.freq_once_per_bar_close)
        pg_dayBuy := pg_currDay
        pg_tBuy   := time
        [lastBullishTime, lastBullishPrice, lastBullishTextTR, lastBullishTextEN, lastBullishTF] = f_record_bullish("PG GİRİŞ","PG IN", f_tf_label(timeframe.period))

    // PG EXIT disabled
    // if canSendNow and allowChartSell
    //     hdrS_tr := "💨 PG ÇIKIŞ — " + syminfo.ticker + " [" + f_tf_label(timeframe.period) + "]"
    //     hdrS_en := "💨 PG OUT — " + syminfo.ticker + " [" + f_tf_label(timeframe.period) + "]"
    //     valueLine_tr := pg_va_mode=="MA+Bollinger" ? "\nBB Konumu: " + pg_bb_pos : "\nDeğer: " + pg_label_val + (not na(pg_vdiff) ? "  Δ: " + str.tostring(pg_vdiff, "#.####") : "")
    //     valueLine_en := pg_va_mode=="MA+Bollinger" ? "\nBB Position: " + pg_bb_pos : "\nValue: " + pg_label_val + (not na(pg_vdiff) ? "  Δ: " + str.tostring(pg_vdiff, "#.####") : "")
    //     body_tr_s := "\nFiyat: " + fmtMint(close) + "\nTR:" + pg_trend_stat + "\nMACD: " + pg_macd_stat + "\nADX: " + str.tostring(pg_adx_val, "#.##") + " (" + pg_adx_interp + ")\nATR: " + str.tostring(pg_atr, "#.##") + "\nCMF: " + str.tostring(pg_cmf, "#.###") + valueLine_tr
    //     body_en_s := "\nPrice: " + fmtMint(close) + "\nTR:" + pg_trend_stat + "\nMACD: " + pg_macd_stat + "\nADX: " + str.tostring(pg_adx_val, "#.##") + " (" + pg_adx_interp + ")\nATR: " + str.tostring(pg_atr, "#.##") + "\nCMF: " + str.tostring(pg_cmf, "#.###") + valueLine_en
    //     txtS := (etiketDil=="TR" ? hdrS_tr + body_tr_s : hdrS_en + body_en_s)
    //     send_event("PG_CHART_SELL_"+str.tostring(bar_index), txtS, f_pg_chat(false), alert.freq_once_per_bar_close)

// ---
// 10) HYBRID POTENTIAL
// ---
var float __barDurationMs = 0.0
if barstate.isnew
    __barDurationMs := nz(time - time[1], time_close - time)
isRT = barstate.isrealtime
barProgressPct = isRT and __barDurationMs > 0 ? (timenow - time) / __barDurationMs * 100.0 : 100.0
barProgressPct := math.min(math.max(barProgressPct, 0.0), 100.0)

var int potBuyStableCount  = 0
var int potSellStableCount = 0
potRawBuy  = buySignal
potRawSell = sellSignal
potBuyStableCount  := potRawBuy  ? potBuyStableCount + 1 : 0
potSellStableCount := potRawSell ? potSellStableCount + 1 : 0

var int potBuyBarSent  = na
var int potSellBarSent = na
hybCooldownMs = eff_hybCooldownMinutes * 60 * 1000
var int potLastBuyTime  = na
var int potLastSellTime = na
potCooldownOkBuy  = eff_hybCooldownMinutes==0 or na(potLastBuyTime)  or (time - potLastBuyTime  > hybCooldownMs)
potCooldownOkSell = eff_hybCooldownMinutes==0 or na(potLastSellTime) or (time - potLastSellTime > hybCooldownMs)

eligiblePotBuy  = enableHybrid and potRawBuy  and htfOkLongLabel  and isRT and barProgressPct >= eff_hybMinProgressPct and potBuyStableCount  >= eff_hybStabilityTicks and (na(potBuyBarSent)  or bar_index != potBuyBarSent)  and potCooldownOkBuy and not combinePotAndConfirm
eligiblePotSell = enableHybrid and potRawSell and htfOkShortLabel and isRT and barProgressPct >= eff_hybMinProgressPct and potSellStableCount >= eff_hybStabilityTicks and (na(potSellBarSent) or bar_index != potSellBarSent) and potCooldownOkSell and not combinePotAndConfirm

// ---
// 11) CONFIRMED EVENTS (Unified Build) + SQZ
// ---
confirmWrap(c)=> (not useCloseConfirm or barstate.isconfirmed)?c:false
evBuy   = confirmWrap(includeBuyFlip        and buySignal          and htfOkLongAlert)
evSell  = confirmWrap(includeSellFlip       and sellSignal         and htfOkShortAlert)
evLInt  = confirmWrap(includeLongIntersect  and longIntersectAlert)
evSInt  = confirmWrap(includeShortIntersect and shortIntersectAlert)
evHit1  = confirmWrap(includeHitR1          and hitR1)
evHit2  = confirmWrap(includeHitR2          and hitR2)
evTrail = confirmWrap(includeTrailMove      and trailMoved)
evExit  = confirmWrap(includeExit           and (exitLong or exitShort))
if evLInt
    evBuy := false
if evSInt
    evSell := false

string tech_htf = ""
if not enableHTF
    tech_htf := etiketDil=="TR" ? "HTF: Kapalı" : "HTF: Off"
else
    string htfDirStr2 = etiketDil=="TR" ? (htfUp ? "Yukarı" : htfDn ? "Aşağı" : "Yatay") : (htfUp ? "Up" : htfDn ? "Down" : "Flat")
    string slopeStr2  = htfSlopeConfirm ? (etiketDil=="TR" ? (" (Eğim " + (htfSlope >= 0 ? "≥0" : "<0") + ")") : (" (Slope " + (htfSlope >= 0 ? "≥0" : "<0") + ")")) : ""
    tech_htf := "HTF:" + htfDirStr2 + slopeStr2 + " [" + htfModeAlerts + "]"
string st_event = ""
if evLInt
    st_event := etiketDil=="TR" ? "SuperTR:BANKO KESİŞME AL" : "SuperTR:BANKO LONG INTERSECT"
else if evBuy
    st_event := etiketDil=="TR" ? "SuperTR:AL Flip" : "SuperTR:Buy Flip"
else if evSInt
    st_event := etiketDil=="TR" ? "SuperTR:BANKO KESİŞME SAT" : "SuperTR:BANKO SHORT INTERSECT"
else if evSell
    st_event := etiketDil=="TR" ? "SuperTR:SAT Flip" : "SuperTR:Sell Flip"
string slingshot_note = ""
if consUp
    slingshot_note := etiketDil=="TR" ? "SS: Con Up" : "SS: Con Up"
else if consDn
    slingshot_note := etiketDil=="TR" ? "SS: Con Down" : "SS: Con Down"
tech_ctx_for_unified_buy := tech_htf + (st_event!="" ? ("\n" + st_event) : "") + (slingshot_note!="" ? ("\n" + slingshot_note) : "")

currDay = str.format("{0}-{1}-{2}", year(time), month(time), dayofmonth(time))
cooldownMs = eff_cooldownMinutes * 60 * 1000
fAllow(ev, dayRef, tRef)=>
    allow = ev
    if allow and eff_dailyOnce
        allow := dayRef != currDay
    if allow and eff_cooldownMinutes>0
        allow := na(tRef) or time - tRef > cooldownMs
    allow

var string dayBuy  = ""
var string daySell = ""
var string dayLInt = ""
var string daySInt = ""
var string dayR1   = ""
var string dayR2   = ""
var string dayTrail= ""
var string dayExit = ""

var int tBuy   = na
var int tSell  = na
var int tLInt  = na
var int tSInt  = na
var int tR1    = na
var int tR2    = na
var int tTrail = na
var int tExit  = na

allowBuy   = fAllow(evBuy,   dayBuy,   tBuy)   and not buyBlockedByPct
allowSell  = fAllow(evSell,  daySell,  tSell)
allowLInt  = fAllow(evLInt,  dayLInt,  tLInt)  and not buyBlockedByPct
allowSInt  = fAllow(evSInt,  daySInt,  tSInt)
allowHitR1 = fAllow(evHit1,  dayR1,    tR1)
allowHitR2 = fAllow(evHit2,  dayR2,    tR2)
allowTrail = fAllow(evTrail, dayTrail, tTrail)
allowExit  = fAllow(evExit,  dayExit,  tExit)

mgChartFired = eff_includeModule2 and mg_enableAlertsChart and barstate.isconfirmed and strong_buy

if allowBuy
    dayBuy := currDay
    tBuy := time
if allowSell
    daySell := currDay
    tSell := time
if allowLInt
    dayLInt := currDay
    tLInt := time
if allowSInt
    daySInt := currDay
    tSInt := time
if allowHitR1
    dayR1 := currDay
    tR1 := time
if allowHitR2
    dayR2 := currDay
    tR2 := time
if allowTrail
    dayTrail := currDay
    tTrail := time
if allowExit
    dayExit := currDay
    tExit := time

// ---
// SQZ Signal modu — olayları oluştur (1H/4H/1D destekli)
// ---

// 1) SQZ Durumunu Hesaplayan Fonksiyon
f_sqz_state() =>
    _source   = close
    _basis    = ta.sma(_source, sqz_lenBB)
    _dev      = sqz_multBB * ta.stdev(_source, sqz_lenBB)
    _upperBB  = _basis + _dev
    _lowerBB  = _basis - _dev
    _range    = sqz_useTR ? ta.tr(true) : (high - low)
    _rangema  = ta.sma(_range, sqz_lenKC)
    _ma       = ta.sma(_source, sqz_lenKC)
    _upperKC  = _ma + _rangema * sqz_multKC
    _lowerKC  = _ma - _rangema * sqz_multKC
    _sqzOn    = (_lowerBB > _lowerKC) and (_upperBB < _upperKC)
    _sqzOff   = (_lowerBB < _lowerKC) and (_upperBB > _upperKC)
    _sqz_base = close - math.avg(math.avg(ta.highest(high, sqz_lenKC), ta.lowest(low, sqz_lenKC)), ta.sma(close, sqz_lenKC))
    _sqz_val  = ta.linreg(_sqz_base, sqz_lenKC, 0)
    [_sqzOn, _sqzOff, _sqz_val]

// 2) MTF İçin Özel Sinyal Hesaplayıcı + ADX/Trend Bilgisi
// Bu fonksiyon çağrıldığı zaman diliminde Sinyal, ADX ve Trend durumunu aynı anda hesaplar
f_sqz_mtf_logic_with_context(_adxLen, _trendLen) =>
    [_on, _off, _val] = f_sqz_state()
    // Sinyal tespiti (bir önceki barda off değildi, şimdi off ise = çıkış)
    _sigLong  = _off and not _off[1] and (_val > 0)
    _sigShort = _off and not _off[1] and (_val < 0)
    
    // ADX Hesaplama (o TF içinde)
    [di_p, di_m, adx_raw] = ta.dmi(_adxLen, _adxLen)
    
    // Trend Hesaplama (o TF içinde)
    ema_val = ta.ema(close, _trendLen)
    
    [_sigLong, _sigShort, _val, adx_raw, ema_val, close, barstate.isconfirmed]

f_sqz_strength_txt(v) =>
    _abs = math.abs(v)
    _tr  = _abs < 0.05 ? "DUS" : _abs < 0.15 ? "ORT" : "YUK"
    _en  = _tr
    [_tr, _en]

f_adx_txt(val) =>
    _tr = val < 20 ? "ZAY" : val < 40 ? "GT" : "CGT"
    _en = _tr
    [_tr, _en]

f_trend_txt(price, ema) =>
    _tr = price > ema ? "YUK" : "DUS"
    _en = price > ema ? "UP" : "DN"
    [_tr, _en]

// SQZ mesaj gönderimi (GELİŞMİŞ)
f_send_sqz_advanced(tfLabel, _isLong, _close, _sqzVal, _adxVal, _emaVal, _chatId) =>
    // Apply QG if enabled
    bool sendAllowed = true
    if _isLong and buyQG_enable and buyQG_apply_sqz
        sendAllowed := buyqg_quality_pass
    if not _isLong and sellQG_enable and sellQG_apply_sqz
        sendAllowed := sellqg_qpass
    
    [strTR, strEN] = f_sqz_strength_txt(_sqzVal)
    [adxTR, adxEN] = f_adx_txt(_adxVal)
    [trdTR, trdEN] = f_trend_txt(_close, _emaVal)
    
    string hdr = _isLong
         ? (etiketDil=="TR" ? "📊 SQZ " + (_isLong?"↑":"↓") + " — " : "📊 SQZ " + (_isLong?"↑":"↓") + " — ")
         : (etiketDil=="TR" ? "📊 SQZ " + (_isLong?"↑":"↓") + " — "  : "📊 SQZ " + (_isLong?"↑":"↓") + " — ")
    hdr += syminfo.ticker + " [" + tfLabel + "]"
    
    bodyTR = "\nP:" + fmtMint(_close) + 
             "\nSQZ:" + str.tostring(_sqzVal, "#.##") + 
             " M:" + strTR + 
             " ADX:" + str.tostring(_adxVal, "#.#") + " " + trdTR
             
    bodyEN = "\nP:" + fmtMint(_close) + 
             "\nSQZ:" + str.tostring(_sqzVal, "#.##") + 
             " M:" + strEN + 
             " ADX:" + str.tostring(_adxVal, "#.#") + " " + trdEN

    string body = etiketDil=="TR" ? bodyTR : bodyEN
    string _id = "SQZ_" + tfLabel + "_" + (_isLong ? "L" : "S") + "_" + str.tostring(time) + "_" + str.tostring(bar_index)
    
    if sendAllowed
        send_event(_id, hdr + body, _chatId, alert.freq_once_per_bar_close)

// Chart TF hesaplamaları (Mevcut Grafik)
[sqzOn_ch, sqzOff_ch, sqzVal_ch] = f_sqz_state()
[di_p_ch, di_m_ch, adx_ch] = ta.dmi(pg_adx_len, pg_adx_len) // PG ayarını kullanıyoruz (14)
ema_ch = ta.ema(close, pg_trend_len) // PG ayarını kullanıyoruz (50)

sqz_long_signal  = sqz_enable and (sqz_mode=="Signal") and sqzOff_ch and not sqzOff_ch[1] and (sqzVal_ch > 0)
sqz_short_signal = sqz_enable and (sqz_mode=="Signal") and sqzOff_ch and not sqzOff_ch[1] and (sqzVal_ch < 0)

if sqz_enable and (sqz_mode=="Signal") and sqz_long_signal
    f_send_sqz_advanced(f_tf_label(timeframe.period), true, close, sqzVal_ch, adx_ch, ema_ch, telegramChatIdBuy)

if sqz_enable and (sqz_mode=="Signal") and sqz_short_signal
    f_send_sqz_advanced(f_tf_label(timeframe.period), false, close, sqzVal_ch, adx_ch, ema_ch, telegramChatIdSell)

// MTF SQZ (4H, 1D) - Gelişmiş Context ile
f_send_sqz_mtf(tf, tfLabel, useTf)=>
    // Skip if requested timeframe is not higher than chart timeframe
    if sqz_enable and (sqz_mode=="Signal") and useTf and f_is_higher_tf(tf)
        // PG'deki uzunluk ayarlarını (14, 50) MTF içine gönderiyoruz
        [mtf_lSig, mtf_sSig, mtf_val, mtf_adx, mtf_ema, mtf_close, tfClosed] =  request.security(syminfo.tickerid, tf, f_sqz_mtf_logic_with_context(pg_adx_len, pg_trend_len), barmerge.gaps_off, barmerge.lookahead_off)

        // ESKİ satır SİLİNECEK (artık gerek yok):
        // tfClosed = request.security(syminfo.tickerid, tf, barstate.isconfirmed, barmerge.gaps_off, barmerge.lookahead_off)

        if tfClosed and mtf_lSig
            f_send_sqz_advanced(tfLabel, true, mtf_close, mtf_val, mtf_adx, mtf_ema, telegramChatIdBuy)
        if tfClosed and mtf_sSig
            f_send_sqz_advanced(tfLabel, false, mtf_close, mtf_val, mtf_adx, mtf_ema, telegramChatIdSell)

// 4H ve 1D için çağır
f_send_sqz_mtf("240", "4H", true)
f_send_sqz_mtf("D",   "1D", true)

eventsArr = array.new_string()
if allowLInt
    array.push(eventsArr, TXT_LINT)
if allowSInt
    array.push(eventsArr, TXT_SINT)
if allowBuy
    array.push(eventsArr, TXT_BUY)
if allowSell
    array.push(eventsArr, TXT_SELL)
if mgChartFired
    array.push(eventsArr, TXT_MG_BUY)
if sqz_add_to_unified
    if sqz_long_signal
        array.push(eventsArr, "SQZ LONG RELEASE")
    if sqz_short_signal
        array.push(eventsArr, "SQZ SHORT RELEASE")
if allowHitR1
    array.push(eventsArr, TXT_HIT_R1)
if allowHitR2
    array.push(eventsArr, TXT_HIT_R2)
if allowTrail
    array.push(eventsArr, TXT_TRAIL_UP)
if allowExit
    array.push(eventsArr, TXT_EXIT)

events = ""
if array.size(eventsArr) > 0
    for i = 0 to array.size(eventsArr)-1
        evTxt = array.get(eventsArr, i)
        events := events=="" ? evTxt : events + ", " + evTxt

isBuyLike  = allowBuy or allowLInt or mgChartFired
isSellLike = allowSell or allowSInt
if not isBuyLike and not isSellLike
    if (allowHitR1 or allowHitR2 or allowTrail) and havePosition
        isBuyLike  := lastEntryDir == 1
        isSellLike := lastEntryDir == -1
    else if allowExit
        isBuyLike  := exitLong
        isSellLike := exitShort

useChatId = fChatId(isBuyLike, isSellLike)
// ---
// 11.5) KESİNLİK MASTER GATE
// ---
grpMASTER = "Kesinlik Master Gate"
masterEnable        = input.bool(true,  "Master Gate: (Kesişim + HTF Strict + PG HC + M2/MTF) olmadan UNIFIED gönderme", group=grpMASTER)
//masterReqM2orMTF    = input.bool(true,  "Master Gate: M2 Combined veya MTF teyidi de şart olsun", group=grpMASTER) cok mesaj gelirse true yap yine
masterReqM2orMTF    = input.bool(false,  "Master Gate: M2 Combined veya MTF teyidi de şart olsun", group=grpMASTER)

// HTF Strict kapısı
isHTFStrictSel   = enableHTF and (htfModeAlerts == "Strict")
isHTFStrictLong  = not isHTFStrictSel or htfUp
isHTFStrictShort = not isHTFStrictSel or htfDn

// M2/MG teyidi
hc_m2_ok =
     nz(mt_buyAllowedCombined, false)
  or nz(mt_buyAllowedConf, false)
  or nz(mt_buyAllowedCandle, false)
  or nz(mgChartFired, false)
  or nz(mt_buyAllowedCombined1D, false)
  or nz(mt_buyAllowedConf1D, false)
  or nz(mt_buyAllowedCandle1D, false)

// PG High-Confidence kapısı
pg_hc_long_ok  = eff_pg_enable ? (pg_hc_enable ? nz(buyHC, false) : nz(pg_buy_sig_base, false)) : true
pg_hc_short_ok = eff_pg_enable ? (pg_hc_enable ? nz(selHC,  false) : nz(pg_sell_sig_base,false)) : true

// Kesişim ve tüm kapılar
hc_long_gate  = evLInt and isHTFStrictLong  and pg_hc_long_ok  and (not masterReqM2orMTF or hc_m2_ok)
hc_short_gate = evSInt and isHTFStrictShort and pg_hc_short_ok and (not masterReqM2orMTF or (nz(mt_sellAllowedCombined, false) or nz(mt_sellAllowedCombined1D, false)))

// Unified mesajın izni
canSendUnified = enableUnifiedAlert and (events != "") and (not masterEnable or hc_long_gate or hc_short_gate)

// ---
// 12) HYBRID POTENTIAL SEND
// ---
if hybUseSeparateAlerts and eligiblePotBuy and not buyBlockedByPct
    potHdr  = (etiketDil=="TR" ? "⚠️ [POTANSİYEL AL " : "⚠️ [POTENTIAL BUY ") + syminfo.ticker + "]"
    potBody = (etiketDil=="TR" ? ("Bar İlerlemesi: " + str.tostring(barProgressPct, "#.0") + "%\nFiyat: " + fmtMint(close)) : ("Bar Progress: " + str.tostring(barProgressPct, "#.0") + "%\nPrice: " + fmtMint(close)))
    potMsg  = potHdr + "\n" + potBody
    send_event("POT_BUY_"+str.tostring(bar_index), potMsg, fChatId(true,false), alert.freq_once_per_bar)
    potBuyBarSent := bar_index
    potLastBuyTime := time
    if hybShowPotentialLabel
        label.new(bar_index, close, etiketDil=="TR"?"POT AL":"POT BUY", style=label.style_label_up, color=color.new(color.blue,0), textcolor=color.white, size=size.tiny)

if hybUseSeparateAlerts and eligiblePotSell
    potHdr  = (etiketDil=="TR" ? "⚠️ [POTANSİYEL SAT " : "⚠️ [POTENTIAL SELL ") + syminfo.ticker + "]"
    potBody = (etiketDil=="TR" ? ("Bar İlerlemesi: " + str.tostring(barProgressPct, "#.0") + "%\nFiyat: " + fmtMint(close)) : ("Bar Progress: " + str.tostring(barProgressPct, "#.0") + "%\nPrice: " + fmtMint(close)))
    potMsg  = potHdr + "\n" + potBody
    send_event("POT_SELL_"+str.tostring(bar_index), potMsg, fChatId(false,true), alert.freq_once_per_bar)
    potSellBarSent := bar_index
    potLastSellTime := time
    if hybShowPotentialLabel
        label.new(bar_index, close, etiketDil=="TR"?"POT SAT":"POT SELL", style=label.style_label_down, color=color.new(color.orange,0), textcolor=color.white)

// ---
// 12.5) ERKEN BANKO
// ---
var int earlyBankoBuyLast  = na
var int earlyBankoSellLast = na
earlyBankoCooldownMs = earlyBankoCooldownMin * 60 * 1000

earlyOkTimeBuy  = earlyBankoCooldownMin==0 or na(earlyBankoBuyLast)  or (time - earlyBankoBuyLast  > earlyBankoCooldownMs)
earlyOkTimeSell = earlyBankoCooldownMin==0 or na(earlyBankoSellLast) or (time - earlyBankoSellLast > earlyBankoCooldownMs)

earlyBankoBuy  = earlyBankoEnabled and isRT and (barProgressPct >= earlyBankoMinProgressPct)  and longIntersect_raw  and htfOkLongLabel  and earlyOkTimeBuy
earlyBankoSell = earlyBankoEnabled and isRT and (barProgressPct >= earlyBankoMinProgressPct)  and shortIntersect_raw and htfOkShortLabel and earlyOkTimeSell

if earlyBankoBuy
    idB = "EARLY_BANKO_BUY_" + str.tostring(bar_index)
    prevNoteEB = f_prev_bullish_note()
    msgB = (etiketDil=="TR" ? "⚠️ ERKEN BANKO AL [" : "⚠️ EARLY BANKO BUY [") + syminfo.ticker + "] [" + f_tf_label(timeframe.period) + "] — Fiyat: " + fmtMint(close) + prevNoteEB
    send_event(idB, msgB, fChatId(true,false), alert.freq_once_per_bar)
    earlyBankoBuyLast := time
    [lastBullishTime, lastBullishPrice, lastBullishTextTR, lastBullishTextEN, lastBullishTF] = f_record_bullish("ERKEN BANKO AL", "EARLY BANKO BUY", f_tf_label(timeframe.period))

if earlyBankoSell
    idS = "EARLY_BANKO_SELL_" + str.tostring(bar_index)
    msgS = (etiketDil=="TR" ? "⚠️ ERKEN BANKO SAT [" : "⚠️ EARLY BANKO SELL [") + syminfo.ticker + "] [" + f_tf_label(timeframe.period) + "] — Fiyat: " + fmtMint(close)
    send_event(idS, msgS, fChatId(false,true), alert.freq_once_per_bar)
    earlyBankoSellLast := time

// ---
// 13) UNIFIED MESSAGE — Master Gate ile
// ---
if canSendUnified
    priceStr = fmtMint(close)
    entryStr = havePosition ? fmtMint(lastEntryPrice) : "NA"
    stopStr  = havePosition ? fmtMint(liveStop) : "NA"
    riskStr  = havePosition and riskDist>0 ? fmtMint(riskDist) : "NA"
    r1Str    = (havePosition and showRTargets and not na(lineR1)) ? fmtMint(line.get_y1(lineR1)) : "NA"
    r2Str    = (havePosition and showRTargets and not na(lineR2)) ? fmtMint(line.get_y1(lineR2)) : "NA"
    timeStr  = f_fmt_time(time)
    posDir   = havePosition ? (lastEntryDir==1 ? "LONG" : "SHORT") : "FLAT"
    header   = "📈 [" + syminfo.ticker + "] [" + f_tf_label(timeframe.period) + "]"
    hedefLine = showRTargets ? ((etiketDil=="TR" ? "\nHedef1: " : "\nTarget1: ") + r1Str + (etiketDil=="TR" ? "   Hedef2: " : "   Target2: " ) + r2Str) : ""
    pgBlock  = (unifiedIncludePG and eff_pg_enable and isBuyLike and pg_ctx_for_unified_buy!="") ? ((etiketDil=="TR" ? "\nPG:\n" : "\nPG\n") + pg_ctx_for_unified_buy) : ""
    techBlock= (st_event!="" or slingshot_note!="" or enableHTF) ? ((etiketDil=="TR" ? "\nTEK\n" : "\nTECH\n") + tech_ctx_for_unified_buy) : ""
    prevNoteU = f_prev_bullish_note()
    body = (etiketDil=="TR" ? ("Olay: " + events + "\nFiyat: " + priceStr + "\nPozisyon: " + posDir + "\nGiriş: " + entryStr + "\nStop: " + stopStr + "\nRisk Mesafe: " + riskStr + hedefLine + pgBlock + techBlock + prevNoteU + "\nT:" + timeStr) : ("Event: " + events + "\nPrice: " + priceStr + "\nPosition: " + posDir + "\nEntry: " + entryStr + "\nStop: " + stopStr + "\nRisk Distance: " + riskStr + hedefLine + pgBlock + techBlock + prevNoteU + "\nT:" + timeStr))
    unifiedId = "UNIFIED_"+str.tostring(bar_index)
    freqU = useCloseConfirm ? alert.freq_once_per_bar_close : alert.freq_once_per_bar
    send_event(unifiedId, header + "\n" + body, useChatId, freqU)
    if allowLInt
        [lastBullishTime, lastBullishPrice, lastBullishTextTR, lastBullishTextEN, lastBullishTF] = f_record_bullish("BANKO KESİŞME AL", "BANKO LONG INTERSECT", f_tf_label(timeframe.period))
    else if allowBuy
        [lastBullishTime, lastBullishPrice, lastBullishTextTR, lastBullishTextEN, lastBullishTF] = f_record_bullish("ST AL Flip", "ST Buy Flip", f_tf_label(timeframe.period))
    else if mgChartFired
        [lastBullishTime, lastBullishPrice, lastBullishTextTR, lastBullishTextEN, lastBullishTF] = f_record_bullish("Multi Güçlü AL", "Multi Strong BUY", f_tf_label(timeframe.period))

// ---
// 14) MTF ST — Safe Boot ile
// ---
f_mtf_eval() =>
    _tr  = ta.tr(true)
    _atr = altAtrMethod ? ta.sma(_tr, atrLen) : ta.atr(atrLen)
    _mid = hl2
    var float _stU = na
    var float _stD = na
    _upL = _mid - atrMult*_atr
    _dnL = _mid + atrMult*_atr
    _upP = nz(_stU[1], _upL)
    _dnP = nz(_stD[1], _dnL)
    _stU := close[1] > _upP ? math.max(_upL,_upP) : _upL
    _stD := close[1] < _dnP ? math.min(_dnL,_dnP) : _dnL
    var int _dir = 1
    _dir := _dir == -1 and close > _dnP ? 1 : (_dir == 1 and close < _upP ? -1 : _dir)
    _flipUp   = _dir == 1 and _dir[1] == -1
    _flipDown = _dir == -1 and _dir[1] ==  1
    _emaF = ta.ema(close, emaFastLen)
    _emaS = ta.ema(close, emaSlowLen)
    _consUp = _emaF > _emaS and close[1] < _emaF[1] and close > _emaF
    _consDn = _emaF < _emaS and close[1] > _emaF[1] and close < _emaF
    _inWinUp   = eff_confirmWindow==0 ? _flipUp   : ta.barssince(_flipUp)   <= eff_confirmWindow
    _inWinDown = eff_confirmWindow==0 ? _flipDown : ta.barssince(_flipDown) <= eff_confirmWindow
    _evBuy  = (not useCloseConfirm or barstate.isconfirmed) and includeBuyFlip        and _flipUp
    _evSell = (not useCloseConfirm or barstate.isconfirmed) and includeSellFlip       and _flipDown
    // BANKO AL: realtime (no barstate.isconfirmed check)
    _evLInt = includeLongIntersect  and _inWinUp   and _consUp
    // BANKO SAT and others: keep confirmed check
    _evSInt = (not useCloseConfirm or barstate.isconfirmed) and includeShortIntersect and _inWinDown and _consDn
    if _evLInt
        _evBuy := false
    if _evSInt
        _evSell := false
    [_evBuy, _evSell, _evLInt, _evSInt, barstate.isconfirmed, time, close]

sendMtf(tf, tfLabel, useTf)=>
    // Skip if requested timeframe is not higher than chart timeframe
    if eff_mtf_enable and useTf and f_is_higher_tf(tf)
        [b_, s_, l_, k_, tfClosed, mtfTime, mtfClose] = request.security(syminfo.tickerid, tf, f_mtf_eval(), barmerge.gaps_off, barmerge.lookahead_off)

        // tfClosed = request.security(syminfo.tickerid, tf, barstate.isconfirmed, barmerge.gaps_off, barmerge.lookahead_off)
        
        // BANKO AL realtime: fire immediately when l_ is true (no tfClosed check)
        // Only for BANKO AL when mtf_only_banko is true
        bankoAlRealtime = mtf_only_banko and l_
        
        // For non-BANKO mode or for SAT/flip events, wait for tfClosed as before
        if bankoAlRealtime or (tfClosed and (b_ or s_ or l_ or k_))
            buyLike = b_ or l_
            sellLike = s_ or k_
            evStrBuy = ""
            evStrSell = ""
            if mtf_only_banko
                if l_
                    evStrBuy := TXT_LINT
                // k_ (BANKO SAT) should not be sent per user request
            else
                if l_
                    evStrBuy := evStrBuy=="" ? TXT_LINT : evStrBuy + "; " + TXT_LINT
                if b_
                    evStrBuy := evStrBuy=="" ? (etiketDil=="TR"?"AL Flip":"Buy Flip") : evStrBuy + "; " + (etiketDil=="TR"?"AL Flip":"Buy Flip")
                if k_
                    evStrSell := evStrSell=="" ? TXT_SINT : evStrSell + "; " + TXT_SINT
                if s_
                    evStrSell := evStrSell=="" ? (etiketDil=="TR"?"SAT Flip":"Sell Flip") : evStrSell + "; " + (etiketDil=="TR"?"SAT Flip":"Sell Flip")
            
            // BANKO AL alert with proper format: "K - BANKO KESİŞME AL (1H)"
            // Only send when l_ (BANKO AL) is true in BANKO mode
            if mtf_only_banko and l_ and not buyBlockedByPct
                // Use MTF bar time for deduplication instead of bar_index
                // This prevents spam: same mtfTime = same HTF bar = single alert
                id = "MTF_BANKO_AL_"+tfLabel+"_"+str.tostring(mtfTime)
                prevNoteMtf = f_prev_bullish_note()
                // Add REALTIME/CONFIRMED label based on tfClosed status
                statusLabel = tfClosed ? " [✓CONFIRMED]" : " [⚡REALTIME]"
                // Message format: TXT_LINT + " (" + tfLabel + ")" + status
                msg = evStrBuy + " (" + tfLabel + ")" + statusLabel + " [" + syminfo.ticker + "]\nFiyat: " + fmtMint(mtfClose) + prevNoteMtf
                // alert.freq_once_per_bar for realtime; dedup handled by send_event with mtfTime in id
                // MTF BANKO alerts sent to dedicated chat ID
                send_event(id, msg, telegramChatIdMtfBanko, alert.freq_once_per_bar)
                [lastBullishTime, lastBullishPrice, lastBullishTextTR, lastBullishTextEN, lastBullishTF] = f_record_bullish("BANKO KESİŞME AL", "BANKO LONG INTERSECT", tfLabel)
            // For non-BANKO mode, handle other events normally
            if not mtf_only_banko
                if buyLike and not buyBlockedByPct and evStrBuy!=""
                    id = "MTF_ST_"+tfLabel+"_BUY_"+str.tostring(mtfTime)
                    prevNoteMtf = f_prev_bullish_note()
                    msg = (etiketDil=="TR"?"🚀 MTF AL [" : "🚀 MTF BUY [") + syminfo.ticker + "] " + tfLabel + ": " + evStrBuy + "\nFiyat: " + fmtMint(mtfClose) + prevNoteMtf
                    send_event(id, msg, telegramChatIdBuy, alert.freq_once_per_bar_close)
                    [lastBullishTime, lastBullishPrice, lastBullishTextTR, lastBullishTextEN, lastBullishTF] = f_record_bullish("MTF AL", "MTF BUY", tfLabel)
                if sellLike and evStrSell!=""
                    id2 = "MTF_ST_"+tfLabel+"_SELL_"+str.tostring(mtfTime)
                    msg2 = (etiketDil=="TR"?"🔻 MTF SAT [" : "🔻 MTF SELL [") + syminfo.ticker + "] " + tfLabel + ": " + evStrSell + "\nFiyat: " + fmtMint(mtfClose)
                    send_event(id2, msg2, telegramChatIdSell, alert.freq_once_per_bar_close)
            // Note: BANKO SAT (k_) intentionally not sent in BANKO mode per user request

sendMtf("60","1H", mtf_use_1h)
sendMtf("120","2H", mtf_use_2h)
sendMtf("240","4H", mtf_use_4h)
sendMtf("D","1D", mtf_use_1d)

// ---
// 15) MODÜL-2 4H / 1D Mesajlar
// ---
build_pg_value_lines() =>
    string valueLine_tr = ""
    string valueLine_en = ""
    if pg_va_mode=="MA+Bollinger"
        valueLine_tr := "\nBB: " + (close > (ta.sma(pg_bb_src, pg_bb_length) + pg_bb_mult*ta.stdev(pg_bb_src, pg_bb_length)) ? "ÜST" : (close < (ta.sma(pg_bb_src, pg_bb_length) - pg_bb_mult*ta.stdev(pg_bb_src, pg_bb_length)) ? "ALT" : "İÇ"))
        valueLine_en := "\nBB: " + (close > (ta.sma(pg_bb_src, pg_bb_length) + pg_bb_mult*ta.stdev(pg_bb_src, pg_bb_length)) ? "ABOVE" : (close < (ta.sma(pg_bb_src, pg_bb_length) - pg_bb_mult*ta.stdev(pg_bb_src, pg_bb_length)) ? "BELOW" : "IN"))
    else
        float pg_value_here = nz(ta.vwap(pg_vwap_source))
        string pg_label_val = "VW"
        valueLine_tr := "\nDeğer: " + pg_label_val + (not na(pg_value_here) ? "  Δ: " + str.tostring(close - pg_value_here, "#.####") : "")
        valueLine_en := "\nValue: " + pg_label_val + (not na(pg_value_here) ? "  Δ: " + str.tostring(close - pg_value_here, "#.####") : "")
    [valueLine_tr, valueLine_en]

// 4H — BUY BLOKLARI
if eff_includeModule2
    if mt_sendCombinedAlerts and mt_buyAllowedCombined
        idB = "M2_4H_COMBINED_BUY_" + str.tostring(bar_index)
        [valTR, valEN] = build_pg_value_lines()
        [tgTR, tgEN]   = f_target_block_buy(close, (trailStopEnabled and havePosition and not na(liveStop) ? liveStop : stUp))
        hdrTR = "🟢 M2 Kombine AL [" + syminfo.ticker + "] [4H]"
        hdrEN = "🟢 M2 Combined BUY [" + syminfo.ticker + "] [4H]"
        techCtxM2 = tech_ctx_for_unified_buy != "" ? tech_ctx_for_unified_buy : f_quick_tech_ctx()
        techTR = "\nTEK\n" + techCtxM2
        techEN = "\nTECH\n" + techCtxM2
        prevNoteM2 = f_prev_bullish_note()
        bodyTR = "\nRAPOR\nFiyat: " + fmtMint(close) + tgTR + (unifiedIncludePG and eff_pg_enable ? ("\nPG:\n" + PG_CTX_TR) : "") + (etiketDil=="TR"?valTR:valEN) + techTR + prevNoteM2
        bodyEN = "\nReport\nPrice: " + fmtMint(close) + tgEN + (unifiedIncludePG and eff_pg_enable ? ("\nPG\n" + PG_CTX_EN) : "") + (etiketDil=="TR"?valTR:valEN) + techEN
        msgB = (etiketDil=="TR" ? hdrTR + bodyTR : hdrEN + bodyEN)
        send_event(idB, msgB, fChatId(true,false), alert.freq_once_per_bar_close)
        [lastBullishTime, lastBullishPrice, lastBullishTextTR, lastBullishTextEN, lastBullishTF] = f_record_bullish("M2 Kombine AL", "M2 Combined BUY", "4H")

    if mt_sendConfirmedAlerts and mt_buyAllowedConf and not mt_buyAllowedCombined
        idB2 = "M2_4H_CONF_BUY_" + str.tostring(bar_index)
        [valTR2, valEN2] = build_pg_value_lines()
        [tgTR2, tgEN2]   = f_target_block_buy(close, (trailStopEnabled and havePosition and not na(liveStop) ? liveStop : stUp))
        hdrTR2 = "🟢 M2 Onaylı AL [" + syminfo.ticker + "] [4H]"
        hdrEN2 = "🟢 M2 Confirmed BUY [" + syminfo.ticker + "] [4H]"
        techCtxM2b = tech_ctx_for_unified_buy != "" ? tech_ctx_for_unified_buy : f_quick_tech_ctx()
        techTR2 = "\nTEK\n" + techCtxM2b
        techEN2 = "\nTECH\n" + techCtxM2b
        prevNoteM2b = f_prev_bullish_note()
        bodyTR2 = "\nRAPOR\nFiyat: " + fmtMint(close) + tgTR2 + (unifiedIncludePG and eff_pg_enable ? ("\nPG:\n" + PG_CTX_TR) : "") + (etiketDil=="TR"?valTR2:valEN2) + techTR2 + prevNoteM2b
        bodyEN2 = "\nReport\nPrice: " + fmtMint(close) + tgEN2 + (unifiedIncludePG and eff_pg_enable ? ("\nPG\n" + PG_CTX_EN) : "") + (etiketDil=="TR"?valTR2:valEN2) + techEN2
        msgB2 = (etiketDil=="TR" ? hdrTR2 + bodyTR2 : hdrEN2 + bodyEN2)
        send_event(idB2, msgB2, fChatId(true,false), alert.freq_once_per_bar_close)
        [lastBullishTime, lastBullishPrice, lastBullishTextTR, lastBullishTextEN, lastBullishTF] = f_record_bullish("M2 Onaylı AL", "M2 Confirmed BUY", "4H")

    if mt_sendCandleAlerts and mt_buyAllowedCandle
        idBC = "M2_4H_CANDLE_BUY_" + str.tostring(bar_index)
        [valTR3, valEN3] = build_pg_value_lines()
        [tgTR3, tgEN3]   = f_target_block_buy(close, (trailStopEnabled and havePosition and not na(liveStop) ? liveStop : stUp))
        hdrTR3 = "🕯️ M2 Candle Close AL [" + syminfo.ticker + "] [4H]"
        hdrEN3 = "🕯️ M2 Candle Close BUY [" + syminfo.ticker + "] [4H]"
        techCtxM2c = tech_ctx_for_unified_buy != "" ? tech_ctx_for_unified_buy : f_quick_tech_ctx()
        techTR3 = "\nTEK\n" + techCtxM2c
        techEN3 = "\nTECH\n" + techCtxM2c
        prevNoteM2c = f_prev_bullish_note()
        bodyTR3 = "\nRAPOR\nFiyat: " + fmtMint(close) + tgTR3 + (unifiedIncludePG and eff_pg_enable ? ("\nPG:\n" + PG_CTX_TR) : "") + (etiketDil=="TR"?valTR3:valEN3) + techTR3 + prevNoteM2c
        bodyEN3 = "\nReport\nPrice: " + fmtMint(close) + tgEN3 + (unifiedIncludePG and eff_pg_enable ? ("\nPG\n" + PG_CTX_EN) : "") + (etiketDil=="TR"?valTR3:valEN3) + techEN3
        msgBC = (etiketDil=="TR" ? hdrTR3 + bodyTR3 : hdrEN3 + bodyEN3)
        send_event(idBC, msgBC, fChatId(true,false), alert.freq_once_per_bar_close)

    if mt_enableEarlyAlerts and mt_buyAllowedEarly
        idBE = "M2_4H_EARLY_BUY_" + str.tostring(bar_index)
        prevNoteM2e = f_prev_bullish_note()
        msgBE = (etiketDil=="TR" ? "⚠️ M2 ERKEN AL [" : "⚠️ M2 Early BUY [") + syminfo.ticker + "] [4H] — Fiyat: " + fmtMint(close) + prevNoteM2e
        send_event(idBE, msgBE, fChatId(true,false), alert.freq_once_per_bar)

// 4H SELL
if mt_sendCombinedAlerts and mt_sellAllowedCombined
    idS = "M2_4H_COMBINED_SELL_" + str.tostring(bar_index)
    [valTRs, valENs] = build_pg_value_lines()
    [tgTRs, tgENs]   = f_target_block_sell(close, (trailStopEnabled and havePosition and not na(liveStop) ? liveStop : stDn))
    hdrTRs = "🔻 M2 Kombine SAT [" + syminfo.ticker + "] 4H"
    hdrENs = "🔻 M2 Combined SELL [" + syminfo.ticker + "] 4H"
    techCtxM2s = tech_ctx_for_unified_buy != "" ? tech_ctx_for_unified_buy : f_quick_tech_ctx()
    techTRs = "\nTEK:" + techCtxM2s
    techENs = "\nTECH:" + techCtxM2s
    bodyTRs = "\nP:" + fmtMint(close) + tgTRs + (unifiedIncludePG and eff_pg_enable ? ("\nPG:\n" + PG_CTX_TR) : "") + (etiketDil=="TR"?valTRs:valENs) + techTRs
    bodyENs = "\nP:" + fmtMint(close) + tgENs + (unifiedIncludePG and eff_pg_enable ? ("\nPG:\n" + PG_CTX_EN) : "") + (etiketDil=="TR"?valTRs:valENs) + techENs
    msgS = (etiketDil=="TR" ? hdrTRs + bodyTRs : hdrENs + bodyENs)
    send_event(idS, msgS, fChatId(false,true), alert.freq_once_per_bar_close)

// SELL — Onaylı
if mt_sendConfirmedAlerts and mt_sellAllowedConf and not mt_sellAllowedCombined
    idS2 = "M2_4H_CONF_SELL_" + str.tostring(bar_index)
    [valTRs2, valENs2] = build_pg_value_lines()
    [tgTRs2, tgENs2]   = f_target_block_sell(close, (trailStopEnabled and havePosition and not na(liveStop) ? liveStop : stDn))
    hdrTRs2 = "🔻 M2 Onaylı SAT [" + syminfo.ticker + "] 4H"
    hdrENs2 = "🔻 M2 Confirmed SELL [" + syminfo.ticker + "] 4H"
    techCtxM2s2 = tech_ctx_for_unified_buy != "" ? tech_ctx_for_unified_buy : f_quick_tech_ctx()
    techTRs2 = "\nTEK:" + techCtxM2s2
    techENs2 = "\nTECH:" + techCtxM2s2
    bodyTRs2 = "\nP:" + fmtMint(close) + tgTRs2 + (unifiedIncludePG and eff_pg_enable ? ("\nPG:\n" + PG_CTX_TR) : "") + (etiketDil=="TR"?valTRs2:valENs2) + techTRs2
    bodyENs2 = "\nP:" + fmtMint(close) + tgENs2 + (unifiedIncludePG and eff_pg_enable ? ("\nPG:\n" + PG_CTX_EN) : "") + (etiketDil=="TR"?valTRs2:valENs2) + techENs2
    msgS2 = (etiketDil=="TR" ? hdrTRs2 + bodyTRs2 : hdrENs2 + bodyENs2)
    send_event(idS2, msgS2, fChatId(false,true), alert.freq_once_per_bar_close)

// 1D — BUY BLOKLARI
if eff_includeModule2
    // BUY — Kombine
    if mt_sendCombinedAlerts and mt_buyAllowedCombined1D
        idBD = "M2_1D_COMBINED_BUY_" + str.tostring(bar_index)
        [valTRd, valENd] = build_pg_value_lines()
        [tgTRd, tgENd]   = f_target_block_buy(close, (trailStopEnabled and havePosition and not na(liveStop) ? liveStop : stUp))
        hdrTRd = "🟢 M2 Kombine AL [" + syminfo.ticker + "] [1D]"
        hdrENd = "🟢 M2 Combined BUY [" + syminfo.ticker + "] [1D]"
        techCtxD = tech_ctx_for_unified_buy != "" ? tech_ctx_for_unified_buy : f_quick_tech_ctx()
        techTRd = "\nTEK:" + techCtxD
        techENd = "\nTECH:" + techCtxD
        prevNoteD = f_prev_bullish_note()
        bodyTRd = "\nP:" + fmtMint(close) + tgTRd + (unifiedIncludePG and eff_pg_enable ? ("\nPG:\n" + PG_CTX_TR) : "") + (etiketDil=="TR"?valTRd:valENd) + techTRd + prevNoteD
        bodyENd = "\nP:" + fmtMint(close) + tgENd + (unifiedIncludePG and eff_pg_enable ? ("\nPG:\n" + PG_CTX_EN) : "") + (etiketDil=="TR"?valTRd:valENd) + techENd
        msgBD = (etiketDil=="TR" ? hdrTRd + bodyTRd : hdrENd + bodyENd)
        send_event(idBD, msgBD, fChatId(true,false), alert.freq_once_per_bar_close)
        [lastBullishTime, lastBullishPrice, lastBullishTextTR, lastBullishTextEN, lastBullishTF] = f_record_bullish("M2 Kombine AL", "M2 Combined BUY", "1D")

    // BUY — Onaylı
    if mt_sendConfirmedAlerts and mt_buyAllowedConf1D and not mt_buyAllowedCombined1D
        idB2D = "M2_1D_CONF_BUY_" + str.tostring(bar_index)
        [valTR2d, valEN2d] = build_pg_value_lines()
        [tgTR2d, tgEN2d]   = f_target_block_buy(close, (trailStopEnabled and havePosition and not na(liveStop) ? liveStop : stUp))
        hdrTR2d = "🟢 M2 Onaylı AL [" + syminfo.ticker + "] [1D]"
        hdrEN2d = "🟢 M2 Confirmed BUY [" + syminfo.ticker + "] [1D]"
        techCtxM2bd = tech_ctx_for_unified_buy != "" ? tech_ctx_for_unified_buy : f_quick_tech_ctx()
        techTR2d = "\n--- TEK ---\n" + techCtxM2bd
        techEN2d = "\n--- TECH ---\n" + techCtxM2bd
        prevNoteM2bd = f_prev_bullish_note()
        bodyTR2d = "\nRAPOR\nP:" + fmtMint(close) + tgTR2d + (unifiedIncludePG and eff_pg_enable ? ("\nPG:\n" + PG_CTX_TR) : "") + (etiketDil=="TR"?valTR2d:valEN2d) + techTR2d + prevNoteM2bd
        bodyEN2d = "\nReport\nP:" + fmtMint(close) + tgEN2d + (unifiedIncludePG and eff_pg_enable ? ("\nPG:\n" + PG_CTX_EN) : "") + (etiketDil=="TR"?valTR2d:valEN2d) + techEN2d
        msgB2D = (etiketDil=="TR" ? hdrTR2d + bodyTR2d : hdrEN2d + bodyEN2d)
        send_event(idB2D, msgB2D, fChatId(true,false), alert.freq_once_per_bar_close)

    // BUY — Candle close
    if mt_sendCandleAlerts and mt_buyAllowedCandle1D
        idBCD = "M2_1D_CANDLE_BUY_" + str.tostring(bar_index)
        [valTR3d, valEN3d] = build_pg_value_lines()
        [tgTR3d, tgEN3d]   = f_target_block_buy(close, (trailStopEnabled and havePosition and not na(liveStop) ? liveStop : stUp))
        hdrTR3d = "🕯️ M2 Candle Close AL [" + syminfo.ticker + "] [1D]"
        hdrEN3d = "🕯️ M2 Candle Close BUY [" + syminfo.ticker + "] [1D]"
        techCtxM2cd = tech_ctx_for_unified_buy != "" ? tech_ctx_for_unified_buy : f_quick_tech_ctx()
        techTR3d = "\n--- TEK ---\n" + techCtxM2cd
        techEN3d = "\n--- TECH ---\n" + techCtxM2cd
        prevNoteM2cd = f_prev_bullish_note()
        bodyTR3d = "\nRAPOR\nP:" + fmtMint(close) + tgTR3d + (unifiedIncludePG and eff_pg_enable ? ("\nPG:\n" + PG_CTX_TR) : "") + (etiketDil=="TR"?valTR3d:valEN3d) + techTR3d + prevNoteM2cd
        bodyEN3d = "\nReport\nP:" + fmtMint(close) + tgEN3d + (unifiedIncludePG and eff_pg_enable ? ("\nPG:\n" + PG_CTX_EN) : "") + (etiketDil=="TR"?valTR3d:valEN3d) + techEN3d
        msgBCD = (etiketDil=="TR" ? hdrTR3d + bodyTR3d : hdrEN3d + bodyEN3d)
        send_event(idBCD, msgBCD, fChatId(true,false), alert.freq_once_per_bar_close)

// 1D SELL
if mt_sendCombinedAlerts and mt_sellAllowedCombined1D
    idSD = "M2_1D_COMBINED_SELL_" + str.tostring(bar_index)
    [valTRsd, valENsd] = build_pg_value_lines()
    [tgTRsd, tgENsd]   = f_target_block_sell(close, (trailStopEnabled and havePosition and not na(liveStop) ? liveStop : stDn))
    hdrTRsd = "🔻 M2 Kombine SAT [" + syminfo.ticker + "] 1D"
    hdrENsd = "🔻 M2 Combined SELL [" + syminfo.ticker + "] 1D"
    techCtxM2sd = tech_ctx_for_unified_buy != "" ? tech_ctx_for_unified_buy : f_quick_tech_ctx()
    techTRsd = "\nTEK:" + techCtxM2sd
    techENsd = "\nTECH:" + techCtxM2sd
    bodyTRsd = "\nP:" + fmtMint(close) + tgTRsd + (unifiedIncludePG and eff_pg_enable ? ("\nPG:\n" + PG_CTX_TR) : "") + (etiketDil=="TR"?valTRsd:valENsd) + techTRsd
    bodyENsd = "\nP:" + fmtMint(close) + tgENsd + (unifiedIncludePG and eff_pg_enable ? ("\nPG:\n" + PG_CTX_EN) : "") + (etiketDil=="TR"?valTRsd:valENsd) + techENsd
    msgSD = (etiketDil=="TR" ? hdrTRsd + bodyTRsd : hdrENsd + bodyENsd)
    send_event(idSD, msgSD, fChatId(false,true), alert.freq_once_per_bar_close)

// SELL — Onaylı (1D)
if mt_sendConfirmedAlerts and mt_sellAllowedConf1D and not mt_sellAllowedCombined1D
    idS2D = "M2_1D_CONF_SELL_" + str.tostring(bar_index)
    [valTRs2d, valENs2d] = build_pg_value_lines()
    [tgTRs2d, tgENs2d]   = f_target_block_sell(close, (trailStopEnabled and havePosition and not na(liveStop) ? liveStop : stDn))
    hdrTRs2d = "🔻 M2 Onaylı SAT [" + syminfo.ticker + "] 1D"
    hdrENs2d = "🔻 M2 Confirmed SELL [" + syminfo.ticker + "] 1D"
    techCtxM2s2d = tech_ctx_for_unified_buy != "" ? tech_ctx_for_unified_buy : f_quick_tech_ctx()
    techTRs2d = "\nTEK:" + techCtxM2s2d
    techENs2d = "\nTECH:" + techCtxM2s2d
    bodyTRs2d = "\nP:" + fmtMint(close) + tgTRs2d + (unifiedIncludePG and eff_pg_enable ? ("\nPG:\n" + PG_CTX_TR) : "") + (etiketDil=="TR"?valTRs2d:valENs2d) + techTRs2d
    bodyENs2d = "\nP:" + fmtMint(close) + tgENs2d + (unifiedIncludePG and eff_pg_enable ? ("\nPG:\n" + PG_CTX_EN) : "") + (etiketDil=="TR"?valTRs2d:valENs2d) + techENs2d
    msgS2D = (etiketDil=="TR" ? hdrTRs2d + bodyTRs2d : hdrENs2d + bodyENs2d)
    send_event(idS2D, msgS2D, fChatId(false,true), alert.freq_once_per_bar_close)

// ---
// 16) VISUAL LABELS + ALERT CONDITIONS
// ---
if showSTSignals and buySignal and entryConfirmed(true) and htfOkLongLabel
    label.new(bar_index, stUp, TXT_BUY, style=label.style_label_up, color=color.new(color.green,0), textcolor=color.white)
if showSTSignals and sellSignal and entryConfirmed(true) and htfOkShortLabel
    label.new(bar_index, stDn, TXT_SELL, style=label.style_label_down, color=color.new(color.red,0), textcolor=color.white)
if longIntersectLabel and entryConfirmed(true)
    label.new(bar_index, low, TXT_LINT, style=label.style_label_up, color=color.new(color.teal,0), textcolor=color.white)
if shortIntersectLabel and entryConfirmed(true)
    label.new(bar_index, high, TXT_SINT, style=label.style_label_down, color=color.new(color.maroon,0), textcolor=color.white)

// SQZ görsel işaretler (kapalı - token tasarrufu)
// plotshape(sqz_enable and sqzOff and (sqz_val>0),  title="SQZ L", style=shape.circle, location=location.belowbar, color=color.new(color.lime, 0), size=size.tiny)
// plotshape(sqz_enable and sqzOff and (sqz_val<0),  title="SQZ S", style=shape.circle, location=location.abovebar, color=color.new(color.red, 0),  size=size.tiny)

// ---
// DT MODÜLÜ — Çift / Üçlü Dip–Tepe + MOST (saf ek analiz)
// Kaynak: ikiliucludipmitmovearesat.txt (v6'dan v5'e port)
// Hiçbir mevcut V61 ayarını DEĞİŞTİRMEZ, sadece ekler.
// ---

//----------------------------------------------------
// DT Inputs (formasyon + MOST)
//----------------------------------------------------
grpDT = "DT — Çift/Üçlü Dip & Tepe + MOST"

dt_tfPreset         = input.string("Auto", "DT Zaman Dilimi Preset", options=["Auto","1H","4H","1D"], group=grpDT)
dt_x                = input.int(14,  "DT Pivot Uzunluğu (Zaman Ufku)", minval=3, group=grpDT)
dt_minSpacing       = input.int(8,   "DT Pivotlar Arası Minimum Bar", minval=1, group=grpDT)
dt_tolPct           = input.float(1.0, "DT Fiyat Toleransı %", step=0.1, minval=0.0, group=grpDT)
dt_tolAtrMult       = input.float(1.2, "DT Fiyat Toleransı ATR Katı", step=0.1, minval=0.0, group=grpDT)
dt_tolAtrLen        = input.int(14,  "DT ATR Periyodu (Tolerans)", minval=1, group=grpDT)
dt_useTriple        = input.bool(true, "DT Üçlü Dip/Tepe Ara", group=grpDT)

dt_useBreakoutATR   = input.bool(true, "DT Kırılımda ATR Eşiği Kullan", group=grpDT)
dt_breakoutATR      = input.float(0.05, "DT Kırılım ATR eps", step=0.01, group=grpDT)

dt_useTrendFilter   = input.bool(false, "DT Trend Filtresi Açık", group=grpDT)
dt_trendMaLen       = input.int(100, "DT Trend MA Periyodu", minval=5, group=grpDT)
dt_trendSlopeLen    = input.int(5,   "DT Trend Eğim Lookback", minval=1, group=grpDT)
dt_useHigherTFConfirm = input.bool(false, "DT Üst TF Trend Onayı Gerekli", group=grpDT)

dt_useVolFilter     = input.bool(true, "DT Kırılımda Hacim Filtresi", group=grpDT)
dt_volMaLen         = input.int(20, "DT Hacim MA Periyodu", minval=1, group=grpDT)
dt_volMult          = input.float(1.5, "DT Hacim MA Çarpanı", step=0.1, minval=0.1, group=grpDT)
dt_volZLen          = input.int(20, "DT Hacim ZScore Periyodu", minval=2, group=grpDT)
dt_volZTh           = input.float(1.0, "DT Hacim ZScore Eşiği", step=0.1, minval=0.0, group=grpDT)
dt_volRequireBoth   = input.bool(false, "DT Hem MA*Çarpan hem ZScore gereksin", group=grpDT)
useRealtimeBreak = input.bool(true, "DT: Bar kapanışını bekleme (high/low kırılım + realtime)", group=grpDT)

dt_showPotential    = input.bool(false, "DT Potansiyel Etiketleri Göster (POT)", group=grpDT)
dt_showNeckLines    = input.bool(true, "DT Boyun Çizgisi Göster", group=grpDT)
dt_drawNecksOnlyOnConf = input.bool(true, "DT Boyun Çizgisi Yalnızca Onayda Çiz", group=grpDT)
dt_limitNeckExtendBars = input.int(80, "DT Boyun Çizgisi Uzatma (bar)", minval=1, group=grpDT)
dt_minProfitPct     = input.float(4.0, "DT Minimum Kar Potansiyeli %", step=0.5, minval=0.0, group=grpDT)

dt_cBull            = input.color(color.lime, "DT Al (Dip) Rengi", group=grpDT)
dt_cBear            = input.color(color.red, "DT Sat (Tepe) Rengi", group=grpDT)
dt_cNeck            = input.color(color.orange, "DT Boyun Çizgi Rengi", group=grpDT)

dt_confirmationCooldown = input.int(6, "DT Onay Sonrası Bekleme (bar)", minval=0, group=grpDT)
dt_minRRtoShow          = input.float(1.2, "DT Gösterim için Min RR", step=0.1, group=grpDT)

// ---
// FO — Forecast Oscillator BUY-only Alert Module
// ---
grpFO = "FO — Forecast Oscillator"
fo_enable            = input.bool(false, "FO Module Enable", group=grpFO)
fo_chat_id           = input.string("", "FO Telegram chat_id (boş=DEFAULT)", group=grpFO)
fo_lenFosc           = input.int(14, "FO Length (Forecast Oscillator)", minval=1, group=grpFO)
fo_lenTrend          = input.int(50, "FO Trend Length (LinReg)", minval=1, group=grpFO)
fo_lenRSI            = input.int(14, "FO RSI Length", minval=1, group=grpFO)
fo_lenVol            = input.int(20, "FO Volume SMA Length", minval=1, group=grpFO)
fo_lenATR            = input.int(14, "FO ATR Length", minval=1, group=grpFO)
fo_slMult            = input.float(1.0, "FO Stop Loss ATR Multiplier", step=0.1, minval=0.1, group=grpFO)
fo_rr1               = input.float(1.0, "FO Target1 R-Multiple", step=0.25, minval=0.1, group=grpFO)
fo_rr2               = input.float(2.0, "FO Target2 R-Multiple", step=0.25, minval=0.1, group=grpFO)
fo_cooldownBars      = input.int(10, "FO Cooldown Bars (min gap between signals)", minval=0, group=grpFO)
fo_use_xu100         = input.bool(true, "FO Use XU100 Market Filter", group=grpFO)
fo_xuLen             = input.int(50, "FO XU100 Trend Length", minval=1, group=grpFO)
fo_confirm_on_close  = input.bool(true, "FO Confirm on Bar Close", group=grpFO)
fo_round_to_mintick  = input.bool(true, "FO Round to mintick", group=grpFO)

//----------------------------------------------------
// Preset uygula (Auto) — sadece DT formasyon kısmı
//----------------------------------------------------
var bool dt_presetsApplied = false
if not dt_presetsApplied
    dt_timeframeStr = timeframe.period
    _dt_is1H = dt_timeframeStr == "60" or dt_timeframeStr == "1H"
    _dt_is4H = dt_timeframeStr == "240" or dt_timeframeStr == "4H"
    _dt_is1D = dt_timeframeStr == "D" or dt_timeframeStr == "1D"
    if dt_tfPreset == "Auto"
        if _dt_is1H
            dt_x                := 12
            dt_minSpacing       := 6
            dt_tolPct           := 0.8
            dt_tolAtrMult       := 1.0
            dt_useTrendFilter   := false
            dt_confirmationCooldown := 5
            dt_minRRtoShow      := 1.1
            dt_useTriple        := false
        else if _dt_is4H
            dt_x                := 14
            dt_minSpacing       := 8
            dt_tolPct           := 1.0
            dt_tolAtrMult       := 1.2
            dt_useTrendFilter   := false
            dt_confirmationCooldown := 6
            dt_minRRtoShow      := 1.2
            dt_useTriple        := true
        else if _dt_is1D
            dt_x                := 18
            dt_minSpacing       := 10
            dt_tolPct           := 1.2
            dt_tolAtrMult       := 1.5
            dt_useTrendFilter   := false
            dt_confirmationCooldown := 8
            dt_minRRtoShow      := 1.3
            dt_useTriple        := true
    dt_presetsApplied := true

//----------------------------------------------------
// Helpers (DT formasyon)
//----------------------------------------------------
dt_atrTol   = ta.atr(dt_tolAtrLen) * dt_tolAtrMult
dt_withinTol(p1, p2) =>
    math.abs(p1 - p2) <= (math.max(p1, p2) * dt_tolPct / 100.0 + dt_atrTol)

dt_maTrend  = ta.sma(close, dt_trendMaLen)
dt_slope    = ta.sma(ta.change(dt_maTrend), dt_trendSlopeLen)
dt_trendDown = close < dt_maTrend and dt_slope < 0
dt_trendUp   = close > dt_maTrend and dt_slope > 0

dt_getHigherTFUp() =>
    _tf = timeframe.period == "D" ? "W" : (timeframe.period == "240" or timeframe.period == "4H" ? "D" : "240")
    [_c, _ma, _sl] = request.security(syminfo.tickerid, _tf, [close, ta.sma(close, dt_trendMaLen), ta.sma(ta.change(ta.sma(close, dt_trendMaLen)), dt_trendSlopeLen)])
    (_c > _ma and _sl > 0)

dt_getHigherTFDn() =>
    _tf = timeframe.period == "D" ? "W" : (timeframe.period == "240" or timeframe.period == "4H" ? "D" : "240")
    [_c, _ma, _sl] = request.security(syminfo.tickerid, _tf, [close, ta.sma(close, dt_trendMaLen), ta.sma(ta.change(ta.sma(close, dt_trendMaLen)), dt_trendSlopeLen)])
    (_c < _ma and _sl < 0)

dt_volMa = ta.sma(volume, dt_volMaLen)
dt_volZ  = (volume - dt_volMa) / ta.stdev(volume, dt_volZLen)
dt_volCondMA = volume > dt_volMa * dt_volMult
dt_volCondZ  = dt_volZ > dt_volZTh
dt_volOk = not dt_useVolFilter or (dt_volRequireBoth ? (dt_volCondMA and dt_volCondZ) : (dt_volCondMA or dt_volCondZ))

dt_epsUp = dt_useBreakoutATR ? (ta.atr(dt_tolAtrLen) * dt_breakoutATR) : 0.0
dt_epsDn = dt_epsUp

dt_rrCalc(entry, target, stop) =>
    _risk = math.max(0.0001, math.abs(entry - stop))
    _reward = math.max(0.0001, math.abs(target - entry))
    _reward / _risk

//----------------------------------------------------
// Pivot yakalama (chart TF) — formasyon
//----------------------------------------------------
dt_ph = ta.pivothigh(close, dt_x, dt_x)
dt_pl = ta.pivotlow(close,  dt_x, dt_x)

type dt_PivotRec
    float price
    int   index

var dt_PivotRec[] dt_lows  = array.new<dt_PivotRec>()
var dt_PivotRec[] dt_highs = array.new<dt_PivotRec>()

if not na(dt_pl)
    array.unshift(dt_lows, dt_PivotRec.new(dt_pl, bar_index - dt_x))
if not na(dt_ph)
    array.unshift(dt_highs, dt_PivotRec.new(dt_ph, bar_index - dt_x))

while array.size(dt_lows)  > 30
    array.pop(dt_lows)
while array.size(dt_highs) > 30
    array.pop(dt_highs)

// Max/Min yardımcıları
dt_maxHighBetween(iStart, iEnd) =>
    float m = na
    for i = 0 to array.size(dt_highs) - 1
        h = array.get(dt_highs, i)
        if h.index >= iStart and h.index <= iEnd
            m := na(m) ? h.price : math.max(m, h.price)
    m

dt_minLowBetween(iStart, iEnd) =>
    float m = na
    for i = 0 to array.size(dt_lows) - 1
        l = array.get(dt_lows, i)
        if l.index >= iStart and l.index <= iEnd
            m := na(m) ? l.price : math.min(m, l.price)
    m

//----------------------------------------------------
// Formasyon tespiti (chart TF)
//----------------------------------------------------
var bool  dt_potDB = false
var bool  dt_potDT = false
var bool  dt_potTB = false
var bool  dt_potTT = false

var float dt_neckDB = na
var float dt_neckDT = na
var float dt_neckTB = na
var float dt_neckTT = na

var dt_PivotRec dt_lastL1 = dt_PivotRec.new(na, na)
var dt_PivotRec dt_lastL2 = dt_PivotRec.new(na, na)
var dt_PivotRec dt_lastL3 = dt_PivotRec.new(na, na)
var dt_PivotRec dt_lastH1 = dt_PivotRec.new(na, na)
var dt_PivotRec dt_lastH2 = dt_PivotRec.new(na, na)
var dt_PivotRec dt_lastH3 = dt_PivotRec.new(na, na)

if array.size(dt_lows) >= 1
    dt_lastL1 := array.get(dt_lows, 0)
if array.size(dt_lows) >= 2
    dt_lastL2 := array.get(dt_lows, 1)
if array.size(dt_lows) >= 3
    dt_lastL3 := array.get(dt_lows, 2)

if array.size(dt_highs) >= 1
    dt_lastH1 := array.get(dt_highs, 0)
if array.size(dt_highs) >= 2
    dt_lastH2 := array.get(dt_highs, 1)
if array.size(dt_highs) >= 3
    dt_lastH3 := array.get(dt_highs, 2)

// Çift Dip
dt_potDB := false
if array.size(dt_lows) >= 2 and array.size(dt_highs) >= 1
    dt_spaceOK = (dt_lastL1.index - dt_lastL2.index) >= dt_minSpacing
    dt_tolOK   = dt_withinTol(dt_lastL1.price, dt_lastL2.price)
    dt_neck    = dt_maxHighBetween(dt_lastL2.index, dt_lastL1.index)
    dt_trendOK = not dt_useTrendFilter or dt_trendDown
    if dt_spaceOK and dt_tolOK and not na(dt_neck) and dt_trendOK
        dt_potDB  := true
        dt_neckDB := dt_neck

// Çift Tepe
dt_potDT := false
if array.size(dt_highs) >= 2 and array.size(dt_lows) >= 1
    dt_spaceOK2 = (dt_lastH1.index - dt_lastH2.index) >= dt_minSpacing
    dt_tolOK2   = dt_withinTol(dt_lastH1.price, dt_lastH2.price)
    dt_neck2    = dt_minLowBetween(dt_lastH2.index, dt_lastH1.index)
    dt_trendOK2 = not dt_useTrendFilter or dt_trendUp
    if dt_spaceOK2 and dt_tolOK2 and not na(dt_neck2) and dt_trendOK2
        dt_potDT  := true
        dt_neckDT := dt_neck2

// Üçlü Dip
dt_potTB := false
if dt_useTriple and array.size(dt_lows) >= 3 and array.size(dt_highs) >= 2
    dt_tolOK3   = dt_withinTol(dt_lastL1.price, dt_lastL2.price) and dt_withinTol(dt_lastL1.price, dt_lastL3.price)
    dt_spaceOK3 = (dt_lastL1.index - dt_lastL3.index) >= (dt_minSpacing * 2)
    dt_neckA   = dt_maxHighBetween(dt_lastL3.index, dt_lastL2.index)
    dt_neckB   = dt_maxHighBetween(dt_lastL2.index, dt_lastL1.index)
    float dt_neck3 = na
    dt_neck3 := na(dt_neckA) and na(dt_neckB) ? na : na(dt_neckA) ? dt_neckB : na(dt_neckB) ? dt_neckA : math.max(dt_neckA, dt_neckB)
    dt_trendOK3 = not dt_useTrendFilter or dt_trendDown
    if dt_tolOK3 and dt_spaceOK3 and not na(dt_neck3) and dt_trendOK3
        dt_potTB  := true
        dt_neckTB := dt_neck3

// Üçlü Tepe
dt_potTT := false
if dt_useTriple and array.size(dt_highs) >= 3 and array.size(dt_lows) >= 2
    dt_tolOK4   = dt_withinTol(dt_lastH1.price, dt_lastH2.price) and dt_withinTol(dt_lastH1.price, dt_lastH3.price)
    dt_spaceOK4 = (dt_lastH1.index - dt_lastH3.index) >= (dt_minSpacing * 2)
    dt_neckA2   = dt_minLowBetween(dt_lastH3.index, dt_lastH2.index)
    dt_neckB2   = dt_minLowBetween(dt_lastH2.index, dt_lastH1.index)
    float dt_neck4 = na
    dt_neck4 := na(dt_neckA2) and na(dt_neckB2) ? na : na(dt_neckA2) ? dt_neckB2 : na(dt_neckB2) ? dt_neckA2 : math.min(dt_neckA2, dt_neckB2)
    dt_trendOK4 = not dt_useTrendFilter or dt_trendUp
    if dt_tolOK4 and dt_spaceOK4 and not na(dt_neck4) and dt_trendOK4
        dt_potTT  := true
        dt_neckTT := dt_neck4

//----------------------------------------------------
// Onay + filtreler
//----------------------------------------------------
var bool dt_confDB = false
var bool dt_confDT = false
var bool dt_confTB = false
var bool dt_confTT = false

var int dt_lastConfBar_DB = na
var int dt_lastConfBar_DT = na
var int dt_lastConfBar_TB = na
var int dt_lastConfBar_TT = na

dt_canShowDB() => dt_confirmationCooldown == 0 or na(dt_lastConfBar_DB) or (bar_index - dt_lastConfBar_DB) > dt_confirmationCooldown
dt_canShowDT() => dt_confirmationCooldown == 0 or na(dt_lastConfBar_DT) or (bar_index - dt_lastConfBar_DT) > dt_confirmationCooldown
dt_canShowTB() => dt_confirmationCooldown == 0 or na(dt_lastConfBar_TB) or (bar_index - dt_lastConfBar_TB) > dt_confirmationCooldown
dt_canShowTT() => dt_confirmationCooldown == 0 or na(dt_lastConfBar_TT) or (bar_index - dt_lastConfBar_TT) > dt_confirmationCooldown

dt_trendOkUp   = not dt_useTrendFilter or dt_trendUp
dt_trendOkDown = not dt_useTrendFilter or dt_trendDown
dt_higherOkUp   = not dt_useHigherTFConfirm or dt_getHigherTFUp()
dt_higherOkDown = not dt_useHigherTFConfirm or dt_getHigherTFDn()

dt_confDB := false
if dt_potDB and not na(dt_neckDB)
    dt_closeBreakDB = useRealtimeBreak ? (high > (dt_neckDB + dt_epsUp) and barstate.isrealtime) : (close > (dt_neckDB + dt_epsUp))
    if dt_closeBreakDB and dt_volOk and dt_trendOkUp and dt_higherOkUp and dt_canShowDB()
        dt_rrDB = dt_rrCalc(close, dt_neckDB + math.abs(dt_neckDB - dt_lastL1.price), dt_neckDB - dt_epsUp)
        if dt_rrDB >= dt_minRRtoShow
            dt_confDB := true
            dt_lastConfBar_DB := bar_index

dt_confDT := false
if dt_potDT and not na(dt_neckDT)
    dt_closeBreakDT = useRealtimeBreak ? (low < (dt_neckDT - dt_epsDn) and barstate.isrealtime) : (close < (dt_neckDT - dt_epsDn))
    if dt_closeBreakDT and dt_volOk and dt_trendOkDown and dt_higherOkDown and dt_canShowDT()
        dt_rrDT = dt_rrCalc(close, dt_neckDT - math.abs(dt_lastH1.price - dt_neckDT), dt_neckDT + dt_epsDn)
        if dt_rrDT >= dt_minRRtoShow
            dt_confDT := true
            dt_lastConfBar_DT := bar_index

dt_confTB := false
if dt_useTriple and dt_potTB and not na(dt_neckTB)
    dt_closeBreakTB = useRealtimeBreak ? (high > (dt_neckTB + dt_epsUp) and barstate.isrealtime) : (close > (dt_neckTB + dt_epsUp))
    if dt_closeBreakTB and dt_volOk and dt_trendOkUp and dt_higherOkUp and dt_canShowTB()
        dt_rrTB = dt_rrCalc(close, dt_neckTB + math.abs(dt_neckTB - dt_lastL1.price), dt_neckTB - dt_epsUp)
        if dt_rrTB >= dt_minRRtoShow
            dt_confTB := true
            dt_lastConfBar_TB := bar_index

dt_confTT := false
if dt_useTriple and dt_potTT and not na(dt_neckTT)
    dt_closeBreakTT = useRealtimeBreak ? (low < (dt_neckTT - dt_epsDn) and barstate.isrealtime) : (close < (dt_neckTT - dt_epsDn))
    if dt_closeBreakTT and dt_volOk and dt_trendOkDown and dt_higherOkDown and dt_canShowTT()
        dt_rrTT = dt_rrCalc(close, dt_neckTT - math.abs(dt_lastH1.price - dt_neckTT), dt_neckTT + dt_epsDn)
        if dt_rrTT >= dt_minRRtoShow
            dt_confTT := true
            dt_lastConfBar_TT := bar_index

//----------------------------------------------------
// Boyun çizgisi (chart TF)
//----------------------------------------------------
var line dt_neckLineDB = na
var line dt_neckLineDT = na
var line dt_neckLineTB = na
var line dt_neckLineTT = na

dt_drawNeck(ref, y, startIdx) =>
    if not na(ref)
        line.delete(ref)
    line.new(startIdx, y, bar_index + dt_limitNeckExtendBars, y, xloc=xloc.bar_index, color=dt_cNeck, style=line.style_dashed, width=1)

if dt_showNeckLines
    if dt_drawNecksOnlyOnConf
        if dt_confDB and not na(dt_neckDB)
            dt_neckLineDB := dt_drawNeck(dt_neckLineDB, dt_neckDB, dt_lastL2.index)
        if dt_confDT and not na(dt_neckDT)
            dt_neckLineDT := dt_drawNeck(dt_neckLineDT, dt_neckDT, dt_lastH2.index)
        if dt_confTB and not na(dt_neckTB)
            dt_neckLineTB := dt_drawNeck(dt_neckLineTB, dt_neckTB, dt_lastL3.index)
        if dt_confTT and not na(dt_neckTT)
            dt_neckLineTT := dt_drawNeck(dt_neckLineTT, dt_neckTT, dt_lastH3.index)
    else
        if dt_potDB and not na(dt_neckDB)
            dt_neckLineDB := dt_drawNeck(dt_neckLineDB, dt_neckDB, dt_lastL2.index)
        if dt_potDT and not na(dt_neckDT)
            dt_neckLineDT := dt_drawNeck(dt_neckLineDT, dt_neckDT, dt_lastH2.index)
        if dt_potTB and not na(dt_neckTB)
            dt_neckLineTB := dt_drawNeck(dt_neckLineTB, dt_neckTB, dt_lastL3.index)
        if dt_potTT and not na(dt_neckTT)
            dt_neckLineTT := dt_drawNeck(dt_neckLineTT, dt_neckTT, dt_lastH3.index)

//----------------------------------------------------
// Chart TF etiketler + alertler (DT)
//----------------------------------------------------
if dt_confDB
    label.new(bar_index, low, "Çift Dip", style=label.style_label_up, color=dt_cBull, textcolor=color.white, size=size.small)
if dt_confDT
    label.new(bar_index, high, "Çift Tepe", style=label.style_label_down, color=dt_cBear, textcolor=color.white, size=size.small)
if dt_confTB
    label.new(bar_index, low, "Üçlü Dip", style=label.style_label_up, color=dt_cBull, textcolor=color.white, size=size.small)
if dt_confTT
    label.new(bar_index, high, "Üçlü Tepe", style=label.style_label_down, color=dt_cBear, textcolor=color.white, size=size.small)

// DT MTF
// Bu blok, DT formasyonlarını 4H ve 1D’de de takip eder, mesaj yollar.
// Hedefler: Neck mesafesi projeksiyonu; stop olarak neck +/- eps kullanılır.
dt_mtf_alerts_enable = input.bool(true, "DT MTF Alerts (4H/1D) aktif", group=grpDT)
dt_mtf_tf_4h        = input.timeframe("240", "DT MTF TF (4H)", group=grpDT)
dt_mtf_tf_1d        = input.timeframe("D",   "DT MTF TF (1D)",  group=grpDT)
dt_mtf_send_4h      = input.bool(true, "4H DT mesajları", group=grpDT)
dt_mtf_send_1d      = input.bool(true, "1D DT mesajları", group=grpDT)

// HTF’de aynı DT mantığını çalıştır: conf sinyalleri ve boyun değerlerini çek
f_dt_pack() => [dt_confDB, dt_confDT, dt_confTB, dt_confTT, dt_neckDB, dt_neckDT, dt_neckTB, dt_neckTT]

// 4H
[dt_confDB_4h, dt_confDT_4h, dt_confTB_4h, dt_confTT_4h, dt_neckDB_4h, dt_neckDT_4h, dt_neckTB_4h, dt_neckTT_4h] =   request.security(syminfo.tickerid, dt_mtf_tf_4h, f_dt_pack(), barmerge.gaps_off, barmerge.lookahead_off)

if not dt_mtf_alerts_enable
    dt_confDB_4h := false
    dt_confDT_4h := false
    dt_confTB_4h := false
    dt_confTT_4h := false
    dt_neckDB_4h := na
    dt_neckDT_4h := na
    dt_neckTB_4h := na
    dt_neckTT_4h := na

// 1D
[dt_confDB_1d, dt_confDT_1d, dt_confTB_1d, dt_confTT_1d, dt_neckDB_1d, dt_neckDT_1d, dt_neckTB_1d, dt_neckTT_1d] =   request.security(syminfo.tickerid, dt_mtf_tf_1d, f_dt_pack(), barmerge.gaps_off, barmerge.lookahead_off)

if not dt_mtf_alerts_enable
    dt_confDB_1d := false
    dt_confDT_1d := false
    dt_confTB_1d := false
    dt_confTT_1d := false
    dt_neckDB_1d := na
    dt_neckDT_1d := na
    dt_neckTB_1d := na
    dt_neckTT_1d := na


// Basit hedef üretici (neck mesafesi projeksiyonu, R1/R2)
f_dt_targets(_isLong, _neck, _close) =>
    rr    = math.max(syminfo.mintick, math.abs(_close - _neck))
    r1    = _isLong ? _close + rr : _close - rr
    r2    = _isLong ? _close + rr*2 : _close - rr*2
    stop  = _isLong ? _neck - dt_epsUp : _neck + dt_epsDn
    [fmtMint(r1), fmtMint(r2), fmtMint(stop)]

// Mesaj gönderici
f_dt_mtf_send(_tfLabel, _isLong, _typeLabel, _neckVal, _conf) =>
    if dt_mtf_alerts_enable and _conf and not na(_neckVal)
        // Calculate profit potential
        rr = math.max(syminfo.mintick, math.abs(close - _neckVal))
        profitPct = (rr / close) * 100.0
        
        // Check minimum profit threshold
        if profitPct >= dt_minProfitPct
            [r1Str, r2Str, stStr] = f_dt_targets(_isLong, _neckVal, close)
            priceLine = "\n" + (etiketDil=="TR" ? "Fiyat: " : "P: ") + fmtMint(close)
            hdr  = (_isLong ? "🟢 DT " : "🔻 DT ") + _typeLabel + " [" + syminfo.ticker + "] [" + _tfLabel + "]"
            body = etiketDil=="TR"
                 ? priceLine + "\nBoyun: " + fmtMint(_neckVal) + "\nHedef1: " + r1Str + "   Hedef2: " + r2Str + "\nStop (neck ± eps): " + stStr
                 : priceLine + "\nNeck: " + fmtMint(_neckVal) + "\nTarget1: " + r1Str + "   Target2: " + r2Str + "\nStop (neck ± eps): " + stStr
            id = "DT_MTF_" + _tfLabel + "_" + _typeLabel + "_" + str.tostring(bar_index)
            send_event(id, hdr + body, _isLong ? fChatId(true,false) : fChatId(false,true), alert.freq_once_per_bar_close)

// 4H
if dt_mtf_send_4h
    f_dt_mtf_send("4H", true,  "Çift Dip",   dt_neckDB_4h, dt_confDB_4h)
    f_dt_mtf_send("4H", false, "Çift Tepe",  dt_neckDT_4h, dt_confDT_4h)
    f_dt_mtf_send("4H", true,  "Üçlü Dip",   dt_neckTB_4h, dt_confTB_4h)
    f_dt_mtf_send("4H", false, "Üçlü Tepe",  dt_neckTT_4h, dt_confTT_4h)

// 1D
if dt_mtf_send_1d
    f_dt_mtf_send("1D", true,  "Çift Dip",   dt_neckDB_1d, dt_confDB_1d)
    f_dt_mtf_send("1D", false, "Çift Tepe",  dt_neckDT_1d, dt_confDT_1d)
    f_dt_mtf_send("1D", true,  "Üçlü Dip",   dt_neckTB_1d, dt_confTB_1d)
    f_dt_mtf_send("1D", false, "Üçlü Tepe",  dt_neckTT_1d, dt_confTT_1d)

//----------------------------------------------------
// FO — Forecast Oscillator BUY Alert Implementation
//----------------------------------------------------
// Track last FO signal bar for cooldown
var int fo_lastSignalBar = na

// FO calculation (only if enabled)
fo_src = close
fo_lrc  = ta.linreg(fo_src, fo_lenFosc, 0)
fo_lrc1 = ta.linreg(fo_src, fo_lenFosc, 1)
fo_lrs  = fo_lrc - fo_lrc1
fo_tsf  = ta.linreg(fo_src, fo_lenFosc, 0) + fo_lrs
fo_fosc = 100 * (fo_src - fo_tsf[1]) / fo_src

// Trend filters
fo_trendUp = ta.linreg(fo_src, fo_lenTrend, 0) > ta.linreg(fo_src, fo_lenTrend, 1)
fo_rsi = ta.rsi(fo_src, fo_lenRSI)
fo_rsiOK = fo_rsi > 50 and fo_rsi > fo_rsi[1]
fo_volSma = ta.sma(volume, fo_lenVol)
fo_volOK = volume > fo_volSma

// XU100 market filter (optional)
fo_xu100 = request.security("BIST:XU100", timeframe.period, close, barmerge.gaps_off, barmerge.lookahead_off)
fo_xuTrendUp = ta.linreg(fo_xu100, fo_xuLen, 0) > ta.linreg(fo_xu100, fo_xuLen, 1)
fo_xuOK = not fo_use_xu100 or fo_xuTrendUp

// Entry trigger
fo_crossover = ta.crossover(fo_fosc, 0)

// Cooldown check
fo_cooldownOK = na(fo_lastSignalBar) or (bar_index - fo_lastSignalBar) >= fo_cooldownBars

// Combine all filters
fo_signal = fo_enable and fo_crossover and fo_trendUp and fo_rsiOK and fo_volOK and fo_xuOK and fo_cooldownOK

// Confirmation logic
fo_finalSignal = fo_signal and (fo_confirm_on_close ? barstate.isconfirmed : true)

// Risk/targets calculation
fo_atr = ta.atr(fo_lenATR)
fo_entry = close
fo_stop = fo_entry - fo_atr * fo_slMult
fo_risk = fo_entry - fo_stop
fo_target1 = fo_entry + fo_rr1 * fo_risk
fo_target2 = fo_entry + fo_rr2 * fo_risk

// Format helper function
fo_fmt(val) => fo_round_to_mintick ? fmtMint(val) : str.tostring(val, "#.####")

// Send alert
if fo_finalSignal and fo_risk > 0
    // Update last signal bar
    fo_lastSignalBar := bar_index
    
    // Format values
    fo_entryStr = fo_fmt(fo_entry)
    fo_stopStr = fo_fmt(fo_stop)
    fo_t1Str = fo_fmt(fo_target1)
    fo_t2Str = fo_fmt(fo_target2)
    fo_tfStr = f_tf_label(timeframe.period)
    
    // Build message - short parseable format
    fo_msg = "FO_AL|" + syminfo.ticker + "|TF=" + fo_tfStr + "|E=" + fo_entryStr + "|SL=" + fo_stopStr + "|T1=" + fo_t1Str + "|T2=" + fo_t2Str
    
    // Determine chat_id (use dedicated or fall back to default)
    fo_chatId = fo_chat_id == "" ? telegramChatId : fo_chat_id
    
    // Send event
    send_event("FO_BUY_" + str.tostring(bar_index), fo_msg, fo_chatId, alert.freq_once_per_bar_close)

alertcondition(dt_confDB, title="DT Çift Dip Onaylandı", message="DT Çift Dip onaylı kırılım.")
alertcondition(dt_confDT, title="DT Çift Tepe Onaylandı", message="DT Çift Tepe onaylı kırılım.")
alertcondition(dt_confTB, title="DT Üçlü Dip Onaylandı", message="DT Üçlü Dip onaylı kırılım.")
alertcondition(dt_confTT, title="DT Üçlü Tepe Onaylandı", message="DT Üçlü Tepe onaylı kırılım.")

// alertcondition (Unified mantıkta kullanılan final booleanlar)
alertcondition(allowBuy,   title="ST Flip AL (HTF filtreli/Grace)")
alertcondition(allowSell,  title="ST Flip SAT (HTF filtreli)")
alertcondition(allowLInt,  title="BANKO KESİŞME AL (HTF/Grace)")
alertcondition(allowSInt,  title="BANKO KESİŞME SAT (HTF)")
alertcondition(allowHitR1, title="Hedef1 (R1) Ulaşıldı")
alertcondition(allowHitR2, title="Hedef2 (R2) Ulaşıldı")
alertcondition(trailMoved, title="Trail Stop Yükseldi")

// SQZ bağımsız sinyal alarmları (Signal modu)
alertcondition(sqz_enable and (sqz_mode=="Signal") and sqzOff and not sqzOff[1] and (sqz_val > 0), title="SQZ Long Release")
alertcondition(sqz_enable and (sqz_mode=="Signal") and sqzOff and not sqzOff[1] and (sqz_val < 0), title="SQZ Short Release")

// FO Forecast Oscillator BUY signal
alertcondition(fo_finalSignal and fo_risk > 0, title="FO BUY Signal", message="Forecast Oscillator BUY signal fired")