//@version=5
indicator(title="V7-6", shorttitle="V7-6",  overlay=true,  max_labels_count=500, max_lines_count=500, max_boxes_count=200,
     dynamic_requests=true)


// ---
// 0) GENEL — Stabil Başlık, Versiyon Etiketi, Safe Boot, Anchor Plot
// ---
grpGEN = "Genel"
versionLabel   = input.string("2.6-sqz-pro", "Versiyon Etiketi", group=grpGEN)
safeBoot       = input.bool(false, "SAFE BOOT", group=grpGEN)
showAnchorPlot = input.bool(true, "Anchor Plot", group=grpGEN)
// Görsel ölçek sabitleyici (grafikte görünmez)
plot(showAnchorPlot ? close : na, title="ANCHOR_PRICE", display=display.none)

// ---
// 1) INPUTS
// ---
grpST = "Supertrend"
atrLen          = input.int(10,   "ATR Period", group=grpST, minval=1)
atrMult         = input.float(3.0,"ATR Multiplier", group=grpST, step=0.1)
altAtrMethod    = input.bool(true,"Alt ATR", group=grpST)
showSTSignals   = input.bool(true,"ST Labels", group=grpST)
stHighlight     = input.bool(true,"Highlight Background", group=grpST)

grpEMA = "SlingShot"
emaFastLen = input.int(38,"EMA Fast", group=grpEMA, minval=1)
emaSlowLen = input.int(62,"EMA Slow", group=grpEMA, minval=1)
showEMAs   = input.bool(true,"Show EMA+Fill", group=grpEMA)

grpSS = "SlingShot Bars"
showConservative        = input.bool(true,"Cons Bars", group=grpSS)
showAggressive          = input.bool(true,"Agg Pullback Bars", group=grpSS)
hideAggressiveWhenConservative = input.bool(true,"Hide Agg if Cons", group=grpSS)

grpHTF = "HTF Trend Filtresi"
enableHTF        = input.bool(true, "HTF EMA200", group=grpHTF)
htf_tf           = input.timeframe("D", "HTF TF", group=grpHTF)
showHTFLine      = input.bool(true, "HTF çizgi", group=grpHTF)
htfSlopeConfirm  = input.bool(true,"HTF eğim şartı", group=grpHTF)
htfSlopeLen      = input.int(5,"HTF eğim bar", group=grpHTF, minval=1)

htfModeLabels    = input.string("Strict", "HTF Mode (Labels)", options=["Strict","Soft","Off"], group=grpHTF)
htfModeAlerts    = input.string("Strict", "HTF Mode (Alerts)", options=["Strict","Soft","Off"], group=grpHTF)
htfSoftTolType   = input.string("Percent", "Soft Tol. Type", options=["Percent","ATRx"], group=grpHTF)
htfSoftTolPct    = input.float(0.8, "Soft Tol. %", step=0.1, minval=0.0, group=grpHTF)
htfSoftTolATRx   = input.float(0.25, "Soft Tol. ATRx", step=0.05, minval=0.0, group=grpHTF)
htfATRlen        = input.int(14, "Soft Tol. ATR Length (HTF)", minval=1, group=grpHTF)
htfSoftSlopeEps  = input.float(0.0, "Soft Slope epsilon", step=0.01, minval=0.0, group=grpHTF)

// Uygulama kapsamları
htfApplyToBuyEntries  = input.bool(true,  "HTF: BUY entries",  group=grpHTF)
htfApplyToSellEntries = input.bool(false, "HTF: SELL entries", group=grpHTF)
htfApplyToBuyLabels   = input.bool(true,  "HTF: BUY labels",   group=grpHTF)
htfApplyToSellLabels  = input.bool(false, "HTF: SELL labels",  group=grpHTF)
htfApplyToBuyAlerts   = input.bool(true,  "HTF: BUY alerts",   group=grpHTF)
htfApplyToSellAlerts  = input.bool(true,  "HTF: SELL alerts",  group=grpHTF)
htfApplyToExits       = input.bool(false, "HTF: Exits",        group=grpHTF)

buyHTFGraceEnabled        = input.bool(true,  "BUY HTF Grace override", group=grpHTF)
buyHTFGraceBars           = input.int(12,     "BUY Grace window (bars after SAT)", group=grpHTF, minval=1)
buyHTFGraceUseChartEMA200 = input.bool(true,  "BUY Grace: chart EMA200 above", group=grpHTF)
buyHTFGraceChartBars      = input.int(48,     "BUY Grace (EMA200 üstü) en fazla X bar", group=grpHTF, minval=1)

grpIntersect = "Intersection"
enableIntersection = input.bool(true,"ST Flip + Cons", group=grpIntersect)
confirmWindow      = input.int(3,"Cons Window (bars)", group=grpIntersect, minval=0)
confirmOnClose     = input.bool(false,"Confirm on Close", group=grpIntersect)

grpRisk = "Risk & Targets"
showRTargets         = input.bool(true,"Show R1/R2", group=grpRisk)
showRTargetLabels    = input.bool(true,"Show R1/R2 text", group=grpRisk)
r1Multiple           = input.float(1.0,"R1 Multiple", step=0.25, group=grpRisk)
r2Multiple           = input.float(2.0,"R2 Multiple", step=0.25, group=grpRisk)
useFlipIfNoIntersect = input.bool(true,"ST Flip if no Int", group=grpRisk)
trailStopEnabled     = input.bool(false,"Trail Stop ST", group=grpRisk)
stopBufferPct        = input.float(0.0,"Stop Buffer %", step=0.1, minval=0)
applyBufferToStop    = input.bool(true,"Buffer initial+trail", group=grpRisk)
minRiskTicks         = input.int(0,"Min Risk ticks", group=grpRisk, minval=0)
showPrevStructureLvl = input.bool(false,"Prev Structure", group=grpRisk)
structureLookbackBars= input.int(60,"Struct Lookback", group=grpRisk, minval=5)
showRiskBox          = input.bool(false,"Risk Box", group=grpRisk)

grpColors = "Colors"
entryLineColor       = input.color(color.new(color.teal,40),"Entry Line", group=grpColors)
stopLineColorTargets = input.color(color.new(color.red,60),"Stop Line", group=grpColors)
r1Color              = input.color(color.new(color.orange,0),"Hedef1 Line", group=grpColors)
r2Color              = input.color(color.new(color.fuchsia,0),"Hedef2 Line", group=grpColors)
structColor          = input.color(color.new(color.purple,0),"Structure Line", group=grpColors)
riskBoxOpacity       = input.int(85,"Risk Box Opacity", group=grpColors, minval=0, maxval=100)

grpResSup = "Destek/Direnç (Pivot)"
showPivotRes          = input.bool(true,  "Pivot Direnç", group=grpResSup)
showPivotSup          = input.bool(true,  "Pivot Destek", group=grpResSup)
showPivotLabels       = input.bool(true,  "R/S etiket", group=grpResSup)
pivotLeft             = input.int(5,      "Pivot Left", group=grpResSup, minval=1)
pivotRight            = input.int(5,      "Pivot Right", group=grpResSup, minval=1)
maxPivotLevels        = input.int(6,      "Max seviye", group=grpResSup, minval=1, maxval=20)
pivotExtendBars       = input.int(180,    "Uzatma bar", group=grpResSup, minval=20, maxval=2000)
pivotResColor         = input.color(color.new(color.red, 40),   "Direnç rengi", group=grpResSup)
pivotSupColor         = input.color(color.new(color.green,40),  "Destek rengi", group=grpResSup)

grpUA = "Toplu Alarm"
enableUnifiedAlert = input.bool(false,"Enable Unified Alert", group=grpUA)
useCustomJsonAlert = input.bool(true,"JSON (Telegram) format", group=grpUA)
telegramChatId     = input.string("-1003015889970","Telegram chat_id (DEFAULT)", group=grpUA)
telegramChatIdBuy  = input.string("-1003015889970", "Telegram chat_id (BUY)",  group=grpUA)
telegramChatIdSell = input.string("-1002587291984", "Telegram chat_id (SELL)", group=grpUA)
telegramChatIdMtfBanko = input.string("-1002781417418", "Telegram chat_id (MTF BANKO KESİŞME)", group=grpUA)
dailyOnce          = input.bool(true,"Daily once per event (CONFIRMED only)", group=grpUA)
cooldownMinutes    = input.int(30,"Cooldown (minutes) (CONFIRMED only)", group=grpUA, minval=0)
includeBuyFlip        = input.bool(true,"BUY Flip", group=grpUA)
includeSellFlip       = input.bool(true,"SELL Flip", group=grpUA)
includeLongIntersect  = input.bool(true,"Long Kesişme", group=grpUA)
includeShortIntersect = input.bool(true,"Short Kesişme", group=grpUA)
includeHitR1          = input.bool(true,"Include Hedef1 Hit", group=grpUA)
includeHitR2          = input.bool(true,"Include Hedef2 Hit", group=grpUA)
includeTrailMove      = input.bool(false,"Include Trail Move", group=grpUA)
includeExit           = input.bool(true,"Include Exit / Poz Çıkış", group=grpUA)

grpHybrid = "Hybrid (Potansiyel + Onay)"
enableHybrid           = input.bool(true,  "Hybrid Mod (POT + CONF)", group=grpHybrid)
hybMinProgressPct      = input.float(30.0, "POT: Minimum Bar İlerlemesi (%)", step=5, group=grpHybrid)
hybStabilityTicks      = input.int(2,      "POT: Stabilite Sayaç (>=)", minval=1, group=grpHybrid)
hybCooldownMinutes     = input.int(20,     "POT: Cooldown (dakika)", minval=0, group=grpHybrid)
hybShowPotentialLabel  = input.bool(true,  "Grafikte Potansiyel Label Göster", group=grpHybrid)
hybUseSeparateAlerts   = input.bool(false,  "POT İçin Ayrı Alert Mesajı", group=grpHybrid)

grpProfiles = "Profil (Hızlı Ön ayar)"
profilePreset = input.string("Off (manual)", "Profil", options=["Off (manual)", "Aggressive (Early)", "Balanced (Early)", "Safe"], group=grpProfiles)
etiketDil = input.string("TR","Dil / Language", options=["TR","EN"])

grpExtra = "Extra Filters"
suppressBuyIfDailyUp = input.bool(true,  "AL Engel: Günlük ≥ %", group=grpExtra)
dailyUpPctThreshold  = input.float(8.0,  "Eşik (%)", step=0.5, minval=0.0, group=grpExtra)

grpBuyQG = "BQG"
buyQG_enable            = input.bool(true,  "On", group=grpBuyQG)
buyQG_overext_5d_pct    = input.float(20.0, "5D%", step=1.0, minval=0.0, group=grpBuyQG)
buyQG_overext_20d_pct   = input.float(50.0, "20D%", step=5.0, minval=0.0, group=grpBuyQG)
buyQG_overext_126d_pct  = input.float(250.0, "126D%", step=10.0, minval=0.0, group=grpBuyQG)
buyQG_donchian_len      = input.int(20, "Don", minval=5, group=grpBuyQG)
buyQG_breakout_req      = input.bool(true, "BreakReq", group=grpBuyQG)
buyQG_retest_window     = input.int(5, "Retest", minval=0, group=grpBuyQG)
buyQG_min_score         = input.int(3, "MinScr", minval=0, maxval=10, group=grpBuyQG)
buyQG_score_trend       = input.bool(true, "Trend", group=grpBuyQG)
buyQG_score_adx         = input.bool(true, "ADX", group=grpBuyQG)
buyQG_adx_threshold     = input.int(22, "ADX≥", minval=10, group=grpBuyQG)
buyQG_score_cmf         = input.bool(true, "CMF", group=grpBuyQG)
buyQG_cmf_threshold     = input.float(0.0, "CMF≥", step=0.01, group=grpBuyQG)
buyQG_score_breakout    = input.bool(true, "Break", group=grpBuyQG)
buyQG_apply_sqz         = input.bool(true, "SQZ", group=grpBuyQG)
buyQG_apply_mg          = input.bool(true, "MG", group=grpBuyQG)
buyQG_apply_m2          = input.bool(true, "M2", group=grpBuyQG)
buyQG_apply_banko       = input.bool(false, "BANKO", group=grpBuyQG)

grpSellQG = "SQG"
sellQG_enable            = input.bool(true,  "On", group=grpSellQG)
sellQG_overext_5d_pct    = input.float(20.0, "5D%", step=1.0, minval=0.0, group=grpSellQG)
sellQG_overext_20d_pct   = input.float(50.0, "20D%", step=5.0, minval=0.0, group=grpSellQG)
sellQG_overext_126d_pct  = input.float(250.0, "126D%", step=10.0, minval=0.0, group=grpSellQG)
sellQG_donchian_len      = input.int(20, "Don", minval=5, group=grpSellQG)
sellQG_breakout_req      = input.bool(true, "BreakReq", group=grpSellQG)
sellQG_min_score         = input.int(3, "MinScr", minval=0, maxval=10, group=grpSellQG)
sellQG_score_trend       = input.bool(true, "Trend", group=grpSellQG)
sellQG_score_adx         = input.bool(true, "ADX", group=grpSellQG)
sellQG_adx_threshold     = input.int(22, "ADX≥", minval=10, group=grpSellQG)
sellQG_score_cmf         = input.bool(true, "CMF", group=grpSellQG)
sellQG_cmf_threshold     = input.float(0.0, "CMF≤", step=0.01, group=grpSellQG)
sellQG_score_breakout    = input.bool(true, "Break", group=grpSellQG)
sellQG_apply_sqz         = input.bool(true, "SQZ", group=grpSellQG)

grpAlertSafe = "Alert Güvenlik"
alertsRealtimeOnly = input.bool(true, "Realtime only", group=grpAlertSafe)
tr_ascii_upper = input.bool(true, "TR ASCII üst harf", group=grpAlertSafe)

grpMT = "Modül 2 — MesutTrend 4H + MG"
includeModule2          = input.bool(true, "M2 aktif", group=grpMT)
mt_coeff                = input.float(1.0,'MT Multiplier',step=0.1,group=grpMT)
mt_AP                   = input.int(14,'MT Common Period',minval=1,group=grpMT)
mt_useRSI_noVolume      = input.bool(false,'MT Use RSI if no volume?',group=grpMT)
mt_cooldown_minutes     = input.int(1440,'MT Alarm Cooldown (min;0=off)',minval=0,group=grpMT)
mt_enableSellAlerts     = input.bool(false,"MT SELL onay aktif?",group=grpMT)
mt_tpATRmult            = input.float(1.0,'MT TP ATR Mult',step=0.1,minval=0.1,group=grpMT)
mt_stopBufferPct        = input.float(0.0,'MT Stop buffer %',step=0.1,minval=0.0,group=grpMT)
mt_roundToMintick       = input.bool(true,"MT Round target/stop to mintick",group=grpMT)
mt_useOriginalATR       = input.bool(false,"MT Orijinal ATR (sma(tr))",group=grpMT)
mt_includeCandleCloseBuy= input.bool(false,"MT Candle Close Buy sinyali",group=grpMT)
mt_sendCombinedAlerts   = input.bool(true,  "M2 Kombine", group=grpMT)
mt_sendConfirmedAlerts  = input.bool(true,  "M2 Onaylı", group=grpMT)
mt_sendCandleAlerts     = input.bool(true,  "M2 Candle", group=grpMT)
mt_enableEarlyAlerts    = input.bool(false,  "M2 Erken", group=grpMT)

grpMG = "Modül 2 — MG Multi Güçlü AL"
mg_periodMACD   = input.int(12,"MACD Fast",group=grpMG)
mg_slowMACD     = input.int(26,"MACD Slow",group=grpMG)
mg_signalMACD   = input.int(9,"MACD Signal",group=grpMG)
mg_macdTF       = input.timeframe("60","MACD TF",group=grpMG)
mg_maLen        = input.int(20,"MA Length",group=grpMG)
mg_maType       = input.string("EMA","MA Type",options=["SMA","EMA","WMA","HullMA","VWMA","RMA","TEMA","TilsonT3"],group=grpMG)
mg_maTF         = input.timeframe("60","MA TF",group=grpMG)
mg_alphaCoeff   = input.float(1.0,"AlphaTrend Mult",group=grpMG,step=0.1)
mg_alphaPeriod  = input.int(14,"AlphaTrend Period",group=grpMG)
mg_useRSIConfirm= input.bool(true,"Add RSI Confirm?",group=grpMG)
mg_rsiTF        = input.timeframe("60","RSI TF",group=grpMG)
mg_rsiLen       = input.int(14,"RSI Len",group=grpMG)
mg_rsiThresh    = input.int(50,"Min RSI",group=grpMG)
showStrongShapeFiltered= input.bool(false,"Strong Buy shape uses daily filter (M2)",group=grpMG)
mg_enableAlertsChart = input.bool(false,  "MG: Chart TF kapanışında mesaj", group=grpMG)
mg_enableAlertsMTF   = input.bool(true,  "MG: 1H/4H/1D kapanışlarında mesaj", group=grpMG)

// PG grupları
pg_groupSig  = "PG — Sinyal"
pg_groupVA   = "PG — Değer Alanı"
pg_groupInfo = "PG — Raporlama"
pg_groupHTF  = "PG — HTF Filtre"
pg_groupAL   = "PG — Alarm"
pg_groupEX   = "PG — Ek Filtre"
pg_groupMTF  = "PG — MTF (1H/4H/1D)"
pg_groupHC   = "PG — Yüksek Güven (Uzman Filtreler)"

// PG — temel
pg_enable = input.bool(true, "PG Modülü Aktif", group=pg_groupSig)
pg_use_close_confirm = input.bool(true, "Bar kapanışında teyit (PG)", group=pg_groupSig)
pg_chart_also_send   = input.bool(true, "PG Chart TF mesajlarını da gönder (MTF açıksa ek)", group=pg_groupSig)

pg_use_zscore_vol  = input.bool(true,  "Hacimde Z-Score (PG)", group=pg_groupSig)
pg_vol_period      = input.int(20,     "Hacim Periyodu (PG)", minval=5, group=pg_groupSig)
pg_vol_multiplier  = input.float(2.0,  "Hacim Çarpanı SMA (PG)", step=0.1, group=pg_groupSig)
pg_vol_z_threshold = input.float(2.0,  "Z-Score Eşiği (PG)", step=0.1, group=pg_groupSig)
pg_cmf_period      = input.int(20,  "CMF Periyodu (PG)", minval=5, group=pg_groupSig)
pg_cmf_pos_th      = input.float(0.05,  "CMF Pozitif (AL) (PG)", step=0.01, group=pg_groupSig)
pg_cmf_neg_th      = input.float(-0.05, "CMF Negatif (SAT) (PG)", step=0.01, group=pg_groupSig)

// PG — Değer alanı
pg_va_mode       = input.string("VWAP","Değer Alanı (PG)", options=["VWAP","Anchored VWAP","MA+Bollinger"], group=pg_groupVA)
pg_vwap_source   = input.source(hlc3,  "VWAP Kaynağı (PG)", group=pg_groupVA)
pg_anchor_use_session = input.bool(false,"Her seans başı anchor (PG)", group=pg_groupVA)
pg_use_anchor_by_time = input.bool(true, "Anchor'ı tarih/saat ile seç (PG)", group=pg_groupVA)
pg_anchor_time        = input.time(timestamp("2024-01-01T00:00:00"), "Anchor Tarihi (UTC) (PG)", group=pg_groupVA)
pg_bb_src     = input.source(close, "BB Kaynağı (PG)", group=pg_groupVA)
pg_bb_length  = input.int(20,"BB MA Periyodu (PG)", minval=5, group=pg_groupVA)
pg_bb_mult    = input.float(2.0,"BB Std Sapma (PG)", step=0.1, group=pg_groupVA)
pg_bb_ma_type = input.string("SMA","BB MA Türü (PG)", options=["SMA","EMA"], group=pg_groupVA)

// PG — raporlama
pg_trend_len     = input.int(50, "Trend EMA (PG)", minval=5, group=pg_groupInfo)
pg_fast_len      = input.int(12, "MACD Hızlı (PG)",  minval=1, group=pg_groupInfo)
pg_slow_len      = input.int(26, "MACD Yavaş (PG)",  minval=2, group=pg_groupInfo)
pg_signal_len    = input.int(9,  "MACD Sinyal (PG)", minval=1, group=pg_groupInfo)
pg_adx_len       = input.int(14,"ADX Periyodu (PG)", minval=5, group=pg_groupInfo)
pg_adx_threshold = input.int(22,"ADX Güçlü Eşik (PG)", minval=5, group=pg_groupInfo)
pg_atr_len       = input.int(14,"ATR Periyodu (PG)", minval=5, group=pg_groupInfo)

// PG — HTF
pg_enable_htf_cmf = input.bool(false, "HTF CMF yön filtresi (PG)", group=pg_groupHTF)
pg_htf_cmf_tf     = input.timeframe("60","HTF CMF TF (PG)", group=pg_groupHTF)
pg_htf_cmf_pos_th = input.float(0.0,"HTF CMF Pozitif (AL) (PG)", step=0.01, group=pg_groupHTF)
pg_htf_cmf_neg_th = input.float(0.0,"HTF CMF Negatif (SAT) (PG)", step=0.01, group=pg_groupHTF)

// PG — alarm
pg_enable_alerts     = input.bool(true,  "PG Alert aktif (Chart TF)", group=pg_groupAL)
pg_use_json_telegram = input.bool(false, "Telegram JSON (PG’ye özgü) — Global ile OR", group=pg_groupAL)
pg_chat_buy          = input.string("",  "chat_id (PG BUY) (boş=global)", group=pg_groupAL)
pg_chat_sell         = input.string("",  "chat_id (PG SELL) (boş=global)", group=pg_groupAL)
pg_daily_once        = input.bool(true,  "Aynı gün bir kez (PG)", group=pg_groupAL)
pg_cooldown_minutes  = input.int(15,      "Cooldown (dk) (PG)", minval=0, group=pg_groupAL)
pg_window_enable     = input.bool(true,  "PG Window Enable (son X TF barda PG varsa gönder)", group=pg_groupAL)
pg_window_bars       = input.int(3,      "PG Window Bars (TF)", minval=1, group=pg_groupAL)

// PG — ek filtre
pg_suppress_buy_if_daily_up = input.bool(false, "Günlük değişim ≥ %X ise PG-AL engelle", group=pg_groupEX)
pg_daily_up_pct_threshold   = input.float(8.0, "Günlük % eşiği (PG)", step=0.5, minval=0.0, group=pg_groupEX)
pg_require_di_align         = input.bool(true, "PG: Yön için DI hizası şart", group=pg_groupEX)
pg_require_ad_confirm       = input.bool(true, "PG: AKD (Acc/Dist) eğim onayı gerekli", group=pg_groupEX)
pg_ad_slope_len             = input.int(5, "PG: AKD eğim periyodu", minval=1, group=pg_groupEX)

// PG — Yüksek Güven (Uzman) — yeni
pg_hc_enable            = input.bool(true,  "PG High-Confidence (Uzman filtreler)", group=pg_groupHC)
pg_hc_cmf_pos           = input.float(0.10, "HC: CMF pozitif eşiği (AL)", step=0.01, group=pg_groupHC)
pg_hc_cmf_neg           = input.float(-0.10,"HC: CMF negatif eşiği (SAT)", step=0.01, group=pg_groupHC)
pg_hc_min_adx           = input.int(18,     "HC: Min ADX", minval=5, group=pg_groupHC)
pg_hc_min_di_diff       = input.float(3.0,  "HC: Min DI fark puanı", step=0.5, group=pg_groupHC)
pg_hc_vwap_dist_pct     = input.float(0.05, "HC: Min VWAP mesafe %", step=0.05, minval=0.0, group=pg_groupHC)
pg_hc_min_body_pct      = input.float(50.0, "HC: Min gövde/oran %", step=5.0, minval=0.0, maxval=100.0, group=pg_groupHC)
pg_hc_close_near_pct    = input.float(25.0, "HC: Kapanışın range ucuna yakın %", step=5.0, minval=0.0, maxval=50.0, group=pg_groupHC)
pg_hc_neg_day_rule      = input.bool(true,  "HC: Gün negatifken inflow kapat; güçlü akümülasyon istisna", group=pg_groupHC)
pg_hc_limit_down_guard  = input.bool(true,  "HC: Taban-kilit koruması (AL'i bastır)", group=pg_groupHC)
pg_hc_limit_down_len    = input.int(5,      "HC: Taban-kilit pencere (bar)", minval=3, group=pg_groupHC)

// MTF Alerts (1H/2H/4H/1D)
grpMTF = "MTF Alerts (1H/2H/4H/1D)"
mtf_enable      = input.bool(true,  "MTF Alert Paketi Aktif", group=grpMTF)
mtf_use_1h      = input.bool(false,  "1H (60)", group=grpMTF)
mtf_use_2h      = input.bool(false,  "2H (120)", group=grpMTF)
mtf_use_4h      = input.bool(true,  "4H (240)", group=grpMTF)
mtf_use_1d      = input.bool(true,  "1D (D)", group=grpMTF)
mtf_send_if_any = input.bool(true,  "Kapanan TF’te sinyal varsa gönder", group=grpMTF)
mtf_only_banko  = input.bool(true,  "MTF mesajları: yalnız BANKO KESİŞME", group=grpMTF)

// Refactor ekleri
grpRef = "Refactor Ek"
combinePotAndConfirm = input.bool(false, "Hybrid: POT + Confirm tek mesaj", group=grpRef)
unifiedIncludePG     = input.bool(true,  "Unified mesajına PG özeti ekle", group=grpRef)
showDebugFlags       = input.bool(false, "Debug Event ID Label", group=grpRef)

// Early (intra-bar) — BANKO
grpEarly = "Early Alerts"
earlyBankoEnabled        = input.bool(false,  "ERKEN BANKO (intra-bar) aktif", group=grpEarly)
earlyBankoMinProgressPct = input.float(25.0, "ERKEN BANKO: min bar ilerleme (%)", step=5.0, minval=0.0, maxval=100.0, group=grpEarly)
earlyBankoCooldownMin    = input.int(15,     "ERKEN BANKO: cooldown (dakika)", minval=0, group=grpEarly)

// Önceki gün özeti (Berlin 09:00)
grpPrev = "Önceki Gün Özeti"
prevAppendEnabled = input.bool(true, "Bugünkü AL mesajlarına dünkü olumlu sinyali ekle", group=grpPrev)
prevTz            = input.string("Europe/Berlin", "Saat Dilimi (DST otomatik)", group=grpPrev)
prevSessionHour   = input.int(9, "Seans açılışı saat (yerel TZ)", minval=0, maxval=23, group=grpPrev)
prevSessionMinute = input.int(0, "Seans açılışı dakika", minval=0, maxval=59, group=grpPrev)

// SQZ (LazyBear)
grpSQZ = "SQZ (LazyBear)"
//sqz_enable        = input.bool(false, "SQZ Modülü Aktif", group=grpSQZ)
//sqz_mode          = input.string("Off", "Kullanım Modu", options=["Off","Filter","Signal"], group=grpSQZ)
//sqz_filter_mode   = input.string("Strict", "Filter Sıkılığı", options=["Strict","Soft"], group=grpSQZ)
sqz_enable        = input.bool(true, "SQZ Modülü Aktif", group=grpSQZ)
sqz_mode          = input.string("Signal", "Kullanım Modu", options=["Off","Filter","Signal"], group=grpSQZ)
sqz_filter_mode   = input.string("Strict", "Filter Sıkılığı", options=["Strict","Soft"], group=grpSQZ)
sqz_lenBB         = input.int(20, "BB Length", group=grpSQZ, minval=1)
sqz_multBB        = input.float(2.0, "BB MultFactor", group=grpSQZ, step=0.1)
sqz_lenKC         = input.int(20, "KC Length", group=grpSQZ, minval=1)
sqz_multKC        = input.float(1.5, "KC MultFactor", group=grpSQZ, step=0.1)
sqz_useTR         = input.bool(true, "Use TrueRange (KC)", group=grpSQZ)
sqz_add_to_unified= input.bool(false, "Unified mesaja SQZ olayı ekle", group=grpSQZ)

// ---
// SAFE BOOT — etkin bayraklar
// ---
eff_pg_enable           = pg_enable           and not safeBoot
eff_includeModule2      = includeModule2      and not safeBoot
eff_mg_enableAlertsMTF  = mg_enableAlertsMTF  and not safeBoot
eff_mtf_enable          = mtf_enable          and not safeBoot
eff_prevAppendEnabled   = prevAppendEnabled   and not safeBoot

// Profil türevleri
useProfile    = profilePreset != "Off (manual)"
isAggProfile  = profilePreset == "Aggressive (Early)"
isBalProfile  = profilePreset == "Balanced (Early)"
isSafeProfile = profilePreset == "Safe"

eff_htfBuyEntries  = useProfile ? (isAggProfile ? false : isBalProfile ? true  : true)  : htfApplyToBuyEntries
eff_htfBuyLabels   = useProfile ? (isAggProfile ? false : isBalProfile ? false : true) : htfApplyToBuyLabels
eff_htfBuyAlerts   = useProfile ? (isAggProfile ? false : isBalProfile ? false : true) : htfApplyToBuyAlerts
eff_htfSellAlerts  = useProfile ? (isAggProfile ? true  : isBalProfile ? true  : true) : htfApplyToSellAlerts

eff_buyGraceEnabled        = useProfile ? (isSafeProfile ? false : true) : buyHTFGraceEnabled
eff_buyGraceBars           = useProfile ? (isAggProfile ? 14 : isBalProfile ? 9 : 12) : buyHTFGraceBars
eff_buyGraceUseChartEMA200 = useProfile ? (isSafeProfile ? false : true) : buyHTFGraceUseChartEMA200

eff_confirmWindow          = useProfile ? (isAggProfile ? 0 : isBalProfile ? 1 : 2) : confirmWindow
eff_useFlipIfNoIntersect   = useProfile ? true : useFlipIfNoIntersect

eff_hybMinProgressPct      = useProfile ? (isAggProfile ? 22 : isBalProfile ? 30 : 50) : hybMinProgressPct
eff_hybStabilityTicks      = useProfile ? (isAggProfile ? 1  : isBalProfile ? 2  : 3 ) : hybStabilityTicks
eff_hybCooldownMinutes     = useProfile ? (isAggProfile ? 10 : isBalProfile ? 20 : 45) : hybCooldownMinutes

eff_dailyOnce              = useProfile ? (isAggProfile ? false : true) : dailyOnce
eff_cooldownMinutes        = useProfile ? (isAggProfile ? 5 : isBalProfile ? 15 : 30) : cooldownMinutes

useCloseConfirm = enableHybrid ? true : confirmOnClose

// ---
// 2) HELPERS & TEXTS
// ---
fTxt(tr, en) => etiketDil == "TR" ? tr : en
TXT_BUY       = fTxt("K - AL","Buy")
TXT_SELL      = fTxt("K - SAT","Sell")
TXT_LINT      = fTxt("K - BANKO KESİŞME AL","BANKO LONG INTERSECT")
TXT_SINT      = fTxt("K - BANKO KESİŞME SAT","BANKO SHORT INTERSECT")
TXT_HIT_R1    = fTxt("K - Hedef1 Ulaşıldı (Hedef2 için izle)","Target1 Hit (watch Target2)")
TXT_HIT_R2    = fTxt("K - Hedef2 Ulaşıldı (Kar Al / Devam?)","Target2 Hit (TP or Continue?)")
TXT_TRAIL_UP  = fTxt("K - Trail Stop Yükseldi","Trail Stop Up")
TXT_EXIT      = fTxt("K - Poz Çıkış","Exit Position")
TXT_RES       = fTxt("K - Direnç","Res")
TXT_SUP       = fTxt("K - Destek","Sup")

var string PG_CTX_TR = ""
var string PG_CTX_EN = ""
var string pg_ctx_for_unified_buy = ""
var string tech_ctx_for_unified_buy = ""
TXT_MG_BUY    = fTxt("K - MULTI GÜÇLÜ AL","Multi Strong Buy")

fmtMint(x) => str.tostring(x, format.mintick)
f_fmt_time(t)=> str.format("{0,date,yyyy-MM-dd} {0,time,HH:mm}", t)
f_tf_label(tf) => tf == "60" ? "1H" : tf == "120" ? "2H" : tf == "240" ? "4H" : tf == "D" ? "1D" : tf

// Timeframe comparison helper - converts TF string to minutes
f_tf_to_minutes(tf) =>
    tf == "1" ? 1 : tf == "3" ? 3 : tf == "5" ? 5 : tf == "15" ? 15 : tf == "30" ? 30 : tf == "45" ? 45 : tf == "60" ? 60 : tf == "120" ? 120 : tf == "180" ? 180 : tf == "240" ? 240 : tf == "D" ? 1440 : tf == "W" ? 10080 : tf == "M" ? 43200 : 1440

// Check if requested TF is higher than chart TF (for MTF safety)
f_is_higher_tf(requestedTf) =>
    chartMins = f_tf_to_minutes(timeframe.period)
    reqMins = f_tf_to_minutes(requestedTf)
    reqMins > chartMins

// Önceki gün kayıt
var int   lastBullishTime    = na
var float lastBullishPrice   = na
var string lastBullishTextTR = ""
var string lastBullishTextEN = ""
var string lastBullishTF     = ""

// Targets helpers
f_build_buy_targets(_entry, _stUpLine) =>
    float stopCand = na(_stUpLine) ? na : (applyBufferToStop ? _stUpLine * (1 - stopBufferPct/100) : _stUpLine)
    float risk = na(stopCand) ? na : (_entry - stopCand)
    string entryStr = fmtMint(_entry)
    string stopStr  = na(stopCand) ? "NA" : fmtMint(stopCand)
    string riskStr  = na(risk) or risk<=0 ? "NA" : fmtMint(risk)
    string r1Str = "NA", r2Str = "NA"
    if not na(risk) and risk>0
        if r1Multiple>0
            r1Str := fmtMint(_entry + r1Multiple*risk)
        if r2Multiple>0
            r2Str := fmtMint(_entry + r2Multiple*risk)
    [entryStr, stopStr, riskStr, r1Str, r2Str]

f_build_sell_targets(_entry, _stDnLine) =>
    float stopCand = na(_stDnLine) ? na : (applyBufferToStop ? _stDnLine * (1 + stopBufferPct/100) : _stDnLine)
    float risk = na(stopCand) ? na : (stopCand - _entry)
    string entryStr = fmtMint(_entry)
    string stopStr  = na(stopCand) ? "NA" : fmtMint(stopCand)
    string riskStr  = na(risk) or risk<=0 ? "NA" : fmtMint(risk)
    string r1Str = "NA", r2Str = "NA"
    if not na(risk) and risk>0
        if r1Multiple>0
            r1Str := fmtMint(_entry - r1Multiple*risk)
        if r2Multiple>0
            r2Str := fmtMint(_entry - r2Multiple*risk)
    [entryStr, stopStr, riskStr, r1Str, r2Str]

f_target_block_buy(_entry, _stUpLine)=>
    [eS,sS,rS,r1S,r2S] = f_build_buy_targets(_entry, _stUpLine)
    tr = "\nGiriş: " + eS + "\nStop: " + sS + "\nRisk Mesafe: " + rS + (showRTargets ? ("\nHedef1: " + r1S + "   Hedef2: " + r2S) : "")
    en = "\nEntry: " + eS + "\nStop: " + sS + "\nRisk Distance: " + rS + (showRTargets ? ("\nTarget1: " + r1S + "   Target2: " + r2S) : "")
    [tr, en]

f_target_block_sell(_entry, _stDnLine)=>
    [eS,sS,rS,r1S,r2S] = f_build_sell_targets(_entry, _stDnLine)
    tr = "\nGiriş: " + eS + "\nStop: " + sS + "\nRisk Mesafe: " + rS + (showRTargets ? ("\nHedef1: " + r1S + "   Hedef2: " + r2S) : "")
    en = "\nEntry: " + eS + "\nStop: " + sS + "\nRisk Distance: " + rS + (showRTargets ? ("\nTarget1: " + r1S + "   Target2: " + r2S) : "")
    [tr, en]

fEscape(strIn) =>
    s = strIn
    s := str.replace_all(s, "\\", "\\\\")
    s := str.replace_all(s, "\"", "\\\"")
    s := str.replace_all(s, "\n", "\\n")
    s := str.replace_all(s, "\r", "")
    s := str.replace_all(s, "\t", "\\t")
    s := str.replace_all(s, "\u2028", "")
    s := str.replace_all(s, "\u2029", "")
    s

// TR -> ASCII + BÜYÜK
f_tr_ascii_upper(s) =>
    x = s
    x := str.replace_all(x, "ç", "c"),  x := str.replace_all(x, "Ç", "C")
    x := str.replace_all(x, "ğ", "g"),  x := str.replace_all(x, "Ğ", "G")
    x := str.replace_all(x, "ı", "i"),  x := str.replace_all(x, "I", "I")
    x := str.replace_all(x, "i", "i"),  x := str.replace_all(x, "İ", "I")
    x := str.replace_all(x, "ö", "o"),  x := str.replace_all(x, "Ö", "O")
    x := str.replace_all(x, "ş", "s"),  x := str.replace_all(x, "Ş", "S")
    x := str.replace_all(x, "ü", "u"),  x := str.replace_all(x, "Ü", "U")
    str.upper(x)

// DEDUP + Realtime guard
var sentEventIdsArr = array.new_string()
f_sent_contains(_id) =>
    _found = false
    _n = array.size(sentEventIdsArr)
    if _n > 0
        for i = 0 to _n - 1
            if array.get(sentEventIdsArr, i) == _id
                _found := true
    _found
f_rt_ok() => (not alertsRealtimeOnly) or barstate.isrealtime

send_event(id, msg, chatId, freq) =>
    if not f_sent_contains(id) and f_rt_ok()
        msgToSend = (etiketDil=="TR" and tr_ascii_upper) ? f_tr_ascii_upper(msg) : msg
        if useCustomJsonAlert
            alert("{\"chat_id\":\"" + chatId + "\",\"text\":\"" + fEscape(msgToSend) + "\"}", freq)
        else
            alert(msgToSend, freq)
        array.push(sentEventIdsArr, id)
        if array.size(sentEventIdsArr) > 800
            for _i = 0 to 99
                if array.size(sentEventIdsArr) > 700
                    array.shift(sentEventIdsArr)

// Günlük değişim
dCloseNow  = request.security(syminfo.tickerid, "D", close,    barmerge.gaps_off, barmerge.lookahead_off)
dClosePrev = request.security(syminfo.tickerid, "D", close[1], barmerge.gaps_off, barmerge.lookahead_off)
dayChangePct = na(dClosePrev) or dClosePrev==0 ? 0.0 : (dCloseNow - dClosePrev) / dClosePrev * 100.0
buyBlockedByPct = suppressBuyIfDailyUp and dayChangePct >= dailyUpPctThreshold

// ---
// QG — Overextension Filter (Daily lookbacks)
// ---
// Pack daily closes into single request for efficiency
f_buyqg_daily_pack() => [close, close[5], close[20], close[126]]
[buyqg_d_close, buyqg_d_close5, buyqg_d_close20, buyqg_d_close126] =    request.security(syminfo.tickerid, "D", f_buyqg_daily_pack(), barmerge.gaps_off, barmerge.lookahead_off)

// Calculate % changes
buyqg_pct_5d   = na(buyqg_d_close5) or buyqg_d_close5 <= 0 ? 0.0 : (buyqg_d_close - buyqg_d_close5) / buyqg_d_close5 * 100.0
buyqg_pct_20d  = na(buyqg_d_close20) or buyqg_d_close20 <= 0 ? 0.0 : (buyqg_d_close - buyqg_d_close20) / buyqg_d_close20 * 100.0
buyqg_pct_126d = na(buyqg_d_close126) or buyqg_d_close126 <= 0 ? 0.0 : (buyqg_d_close - buyqg_d_close126) / buyqg_d_close126 * 100.0

// Overextension check
buyqg_overext_blocked = buyQG_enable and ((buyqg_pct_5d >= buyQG_overext_5d_pct) or  (buyqg_pct_20d >= buyQG_overext_20d_pct) or  (buyqg_pct_126d >= buyQG_overext_126d_pct))

fChatId(isBuyEvent, isSellEvent) =>
    _def  = telegramChatId
    _buy  = telegramChatIdBuy  != "" ? telegramChatIdBuy  : _def
    _sell = telegramChatIdSell != "" ? telegramChatIdSell : _def
    isBuyEvent ? _buy : isSellEvent ? _sell : _def

f_pg_chat(isBuy) =>
    isBuy ? (pg_chat_buy  != "" ? pg_chat_buy  : telegramChatIdBuy)
          : (pg_chat_sell != "" ? pg_chat_sell : telegramChatIdSell)

// Günlük + cooldown (PG)
f_pg_allow(ev, dayRef, tRef, daily_once, cooldown_minutes, nowTime, currDayStr) =>
    _ok = ev
    if _ok and daily_once
        _ok := dayRef != currDayStr
    if _ok and cooldown_minutes > 0
        _ok := na(tRef) or (nowTime - tRef > cooldown_minutes * 60 * 1000)
    _ok

// Önceki gün notu (Berlin 09:00)
f_is_leap(y) => (y % 4 == 0 and y % 100 != 0) or (y % 400 == 0)
f_dim(y, m) =>
    m==1 or m==3 or m==5 or m==7 or m==8 or m==10 or m==12 ? 31 :  m==4 or m==6 or m==9  or m==11 ? 30 :  (f_is_leap(y) ? 29 : 28)
f_prev_ymd(y, m, d) =>
    py = y, pm = m, pd = d-1
    if pd <= 0
        pm := m-1
        if pm <= 0
            pm := 12
            py := y-1
        pd := f_dim(py, pm)
    [py, pm, pd]
f_prev_threshold_berlin() =>
    y = year(time), m = month(time), d = dayofmonth(time)
    [py, pm, pd] = f_prev_ymd(y, m, d)
    timestamp(prevTz, py, pm, pd, prevSessionHour, prevSessionMinute)

f_record_bullish(_textTR, _textEN, _tfLabel) =>
    [time, close, _textTR, _textEN, _tfLabel]

f_prev_bullish_note() =>
    string s = ""
    if eff_prevAppendEnabled and not na(lastBullishTime)
        thr = f_prev_threshold_berlin()
        if lastBullishTime >= thr
            coreTR = "Dün gelen olumlu sinyal"
            coreEN = "Yesterday's positive signal"
            whatTR = lastBullishTextTR + (lastBullishTF != "" ? " [" + lastBullishTF + "]" : "")
            whatEN = lastBullishTextEN + (lastBullishTF != "" ? " [" + lastBullishTF + "]" : "")
            s := (etiketDil=="TR" ? ("\n" + coreTR + ": " + whatTR + " — " + f_fmt_time(lastBullishTime) + " @ " + fmtMint(lastBullishPrice)) : ("\n" + coreEN + ": " + whatEN + " — " + f_fmt_time(lastBullishTime) + " @ " + fmtMint(lastBullishPrice)))
    s

// ---
// 3) SUPER TREND
// ---
trRange = ta.tr(true)
atrAlt  = ta.sma(trRange, atrLen)
atrBase = altAtrMethod ? atrAlt : ta.atr(atrLen)
midSrc  = hl2
_up = midSrc - atrMult * atrBase
_dn = midSrc + atrMult * atrBase
var float stUp = na
var float stDn = na
upPrev = nz(stUp[1], _up)
dnPrev = nz(stDn[1], _dn)
stUp := close[1] > upPrev ? math.max(_up, upPrev) : _up
stDn := close[1] < dnPrev ? math.min(_dn, dnPrev) : _dn
var int stDir = 1
stDir := stDir == -1 and close > dnPrev ? 1 :
         stDir ==  1 and close < upPrev ? -1 : stDir
flipUp   = stDir == 1 and stDir[1] == -1
flipDown = stDir == -1 and stDir[1] ==  1
buySignal  = flipUp
sellSignal = flipDown

plot(stDir==1?stUp:na,  "ST Up",   color=color.new(color.green,0), linewidth=2, style=plot.style_linebr)
plot(stDir==-1?stDn:na, "ST Down", color=color.new(color.red,0),   linewidth=2, style=plot.style_linebr)
bgcolor(stHighlight ? (stDir==1 ? color.new(color.green,88) : color.new(color.red,88)) : na)

// ---
// 4) SLINGSHOT / EMAs
// ---
emaFast = ta.ema(close, emaFastLen)
emaSlow = ta.ema(close, emaSlowLen)
consUp  = emaFast > emaSlow and close[1] < emaFast[1] and close > emaFast
consDn  = emaFast < emaSlow and close[1] > emaFast[1] and close < emaFast
pullUp  = emaFast > emaSlow and close < emaFast
pullDn  = emaFast < emaSlow and close > emaFast
isCons   = consUp or consDn
isAggBar = pullUp or pullDn
useCons  = showConservative and isCons
useAgg   = showAggressive and isAggBar and not (hideAggressiveWhenConservative and useCons)
barcolor(useCons ? color.aqua : useAgg ? color.yellow : na)
pSlow = plot(showEMAs ? emaSlow : na, "EMA Slow", color=color.new(color.gray,35), linewidth=4, style=plot.style_linebr)
pFast = plot(showEMAs ? emaFast : na, "EMA Fast", color=color.new(color.gray,0),  linewidth=2, style=plot.style_linebr)
fill(pSlow, pFast, color = showEMAs ? color.new(color.silver,70) : na)

// ---
// 4.7) SQZ (LazyBear) — hesaplama
// ---
sqz_source = close
sqz_basis  = ta.sma(sqz_source, sqz_lenBB)
sqz_dev    = sqz_multBB * ta.stdev(sqz_source, sqz_lenBB)
sqz_upperBB = sqz_basis + sqz_dev
sqz_lowerBB = sqz_basis - sqz_dev

sqz_range   = sqz_useTR ? ta.tr(true) : (high - low)
sqz_rangema = ta.sma(sqz_range, sqz_lenKC)
sqz_ma      = ta.sma(sqz_source, sqz_lenKC)
sqz_upperKC = sqz_ma + sqz_rangema * sqz_multKC
sqz_lowerKC = sqz_ma - sqz_rangema * sqz_multKC

sqzOn  = (sqz_lowerBB > sqz_lowerKC) and (sqz_upperBB < sqz_upperKC)
sqzOff = (sqz_lowerBB < sqz_lowerKC) and (sqz_upperBB > sqz_upperKC)
sqzNo  = not sqzOn and not sqzOff

sqz_base = close - math.avg(math.avg(ta.highest(high, sqz_lenKC), ta.lowest(low, sqz_lenKC)), ta.sma(close, sqz_lenKC))
sqz_val  = ta.linreg(sqz_base, sqz_lenKC, 0)

// ---
// 5) HTF EMA200
// ---
f_htf_pack(_slopeLen, _atrLen) =>
    _ema200 = ta.ema(close, 200)
    _slope  = ta.sma(ta.change(_ema200), _slopeLen)
    _atrHtf = ta.atr(_atrLen)
    [close, _ema200, _slope, _atrHtf]

[htfClose, htfEMA200, htfSlope, htfATRhtf] = request.security(syminfo.tickerid, htf_tf,
     f_htf_pack(htfSlopeLen, htfATRlen), barmerge.gaps_off, barmerge.lookahead_off)

htfUpRaw   = htfClose > htfEMA200
htfDnRaw   = htfClose < htfEMA200
htfUp      = enableHTF ? (htfSlopeConfirm ? (htfUpRaw and htfSlope >= 0) : htfUpRaw) : true
htfDn      = enableHTF ? (htfSlopeConfirm ? (htfDnRaw and htfSlope <= 0) : htfDnRaw) : true

softTolVal = htfSoftTolType=="Percent" ? (htfEMA200 * (htfSoftTolPct/100.0)) : (htfATRhtf * htfSoftTolATRx)
htfSoftUp  = enableHTF ? (htfSlopeConfirm ? (htfClose >= (htfEMA200 - softTolVal) and htfSlope >= -htfSoftSlopeEps) : (htfClose >= (htfEMA200 - softTolVal))) : true
htfSoftDn  = enableHTF ? (htfSlopeConfirm ? (htfClose <= (htfEMA200 + softTolVal) and htfSlope <=  htfSoftSlopeEps) : (htfClose <= (htfEMA200 + softTolVal))) : true

modePassLongLabels  = htfModeLabels=="Off"  ? true : htfModeLabels=="Soft"  ? htfSoftUp : htfUp
modePassShortLabels = htfModeLabels=="Off"  ? true : htfModeLabels=="Soft"  ? htfSoftDn : htfDn
modePassLongAlerts  = htfModeAlerts=="Off"  ? true : htfModeAlerts=="Soft"  ? htfSoftUp : htfUp
modePassShortAlerts = htfModeAlerts=="Off"  ? true : htfModeAlerts=="Soft"  ? htfSoftDn : htfDn

plot(showHTFLine ? htfEMA200 : na, title="HTF EMA200", color=color.new(color.blue,0), linewidth=2, style=plot.style_linebr)

chartEMA200 = ta.ema(close, 200)
var int lastSellFlipBar = na
if sellSignal
    lastSellFlipBar := bar_index
barsSinceSellFlip = na(lastSellFlipBar) ? 1000000 : bar_index - lastSellFlipBar

var int lastSellFlipBarForEMA = na
if sellSignal
    lastSellFlipBarForEMA := bar_index
barsSinceSellFlipForEMA = na(lastSellFlipBarForEMA) ? 1000000 : bar_index - lastSellFlipBarForEMA

buyGrace = (eff_buyGraceEnabled) and ((flipUp and emaFast > emaSlow and barsSinceSellFlip <= eff_buyGraceBars)  or (eff_buyGraceUseChartEMA200 and close > chartEMA200 and barsSinceSellFlipForEMA <= buyHTFGraceChartBars))

htfOkLongEntry  = (not enableHTF) or (not eff_htfBuyEntries)  or htfUp or buyGrace
htfOkShortEntry = (not enableHTF) or (not htfApplyToSellEntries) or htfDn
htfOkLongLabel  = (not enableHTF) or (not eff_htfBuyLabels)  or modePassLongLabels or buyGrace
htfOkShortLabel = (not enableHTF) or (not htfApplyToSellLabels) or modePassShortLabels
htfOkLongAlert  = (not enableHTF) or (not eff_htfBuyAlerts)  or modePassLongAlerts or buyGrace
htfOkShortAlert = (not enableHTF) or (not eff_htfSellAlerts) or modePassShortAlerts

// QG — MTF Function
f_buyqg_check() =>
    _s = 0
    if buyQG_score_trend
        _s := (close > ta.ema(close, 50) or htfUp) ? _s + 1 : _s
    if buyQG_score_adx
        _l = 14
        _a = ta.rma(ta.tr(true), _l)
        _u = ta.change(high)
        _d = -ta.change(low)
        _p = na(_u) ? na : (_u > _d and _u > 0 ? _u : 0)
        _m = na(_d) ? na : (_d > _u and _d > 0 ? _d : 0)
        _adx = ta.rma(100 * math.abs(100 * ta.rma(_p, _l) / _a - 100 * ta.rma(_m, _l) / _a) / (100 * ta.rma(_p, _l) / _a + 100 * ta.rma(_m, _l) / _a), _l)
        _s := _adx >= buyQG_adx_threshold ? _s + 1 : _s
    if buyQG_score_cmf
        _mf = ((close - low) - (high - close)) / (high - low) * volume
        _s := (ta.sma(_mf, 20) / ta.sma(volume, 20)) >= buyQG_cmf_threshold ? _s + 1 : _s
    if buyQG_score_breakout
        _s := high > ta.highest(high, buyQG_donchian_len)[1] ? _s + 1 : _s
    (not buyQG_enable) or ((_s >= buyQG_min_score) and ((not buyQG_breakout_req) or high > ta.highest(high, buyQG_donchian_len)[1]) and not buyqg_overext_blocked)

// QG — Chart TF
// Donchian Channel
buyqg_donch_high = ta.highest(high, buyQG_donchian_len)
buyqg_donch_break = high > buyqg_donch_high[1]

// Pivot resistance break (reuse existing pivot detection)
var int buyqg_last_breakout_bar = na
if buyqg_donch_break
    buyqg_last_breakout_bar := bar_index
buyqg_bars_since_break = na(buyqg_last_breakout_bar) ? 999999 : (bar_index - buyqg_last_breakout_bar)
buyqg_in_retest_window = buyqg_bars_since_break <= buyQG_retest_window

// ---
// QG — Scoring Model
// ---
// EMA50 for trend alignment
buyqg_ema50 = ta.ema(close, 50)

buyqg_score = 0

// Score 1: Trend alignment (close above EMA50 or HTF EMA200 up)
if buyQG_score_trend
    buyqg_trend_ok = (close > buyqg_ema50) or htfUp
    buyqg_score := buyqg_trend_ok ? buyqg_score + 1 : buyqg_score

// Score 2: ADX strength
if buyQG_score_adx
    // Proper ADX calculation
    buyqg_adx_len = 14
    buyqg_tr = ta.tr(true)
    buyqg_atr = ta.rma(buyqg_tr, buyqg_adx_len)
    buyqg_up = ta.change(high)
    buyqg_down = -ta.change(low)
    buyqg_plusDM = na(buyqg_up) ? na : (buyqg_up > buyqg_down and buyqg_up > 0 ? buyqg_up : 0)
    buyqg_minusDM = na(buyqg_down) ? na : (buyqg_down > buyqg_up and buyqg_down > 0 ? buyqg_down : 0)
    buyqg_plusDI = 100 * ta.rma(buyqg_plusDM, buyqg_adx_len) / buyqg_atr
    buyqg_minusDI = 100 * ta.rma(buyqg_minusDM, buyqg_adx_len) / buyqg_atr
    buyqg_dx = 100 * math.abs(buyqg_plusDI - buyqg_minusDI) / (buyqg_plusDI + buyqg_minusDI)
    buyqg_adx_val = ta.rma(buyqg_dx, buyqg_adx_len)
    buyqg_adx_ok = buyqg_adx_val >= buyQG_adx_threshold
    buyqg_score := buyqg_adx_ok ? buyqg_score + 1 : buyqg_score

// Score 3: CMF (reuse pg_cmf if available)
if buyQG_score_cmf
    buyqg_cmf_len = 20
    buyqg_mfm = ((close - low) - (high - close)) / (high - low)
    buyqg_mfv = buyqg_mfm * volume
    buyqg_cmf = ta.sma(buyqg_mfv, buyqg_cmf_len) / ta.sma(volume, buyqg_cmf_len)
    buyqg_cmf_ok = buyqg_cmf >= buyQG_cmf_threshold
    buyqg_score := buyqg_cmf_ok ? buyqg_score + 1 : buyqg_score

// Score 4: Breakout or retest
if buyQG_score_breakout
    buyqg_break_ok = buyqg_donch_break or buyqg_in_retest_window
    buyqg_score := buyqg_break_ok ? buyqg_score + 1 : buyqg_score

// Final quality check
buyqg_breakout_pass = (not buyQG_breakout_req) or buyqg_donch_break or buyqg_in_retest_window
buyqg_score_pass = buyqg_score >= buyQG_min_score
buyqg_quality_pass = (not buyQG_enable) or (buyqg_score_pass and buyqg_breakout_pass and not buyqg_overext_blocked)

// ---
// SELL QG - Overext Filter
// Calc neg % change
sellqg_pct_5d   = na(buyqg_d_close5) or buyqg_d_close5 <= 0 ? 0.0 : -(buyqg_d_close - buyqg_d_close5) / buyqg_d_close5 * 100.0
sellqg_pct_20d  = na(buyqg_d_close20) or buyqg_d_close20 <= 0 ? 0.0 : -(buyqg_d_close - buyqg_d_close20) / buyqg_d_close20 * 100.0
sellqg_pct_126d = na(buyqg_d_close126) or buyqg_d_close126 <= 0 ? 0.0 : -(buyqg_d_close - buyqg_d_close126) / buyqg_d_close126 * 100.0

// Overext check
sellqg_ox_block = sellQG_enable and ((sellqg_pct_5d >= sellQG_overext_5d_pct) or   (sellqg_pct_20d >= sellQG_overext_20d_pct) or  (sellqg_pct_126d >= sellQG_overext_126d_pct))

// SELL QG - Chart TF
sellqg_donch_low = ta.lowest(low, sellQG_donchian_len)
sellqg_donch_break = low < sellqg_donch_low[1]

// SELL QG - Score
sellqg_ema50 = ta.ema(close, 50)
sellqg_score = 0

// Score 1: Trend (close<EMA50 or HTF down)
if sellQG_score_trend
    sellqg_trend_ok = (close < sellqg_ema50) or htfDn
    sellqg_score := sellqg_trend_ok ? sellqg_score + 1 : sellqg_score

// Score 2: ADX (same calc as BUY)
if sellQG_score_adx
    sellqg_adx_len = 14
    sellqg_tr = ta.tr(true)
    sellqg_atr = ta.rma(sellqg_tr, sellqg_adx_len)
    sellqg_up = ta.change(high)
    sellqg_down = -ta.change(low)
    sellqg_plusDM = na(sellqg_up) ? na : (sellqg_up > sellqg_down and sellqg_up > 0 ? sellqg_up : 0)
    sellqg_minusDM = na(sellqg_down) ? na : (sellqg_down > sellqg_up and sellqg_down > 0 ? sellqg_down : 0)
    sellqg_plusDI = 100 * ta.rma(sellqg_plusDM, sellqg_adx_len) / sellqg_atr
    sellqg_minusDI = 100 * ta.rma(sellqg_minusDM, sellqg_adx_len) / sellqg_atr
    sellqg_dx = 100 * math.abs(sellqg_plusDI - sellqg_minusDI) / (sellqg_plusDI + sellqg_minusDI)
    sellqg_adx_val = ta.rma(sellqg_dx, sellqg_adx_len)
    sellqg_adx_ok = sellqg_adx_val >= sellQG_adx_threshold
    sellqg_score := sellqg_adx_ok ? sellqg_score + 1 : sellqg_score

// Score 3: CMF (neg = sell)
if sellQG_score_cmf
    sellqg_cmf_len = 20
    sellqg_mfm = ((close - low) - (high - close)) / (high - low)
    sellqg_mfv = sellqg_mfm * volume
    sellqg_cmf = ta.sma(sellqg_mfv, sellqg_cmf_len) / ta.sma(volume, sellqg_cmf_len)
    sellqg_cmf_ok = sellqg_cmf <= sellQG_cmf_threshold
    sellqg_score := sellqg_cmf_ok ? sellqg_score + 1 : sellqg_score

// Score 4: Breakdown
if sellQG_score_breakout
    sellqg_break_ok = sellqg_donch_break
    sellqg_score := sellqg_break_ok ? sellqg_score + 1 : sellqg_score

// Final QG check
sellqg_breakout_pass = (not sellQG_breakout_req) or sellqg_donch_break
sellqg_score_pass = sellqg_score >= sellQG_min_score
sellqg_qpass = (not sellQG_enable) or (sellqg_score_pass and sellqg_breakout_pass and not sellqg_ox_block)

// ---
// 6) INTERSECTION + Quick Tech Fallback
// ---
var int lastFlipBar = na
var int lastFlipDir = 0
if buySignal
    lastFlipBar := bar_index
    lastFlipDir := 1
if sellSignal
    lastFlipBar := bar_index
    lastFlipDir := -1

barsSinceFlip = na(lastFlipBar) ? na : bar_index - lastFlipBar
inWindow = na(barsSinceFlip) ? false : (eff_confirmWindow==0 ? barsSinceFlip==0 : barsSinceFlip <= eff_confirmWindow)
longIntersect_raw  = enableIntersection and lastFlipDir==1  and inWindow and consUp
shortIntersect_raw = enableIntersection and lastFlipDir==-1 and inWindow and consDn

longIntersectEntry  = longIntersect_raw  and htfOkLongEntry
shortIntersectEntry = shortIntersect_raw and htfOkShortEntry
longIntersectLabel  = longIntersect_raw  and htfOkLongLabel
shortIntersectLabel = shortIntersect_raw and htfOkShortLabel
longIntersectAlert  = longIntersect_raw  and htfOkLongAlert
shortIntersectAlert = shortIntersect_raw and htfOkShortAlert

f_quick_tech_ctx() =>
    htfDirStr = etiketDil=="TR" ? (htfUp ? "Yukarı" : htfDn ? "Aşağı" : "Yatay") : (htfUp ? "Up"    : htfDn ? "Down"  : "Flat")
    slopeStr = ""
    if htfSlopeConfirm
        slopeLabel = etiketDil=="TR" ? " (Eğim " : " (Slope "
        slopeSign  = htfSlope >= 0 ? ">=0" : "<0"
        slopeStr   := slopeLabel + slopeSign + ")"
    t = "HTF:" + htfDirStr + slopeStr + " [" + htfModeAlerts + "]"
    if consUp
        t := t + "\n" + (etiketDil=="TR" ? "SS: Con Up" : "SS: Con Up")
    else if consDn
        t := t + "\n" + (etiketDil=="TR" ? "SS: Con Down" : "SS: Con Down")
    t

// ---
// 7) POSITION STATE + Çizimler
// ---
var float lastEntryPrice = na
var float initialStop    = na
var float liveStop       = na
var int   lastEntryDir   = 0
var int   lastEntryBar   = na
var int   entryId        = 0
var line  lineEntry      = na
var line  lineStop       = na
var line  lineR1         = na
var line  lineR2         = na
var line  lineStruct     = na
var label labelR1        = na
var label labelR2        = na
var label labelStruct    = na
var box   riskBox        = na
var bool  r1HitForEntry  = false
var bool  r2HitForEntry  = false

entryConfirmed(c)=> c and (not useCloseConfirm or barstate.isconfirmed)

useFlipLongEntry  = eff_useFlipIfNoIntersect and buySignal  and not longIntersectEntry
useFlipShortEntry = eff_useFlipIfNoIntersect and sellSignal and not shortIntersectEntry
newLongEntry  = (longIntersectEntry or useFlipLongEntry)  and htfOkLongEntry
newShortEntry = (shortIntersectEntry or useFlipShortEntry) and htfOkShortEntry

// SQZ kapısı (Filter)
sqz_long_ok_strict = sqzOff and (sqz_val > 0)
sqz_short_ok_strict= sqzOff and (sqz_val < 0)
sqz_long_ok_soft   = (not sqzOn) and (sqz_val > 0)
sqz_short_ok_soft  = (not sqzOn) and (sqz_val < 0)

_useLongSQZ  = sqz_filter_mode=="Strict" ? sqz_long_ok_strict  : sqz_long_ok_soft
_useShortSQZ = sqz_filter_mode=="Strict" ? sqz_short_ok_strict : sqz_short_ok_soft

sqzGateLong  = (not sqz_enable) or (sqz_mode!="Filter") or _useLongSQZ
sqzGateShort = (not sqz_enable) or (sqz_mode!="Filter") or _useShortSQZ

longIntersectEntry  := longIntersectEntry  and sqzGateLong
shortIntersectEntry := shortIntersectEntry and sqzGateShort
newLongEntry        := newLongEntry        and sqzGateLong
newShortEntry       := newShortEntry       and sqzGateShort

// Apply QG to BANKO signals (optional)
if buyQG_enable and buyQG_apply_banko
    longIntersectEntry  := longIntersectEntry  and buyqg_quality_pass
    longIntersectLabel  := longIntersectLabel  and buyqg_quality_pass
    longIntersectAlert  := longIntersectAlert  and buyqg_quality_pass
    newLongEntry        := newLongEntry        and buyqg_quality_pass

f_delete_all() =>
    if not na(lineEntry)
        line.delete(lineEntry)
    if not na(lineStop)
        line.delete(lineStop)
    if not na(lineR1)
        line.delete(lineR1)
    if not na(lineR2)
        line.delete(lineR2)
    if not na(lineStruct)
        line.delete(lineStruct)
    if not na(labelR1)
        label.delete(labelR1)
    if not na(labelR2)
        label.delete(labelR2)
    if not na(riskBox)
        box.delete(riskBox)

if entryConfirmed(newLongEntry)
    f_delete_all()
    lastEntryPrice := close
    baseStop = stUp
    if applyBufferToStop
        baseStop *= (1 - stopBufferPct/100)
    initialStop := baseStop
    liveStop    := baseStop
    lastEntryDir := 1
    lastEntryBar := bar_index
    r1HitForEntry := false
    r2HitForEntry := false
    entryId += 1

if entryConfirmed(newShortEntry)
    f_delete_all()
    lastEntryPrice := close
    baseStop = stDn
    if applyBufferToStop
        baseStop *= (1 + stopBufferPct/100)
    initialStop := baseStop
    liveStop    := baseStop
    lastEntryDir := -1
    lastEntryBar := bar_index
    r1HitForEntry := false
    r2HitForEntry := false
    entryId += 1

havePosition = not na(lastEntryPrice) and lastEntryDir!=0
baseStopForTargets = havePosition ? (trailStopEnabled and not na(liveStop) ? liveStop : initialStop) : na
riskDist = havePosition and not na(baseStopForTargets) ? (lastEntryDir==1 ? (lastEntryPrice - baseStopForTargets) : (baseStopForTargets - lastEntryPrice)) : na

if havePosition and minRiskTicks>0 and riskDist < syminfo.mintick * minRiskTicks
    f_delete_all()
    lastEntryPrice := na
    initialStop := na
    liveStop := na
    lastEntryDir := 0
    lastEntryBar := na
    r1HitForEntry := false
    r2HitForEntry := false

trailMoved = false
if havePosition and trailStopEnabled and riskDist>0
    if lastEntryDir==1
        cand = stUp
        if applyBufferToStop
            cand *= (1 - stopBufferPct/100)
        if cand > liveStop
            liveStop := cand
            trailMoved := true
    else
        cand = stDn
        if applyBufferToStop
            cand *= (1 + stopBufferPct/100)
        if cand < liveStop
            liveStop := cand
            trailMoved := true

if havePosition and riskDist>0
    if na(lineEntry)
        lineEntry := line.new(lastEntryBar, lastEntryPrice, bar_index+60, lastEntryPrice, color=entryLineColor, width=2)
    if na(lineStop)
        lineStop := line.new(lastEntryBar, liveStop, bar_index+60, liveStop, color=stopLineColorTargets, style=line.style_dashed)
    line.set_x2(lineEntry, bar_index+60)
    line.set_x2(lineStop, bar_index+60)
    line.set_y1(lineStop, liveStop)
    line.set_y2(lineStop, liveStop)

    r1Price = lastEntryDir==1 ? lastEntryPrice + r1Multiple*riskDist : lastEntryPrice - r1Multiple*riskDist
    r2Price = lastEntryDir==1 ? lastEntryPrice + r2Multiple*riskDist : lastEntryPrice - r2Multiple*riskDist

    if showRTargets
        if na(lineR1) and r1Multiple>0
            lineR1 := line.new(lastEntryBar, r1Price, bar_index+60, r1Price, color=r1Color, style=line.style_dotted)
        if na(lineR2) and r2Multiple>0
            lineR2 := line.new(lastEntryBar, r2Price, bar_index+60, r2Price, color=r2Color, style=line.style_dotted)
        if not na(lineR1)
            line.set_x2(lineR1, bar_index+60)
            line.set_y1(lineR1, r1Price)
            line.set_y2(lineR1, r1Price)
        if not na(lineR2)
            line.set_x2(lineR2, bar_index+60)
            line.set_y1(lineR2, r2Price)
            line.set_y2(lineR2, r2Price)

    if showRTargets and showRTargetLabels
        if na(labelR1) and r1Multiple>0
            labelR1 := label.new(bar_index, r1Price, "Hedef1: " + fmtMint(r1Price), style=label.style_label_left, color=color.new(r1Color,0), textcolor=color.white, size=size.tiny)
        if na(labelR2) and r2Multiple>0
            labelR2 := label.new(bar_index, r2Price, "Hedef2: " + fmtMint(r2Price), style=label.style_label_left, color=color.new(r2Color,0), textcolor=color.white, size=size.tiny)
        if not na(labelR1)
            label.set_x(labelR1, bar_index)
            label.set_y(labelR1, r1Price)
            label.set_text(labelR1, "Hedef1: " + fmtMint(r1Price))
        if not na(labelR2)
            label.set_x(labelR2, bar_index)
            label.set_y(labelR2, r2Price)
            label.set_text(labelR2, "Hedef2: " + fmtMint(r2Price))

// R hedefleri
hitR1 = false
hitR2 = false
if havePosition and showRTargets and riskDist>0
    r1Val = not na(lineR1) ? line.get_y1(lineR1) : na
    r2Val = not na(lineR2) ? line.get_y1(lineR2) : na
    if lastEntryDir==1
        if not r1HitForEntry and not na(r1Val) and high >= r1Val
            hitR1 := true
            r1HitForEntry := true
        if not r2HitForEntry and not na(r2Val) and high >= r2Val
            hitR2 := true
            r2HitForEntry := true
    else
        if not r1HitForEntry and not na(r1Val) and low <= r1Val
            hitR1 := true
            r1HitForEntry := true
        if not r2HitForEntry and not na(r2Val) and low <= r2Val
            hitR2 := true
            r2HitForEntry := true

exitShortIntUsed = htfApplyToExits ? shortIntersectEntry : shortIntersect_raw
exitLongIntUsed  = htfApplyToExits ? longIntersectEntry  : longIntersect_raw
exitLong  = havePosition and lastEntryDir==1  and (exitShortIntUsed or (eff_useFlipIfNoIntersect and sellSignal and entryConfirmed(true)))
exitShort = havePosition and lastEntryDir==-1 and (exitLongIntUsed  or (eff_useFlipIfNoIntersect and buySignal  and entryConfirmed(true)))
if exitLong or exitShort
    f_delete_all()
    lastEntryPrice := na
    initialStop := na
    liveStop := na
    lastEntryDir := 0

// ---
// 7.5) Pivot Destek/Direnç
// ---
var rsResLines  = array.new_line()
var rsResLabels = array.new_label()
var rsSupLines  = array.new_line()
var rsSupLabels = array.new_label()

f_push_line(_arrL, _arrLab, _l, _lab, _max)=>
    array.push(_arrL, _l)
    array.push(_arrLab, _lab)
    while array.size(_arrL) > _max
        oldL = array.shift(_arrL)
        if not na(oldL)
            line.delete(oldL)
    while array.size(_arrLab) > _max
        oldLb = array.shift(_arrLab)
        if not na(oldLb)
            label.delete(oldLb)

// Pivot High (Direnç)
pivotHighVal = ta.pivothigh(high, pivotLeft, pivotRight)
if showPivotRes and not na(pivotHighVal)
    x1 = bar_index - pivotRight
    y1 = pivotHighVal
    x2 = bar_index + pivotExtendBars
    phLine = line.new(x1, y1, x2, y1, extend=extend.none, color=pivotResColor, width=1, style=line.style_solid)
    label lb = na
    if showPivotLabels
        lb := label.new(x1, y1, TXT_RES, style=label.style_label_left, textcolor=color.white, color=color.new(pivotResColor, 0), size=size.tiny)
    f_push_line(rsResLines, rsResLabels, phLine, lb, maxPivotLevels)

// Pivot Low (Destek)
pivotLowVal = ta.pivotlow(low, pivotLeft, pivotRight)
if showPivotSup and not na(pivotLowVal)
    x1s = bar_index - pivotRight
    y1s = pivotLowVal
    x2s = bar_index + pivotExtendBars
    plLine = line.new(x1s, y1s, x2s, y1s, extend=extend.none, color=pivotSupColor, width=1, style=line.style_solid)
    label lbs = na
    if showPivotLabels
        lbs := label.new(x1s, y1s, TXT_SUP, style=label.style_label_left, textcolor=color.white, color=color.new(pivotSupColor, 0), size=size.tiny)
    f_push_line(rsSupLines, rsSupLabels, plLine, lbs, maxPivotLevels)

// ---
// 8) MODULE-2 (MesutTrend + MG) — 4H + 1D
// ---
f_at_mt(_ap,_coeff,_useRSI,_useOriginalATR)=>
    atrUsed = _useOriginalATR ? ta.sma(ta.tr(true),_ap) : ta.atr(_ap)
    upT=low-atrUsed*_coeff
    dnT=high+atrUsed*_coeff
    hasVol = not na(volume) and volume!=0
    cond = (_useRSI or not hasVol) ? ta.rsi(close,_ap)>=50 : ta.mfi(hlc3,_ap)>=50
    var float AT=na
    AT := cond ? math.max(upT,nz(AT[1])) : math.min(dnT,nz(AT[1]))
    buyK = ta.crossover(AT,AT[2])
    sellK= ta.crossunder(AT,AT[2])
    candleBuy     = ta.crossover(low[1], AT[1])
    candleSell    = ta.crossunder(high[1],AT[1])
    _qg_pass = f_buyqg_check()  // Calculate quality gate on this TF
    [AT,AT[2],AT[3],buyK[1],sellK[1],buyK,candleBuy,candleSell,close,atrUsed,_qg_pass]

// 4H “new bar” bayrağı
mt_isNew4h = eff_includeModule2 ? request.security(syminfo.tickerid, "240", barstate.isconfirmed, barmerge.gaps_off, barmerge.lookahead_off) : false

// 4H MT kalıcı değişkenler
var float mt_AT4       = na
var float mt_AT4_2     = na
var float mt_AT4_3     = na
var bool  mt_confirmedBuy4  = na
var bool  mt_confirmedSell4 = na
var bool  mt_earlyBuy4      = na
var bool  mt_candleBuy4     = na
var bool  mt_candleSell4    = na
var float mt_c4        = na
var float mt_atr4h     = na
var bool  mt_qg_pass4h = na

if eff_includeModule2
    [__AT4, __AT4_2, __AT4_3, __cBuy4, __cSell4, __eBuy4, __candBuy4, __candSell4, __c4, __atr4h, __qg4h] =       request.security(syminfo.tickerid, "240", f_at_mt(mt_AP, mt_coeff, mt_useRSI_noVolume, mt_useOriginalATR), barmerge.gaps_off, barmerge.lookahead_off)
    mt_AT4            := __AT4
    mt_AT4_2          := __AT4_2
    mt_AT4_3          := __AT4_3
    mt_confirmedBuy4  := __cBuy4
    mt_confirmedSell4 := __cSell4
    mt_earlyBuy4      := __eBuy4
    mt_candleBuy4     := __candBuy4
    mt_candleSell4    := __candSell4
    mt_c4             := __c4
    mt_atr4h          := __atr4h
    mt_qg_pass4h      := __qg4h

// 4H pulse bayrakları
mt_buyPulseConf      = eff_includeModule2 and mt_isNew4h and nz(mt_confirmedBuy4,  false)
mt_sellPulseConf     = eff_includeModule2 and mt_isNew4h and nz(mt_confirmedSell4, false)
mt_buyPulseEarly     = eff_includeModule2 and ((mt_isNew4h and mt_earlyBuy4) ? false : mt_earlyBuy4)
mt_buyPulseCandle    = eff_includeModule2 and mt_isNew4h and (mt_includeCandleCloseBuy and nz(mt_candleBuy4,  false))
mt_sellPulseCandle   = eff_includeModule2 and mt_isNew4h and nz(mt_candleSell4, false)
mt_buyPulseCombined  = eff_includeModule2 and mt_isNew4h and (nz(mt_confirmedBuy4,  false) and nz(mt_candleBuy4,  false))
mt_sellPulseCombined = eff_includeModule2 and mt_isNew4h and (nz(mt_confirmedSell4, false) and nz(mt_candleSell4, false))

// 4H Cooldown ve izinler
mt_cooldown_ms = mt_cooldown_minutes * 60 * 1000
var int mt_lastBuyTime  = na
var int mt_lastSellTime = na
mt_cooldownOkBuy()  => mt_cooldown_minutes==0 or na(mt_lastBuyTime)  or time - mt_lastBuyTime  > mt_cooldown_ms
mt_cooldownOkSell() => mt_cooldown_minutes==0 or na(mt_lastSellTime) or time - mt_lastSellTime > mt_cooldown_ms

mt_buyAllowedConf      = eff_includeModule2 and mt_buyPulseConf      and mt_cooldownOkBuy()
mt_buyAllowedCombined  = eff_includeModule2 and mt_buyPulseCombined  and mt_cooldownOkBuy()
mt_sellAllowedConf     = eff_includeModule2 and mt_sellPulseConf     and mt_cooldownOkSell() and mt_enableSellAlerts
mt_sellAllowedCombined = eff_includeModule2 and mt_sellPulseCombined and mt_cooldownOkSell()
mt_buyAllowedEarly     = eff_includeModule2 and mt_buyPulseEarly
mt_buyAllowedCandle    = eff_includeModule2 and mt_buyPulseCandle

// Apply QG to M2 4H signals using 4H quality check
mt_buyAllowedConf      := mt_buyAllowedConf      and ((not buyQG_enable) or (not buyQG_apply_m2) or mt_qg_pass4h)
mt_buyAllowedCombined  := mt_buyAllowedCombined  and ((not buyQG_enable) or (not buyQG_apply_m2) or mt_qg_pass4h)
mt_buyAllowedEarly     := mt_buyAllowedEarly     and ((not buyQG_enable) or (not buyQG_apply_m2) or mt_qg_pass4h)
mt_buyAllowedCandle    := mt_buyAllowedCandle    and ((not buyQG_enable) or (not buyQG_apply_m2) or mt_qg_pass4h)

if mt_buyAllowedConf or mt_buyAllowedCombined
    mt_lastBuyTime := time
if mt_sellAllowedConf or mt_sellAllowedCombined
    mt_lastSellTime := time

// 1D “new bar” bayrağı
mt_isNew1d = eff_includeModule2 ? request.security(syminfo.tickerid, "D", barstate.isconfirmed, barmerge.gaps_off, barmerge.lookahead_off) : false

// 1D MT kalıcı değişkenler
var float mt_AT1D       = na
var float mt_AT1D_2     = na
var float mt_AT1D_3     = na
var bool  mt_confirmedBuy1D  = na
var bool  mt_confirmedSell1D = na
var bool  mt_earlyBuy1D      = na
var bool  mt_candleBuy1D     = na
var bool  mt_candleSell1D    = na
var float mt_c1D        = na
var float mt_atr1D      = na
var bool  mt_qg_pass1d  = na

if eff_includeModule2
    [__ATD, __ATD_2, __ATD_3, __cBuyD, __cSellD, __eBuyD, __candBuyD, __candSellD, __cD, __atrD, __qg1d] =     request.security(syminfo.tickerid, "D", f_at_mt(mt_AP, mt_coeff, mt_useRSI_noVolume, mt_useOriginalATR), barmerge.gaps_off, barmerge.lookahead_off)
    mt_AT1D            := __ATD
    mt_AT1D_2          := __ATD_2
    mt_AT1D_3          := __ATD_3
    mt_confirmedBuy1D  := __cBuyD
    mt_confirmedSell1D := __cSellD
    mt_earlyBuy1D      := __eBuyD
    mt_candleBuy1D     := __candBuyD
    mt_candleSell1D    := __candSellD
    mt_c1D             := __cD
    mt_atr1D           := __atrD
    mt_qg_pass1d       := __qg1d

// 1D pulse bayrakları
mt_buyPulseConf1D      = eff_includeModule2 and mt_isNew1d and nz(mt_confirmedBuy1D,  false)
mt_sellPulseConf1D     = eff_includeModule2 and mt_isNew1d and nz(mt_confirmedSell1D, false)
mt_buyPulseEarly1D     = eff_includeModule2 and ((mt_isNew1d and mt_earlyBuy1D) ? false : mt_earlyBuy1D)
mt_buyPulseCandle1D    = eff_includeModule2 and mt_isNew1d and (mt_includeCandleCloseBuy and nz(mt_candleBuy1D,  false))
mt_sellPulseCandle1D   = eff_includeModule2 and mt_isNew1d and nz(mt_candleSell1D, false)
mt_buyPulseCombined1D  = eff_includeModule2 and mt_isNew1d and (nz(mt_confirmedBuy1D,  false) and nz(mt_candleBuy1D,  false))
mt_sellPulseCombined1D = eff_includeModule2 and mt_isNew1d and (nz(mt_confirmedSell1D, false) and nz(mt_candleSell1D, false))

// 1D Cooldown ve izinler
var int mt_lastBuyTime1D  = na
var int mt_lastSellTime1D = na
mt_cooldownOkBuy1D()  => mt_cooldown_minutes==0 or na(mt_lastBuyTime1D)  or time - mt_lastBuyTime1D  > mt_cooldown_ms
mt_cooldownOkSell1D() => mt_cooldown_minutes==0 or na(mt_lastSellTime1D) or time - mt_lastSellTime1D > mt_cooldown_ms

mt_buyAllowedConf1D      = eff_includeModule2 and mt_buyPulseConf1D      and mt_cooldownOkBuy1D()
mt_buyAllowedCombined1D  = eff_includeModule2 and mt_buyPulseCombined1D  and mt_cooldownOkBuy1D()
mt_sellAllowedConf1D     = eff_includeModule2 and mt_sellPulseConf1D     and mt_cooldownOkSell1D() and mt_enableSellAlerts
mt_sellAllowedCombined1D = eff_includeModule2 and mt_sellPulseCombined1D and mt_cooldownOkSell1D()
mt_buyAllowedEarly1D     = eff_includeModule2 and mt_buyPulseEarly1D
mt_buyAllowedCandle1D    = eff_includeModule2 and mt_buyPulseCandle1D

// Apply QG to M2 1D signals using 1D quality check
mt_buyAllowedConf1D      := mt_buyAllowedConf1D      and ((not buyQG_enable) or (not buyQG_apply_m2) or mt_qg_pass1d)
mt_buyAllowedCombined1D  := mt_buyAllowedCombined1D  and ((not buyQG_enable) or (not buyQG_apply_m2) or mt_qg_pass1d)
mt_buyAllowedEarly1D     := mt_buyAllowedEarly1D     and ((not buyQG_enable) or (not buyQG_apply_m2) or mt_qg_pass1d)
mt_buyAllowedCandle1D    := mt_buyAllowedCandle1D    and ((not buyQG_enable) or (not buyQG_apply_m2) or mt_qg_pass1d)

if mt_buyAllowedConf1D or mt_buyAllowedCombined1D
    mt_lastBuyTime1D := time
if mt_sellAllowedConf1D or mt_sellAllowedCombined1D
    mt_lastSellTime1D := time

// MG Chart
f_mg_macd_pack(_fast, _slow, _signal) =>
    _fma  = ta.ema(close, _fast)
    _sma  = ta.ema(close, _slow)
    _macd = _fma - _sma
    _sig  = ta.sma(_macd, _signal)
    _hist = _macd - _sig
    [_macd, _sig, _hist]

[mtf_macd, mtf_signal, mtf_hist] =  request.security(syminfo.tickerid, mg_macdTF, f_mg_macd_pack(mg_periodMACD, mg_slowMACD, mg_signalMACD), barmerge.gaps_off, barmerge.lookahead_off)

ma_src=close
ma_actual =
     mg_maType=="SMA"? ta.sma(ma_src, mg_maLen) :
     mg_maType=="EMA"? ta.ema(ma_src, mg_maLen) :
     mg_maType=="WMA"? ta.wma(ma_src, mg_maLen) :
     mg_maType=="HullMA"? ta.wma(2*ta.wma(ma_src, math.round(mg_maLen/2)) - ta.wma(ma_src, mg_maLen), math.round(math.sqrt(mg_maLen))) :
     mg_maType=="VWMA"? ta.vwma(ma_src, mg_maLen) :
     mg_maType=="RMA"? ta.rma(ma_src, mg_maLen) :
     mg_maType=="TEMA"? 3*(ta.ema(ma_src, mg_maLen)-ta.ema(ta.ema(ma_src, mg_maLen), mg_maLen))+ta.ema(ta.ema(ta.ema(ma_src, mg_maLen), mg_maLen), mg_maLen) :
     mg_maType=="TilsonT3"? ta.ema(ma_src, mg_maLen)*0.7 - ta.ema(ta.ema(ma_src, mg_maLen), mg_maLen)*0.3 :
     ta.ema(ma_src, mg_maLen)

mtf_ma  = request.security(syminfo.tickerid, mg_maTF, ma_actual, barmerge.gaps_off, barmerge.lookahead_off)
ma_up   = mtf_ma >= mtf_ma[1]
ma_is_green = ma_up and close > mtf_ma
alphaATR = ta.sma(ta.tr(true), mg_alphaPeriod)
upTmg = low - alphaATR*mg_alphaCoeff
downTmg = high + alphaATR*mg_alphaCoeff
var float alphaTrendMG=na
alphaTrendMG := ta.rsi(close, mg_alphaPeriod)>=50 ? (upTmg < nz(alphaTrendMG[1]) ? nz(alphaTrendMG[1]) : upTmg)
                                                 : (downTmg > nz(alphaTrendMG[1]) ? nz(alphaTrendMG[1]) : downTmg)
alphaBuyMG = ta.crossover(alphaTrendMG, alphaTrendMG[2])
mtf_rsi = request.security(syminfo.tickerid, mg_rsiTF, ta.rsi(close, mg_rsiLen), barmerge.gaps_off, barmerge.lookahead_off)
score_buy = (alphaBuyMG?1:0) + ((ta.crossover(mtf_macd, mtf_signal) and (mtf_hist>0) )?1:0) + (ma_is_green?1:0) + ((mg_useRSIConfirm and (mtf_rsi > mg_rsiThresh))?1:0)
strong_buy = eff_includeModule2 and (score_buy >= (mg_useRSIConfirm?4:3)) and (showStrongShapeFiltered ? not buyBlockedByPct : true)
// Apply QG to MG signals
strong_buy := strong_buy and ((not buyQG_enable) or (not buyQG_apply_mg) or buyqg_quality_pass)
plotshape(eff_includeModule2 and strong_buy, style=shape.labelup, location=location.belowbar, color=color.green, text="MULTI GÜÇLÜ AL", size=size.normal, title="M2 MULTI GÜÇLÜ AL")

if eff_includeModule2 and mg_enableAlertsChart and barstate.isconfirmed and strong_buy
    id_mg_chart = "MG_CHART_BUY_" + str.tostring(bar_index)
    [tgTR, tgEN] = f_target_block_buy(close, (trailStopEnabled and havePosition and not na(liveStop) ? liveStop : stUp))
    headerTR = "🟢 Multi Güçlü AL [" + syminfo.ticker + "] [" + f_tf_label(timeframe.period) + "]"
    headerEN = "🟢 Multi Strong BUY [" + syminfo.ticker + "] [" + f_tf_label(timeframe.period) + "]"
    pgBlock  = (unifiedIncludePG and eff_pg_enable and pg_ctx_for_unified_buy!="") ? ((etiketDil=="TR" ? "\nPG:\n" : "\nPG\n") + pg_ctx_for_unified_buy) : ""
    techCtx  = tech_ctx_for_unified_buy != "" ? tech_ctx_for_unified_buy : f_quick_tech_ctx()
    techBlock= (etiketDil=="TR" ? "\nTEK\n" : "\nTECH\n") + techCtx
    prevNote = f_prev_bullish_note()
    bodyTR   = "\nFiyat: " + fmtMint(close) + tgTR + pgBlock + techBlock + prevNote
    bodyEN   = "\nPrice: " + fmtMint(close) + tgEN + pgBlock + techBlock + prevNote
    msg_mg_chart = (etiketDil=="TR" ? headerTR + bodyTR : headerEN + bodyEN)
    send_event(id_mg_chart, msg_mg_chart, fChatId(true, false), alert.freq_once_per_bar_close)
    [lastBullishTime, lastBullishPrice, lastBullishTextTR, lastBullishTextEN, lastBullishTF] = f_record_bullish("Multi Güçlü AL","Multi Strong BUY", f_tf_label(timeframe.period))

// MG MTF
f_alpha_buy_for_tf(_p, _k) =>
    aATR = ta.sma(ta.tr(true), _p)
    upT  = low  - aATR*_k
    dnT  = high + aATR*_k
    var float AT = na
    AT := ta.rsi(close, _p)>=50 ? math.max(upT, nz(AT[1])) : math.min(dnT, nz(AT[1]))
    ta.crossover(AT, AT[2])

f_macd_buy_for_tf(_fast, _slow, _signal) =>
    fma  = ta.ema(close, _fast)
    sma_ = ta.ema(close, _slow)
    macd = fma - sma_
    sig  = ta.sma(macd, _signal)
    hist = macd - sig
    (ta.crossover(macd, sig) and hist > 0)

f_ma_green_for_tf(_len, _type) =>
    maVal =
         _type=="SMA"? ta.sma(close, _len) :
         _type=="EMA"? ta.ema(close, _len) :
         _type=="WMA"? ta.wma(close, _len) :
         _type=="HullMA"? ta.wma(2*ta.wma(close, math.round(_len/2)) - ta.wma(close, _len), math.round(math.sqrt(_len))) :
         _type=="VWMA"? ta.vwma(close, _len) :
         _type=="RMA"? ta.rma(close, _len) :
         _type=="TEMA"? 3*(ta.ema(close, _len)-ta.ema(ta.ema(close, _len), _len))+ta.ema(ta.ema(ta.ema(close, _len), _len), _len) :
         _type=="TilsonT3"? ta.ema(close, _len)*0.7 - ta.ema(ta.ema(close, _len), _len)*0.3 :
         ta.ema(close, _len)
    (maVal >= maVal[1]) and (close > maVal)

f_mg_strong_on_tf(_tf) =>
    alphaB = request.security(syminfo.tickerid, _tf, f_alpha_buy_for_tf(mg_alphaPeriod, mg_alphaCoeff), barmerge.gaps_off, barmerge.lookahead_off)
    macdB  = request.security(syminfo.tickerid, _tf, f_macd_buy_for_tf(mg_periodMACD, mg_slowMACD, mg_signalMACD), barmerge.gaps_off, barmerge.lookahead_off)
    maG    = request.security(syminfo.tickerid, _tf, f_ma_green_for_tf(mg_maLen, mg_maType), barmerge.gaps_off, barmerge.lookahead_off)
    rsiOk  = mg_useRSIConfirm ? request.security(syminfo.tickerid, _tf, ta.rsi(close, mg_rsiLen) > mg_rsiThresh, barmerge.gaps_off, barmerge.lookahead_off) : true
    sc = (alphaB?1:0) + (macdB?1:0) + (maG?1:0) + (rsiOk?1:0)
    need = mg_useRSIConfirm ? 4 : 3
    eff_includeModule2 and (sc >= need)

sendMgMtf(tf, tfLabel, useTf)=>
    // Skip if requested timeframe is not higher than chart timeframe (prevents redundant calls and errors)
    if eff_includeModule2 and eff_mg_enableAlertsMTF and useTf and f_is_higher_tf(tf)
        tfClosed = request.security(syminfo.tickerid, tf, barstate.isconfirmed, barmerge.gaps_off, barmerge.lookahead_off)
        mgStrong = f_mg_strong_on_tf(tf)
        // Apply QG
        mgStrong := mgStrong and ((not buyQG_enable) or (not buyQG_apply_mg) or buyqg_quality_pass)
        if tfClosed and mgStrong
            [tgTR, tgEN] = f_target_block_buy(close, (trailStopEnabled and havePosition and not na(liveStop) ? liveStop : stUp))
            id  = "MG_MTF_"+tfLabel+"_BUY_" + str.tostring(bar_index)
            hdrTR = "🟢 MTF Multi Güçlü AL [" + syminfo.ticker + "] " + tfLabel
            hdrEN = "🟢 MTF Multi Strong BUY [" + syminfo.ticker + "] " + tfLabel
            pgBlock  = (unifiedIncludePG and eff_pg_enable and pg_ctx_for_unified_buy!="") ? ((etiketDil=="TR" ? "\nPG:\n" : "\nPG\n") + pg_ctx_for_unified_buy) : ""
            techCtx  = tech_ctx_for_unified_buy != "" ? tech_ctx_for_unified_buy : f_quick_tech_ctx()
            techBlock= (etiketDil=="TR" ? "\nTEK\n" : "\nTECH\n") + techCtx
            prevNote = f_prev_bullish_note()
            bodyTR   = "\nFiyat: " + fmtMint(close) + tgTR + pgBlock + techBlock + prevNote
            bodyEN   = "\nPrice: " + fmtMint(close) + tgEN + pgBlock + techBlock + prevNote
            msg = (etiketDil=="TR" ? hdrTR + bodyTR : hdrEN + bodyEN)
            send_event(id, msg, fChatId(true,false), alert.freq_once_per_bar_close)
            [lastBullishTime, lastBullishPrice, lastBullishTextTR, lastBullishTextEN, lastBullishTF] = f_record_bullish("MTF Multi Güçlü AL","MTF Multi Strong BUY", tfLabel)

sendMgMtf("60","1H", mtf_use_1h)
sendMgMtf("240","4H", mtf_use_4h)
sendMgMtf("D","1D", mtf_use_1d)

// ---
// 9) PG MODÜL (Chart TF) + Yüksek Güven
// ---
var bool buyHC = na
var bool selHC = na
var bool pg_buy_sig_base = na
var bool pg_sell_sig_base = na

f_pg_cmf(h,l,c,v,len)=>
    hhll=h-l
    mfm=hhll!=0?((c-l)-(h-c))/hhll:0.0
    mfv=mfm*v
    sum_mfv=ta.sma(mfv,len)*len
    sum_vol=ta.sma(v,len)*len
    sum_vol!=0?sum_mfv/sum_vol:0.0

f_pg_dmi(len)=>
    upMove=high-high[1]
    downMove=low[1]-low
    plusDM=(upMove>downMove and upMove>0)?upMove:0.0
    minusDM=(downMove>upMove and downMove>0)?downMove:0.0
    tr1=high-low
    tr2=math.abs(high-close[1])
    tr3=math.abs(low -close[1])
    tr =math.max(tr1,math.max(tr2,tr3))
    atr=ta.rma(tr,len)
    plusDI = atr!=0?100*ta.rma(plusDM,len)/atr:0.0
    minusDI= atr!=0?100*ta.rma(minusDM,len)/atr:0.0
    dx=(plusDI+minusDI!=0)?100*math.abs(plusDI-minusDI)/(plusDI+minusDI):0.0
    adx=ta.rma(dx,len)
    [plusDI,minusDI,adx]

f_ad_slope(h,l,c,v,len)=>
    hhll=h-l
    mfm=hhll!=0?((c-l)-(h-c))/hhll:0.0
    mfv=mfm*v
    ta.sma(mfv, len)

pg_json_global = useCustomJsonAlert
pg_json_local  = pg_use_json_telegram
pg_json = pg_json_local or pg_json_global

var string pg_dayBuy  = ""
// var string pg_daySell = ""
var int    pg_tBuy    = na
// var int    pg_tSell   = na
pg_cool_ms = pg_cooldown_minutes * 60 * 1000

float pg_vol_sma     = na
float pg_vol_stdev   = na
float pg_vol_z       = na
bool  pg_spike       = false
float pg_cmf         = na
bool  pg_money_in    = false
bool  pg_money_out   = false
float pg_htf_cmf     = na

pg_htf_cmf_val = eff_pg_enable ? request.security(syminfo.tickerid, pg_htf_cmf_tf, f_pg_cmf(high,low,close,volume,pg_cmf_period), barmerge.gaps_off, barmerge.lookahead_off) : na

if eff_pg_enable
    pg_vol_sma   := ta.sma(volume, pg_vol_period)
    pg_vol_stdev := ta.stdev(volume, pg_vol_period)
    pg_vol_z     := pg_vol_stdev>0 ? (volume-pg_vol_sma)/pg_vol_stdev : 0.0
    pg_spike_sma = volume > pg_vol_sma * pg_vol_multiplier
    pg_spike_z   = pg_vol_z > pg_vol_z_threshold
    pg_spike     := pg_use_zscore_vol ? pg_spike_z : pg_spike_sma

    pg_cmf       := f_pg_cmf(high,low,close,volume,pg_cmf_period)
    pg_money_in  := pg_cmf > pg_cmf_pos_th
    pg_money_out := pg_cmf < pg_cmf_neg_th

    pg_htf_cmf := pg_enable_htf_cmf ? pg_htf_cmf_val : na
    pg_ok_buy   = not pg_enable_htf_cmf or (pg_htf_cmf >= pg_cmf_pos_th)
    pg_ok_sell  = not pg_enable_htf_cmf or (pg_htf_cmf <= pg_cmf_neg_th)

    pg_vwap = ta.vwap(pg_vwap_source)
    var float pg_cum_pv = na
    var float pg_cum_vol = na
    var bool  pg_anch_on = false
    var float pg_anch_vwap = na
    pg_new_sess = ta.change(time("D")) != 0
    if pg_anchor_use_session and pg_new_sess
        pg_cum_pv := 0.0
        pg_cum_vol := 0.0
        pg_anch_on := true
        pg_anch_vwap := na
    if pg_use_anchor_by_time and not pg_anchor_use_session
        if (time >= pg_anchor_time) and not pg_anch_on
            pg_cum_pv := 0.0
            pg_cum_vol := 0.0
            pg_anch_on := true
            pg_anch_vwap := na
    if pg_anch_on
        pg_cum_pv  := nz(pg_cum_pv)  + (pg_vwap_source * volume)
        pg_cum_vol := nz(pg_cum_vol) + volume
        pg_anch_vwap := pg_cum_vol > 0 ? pg_cum_pv/pg_cum_vol : na
    else
        pg_anch_vwap := na

    pg_ma_mid = pg_bb_ma_type=="SMA" ? ta.sma(pg_bb_src, pg_bb_length) : ta.ema(pg_bb_src, pg_bb_length)
    pg_bb_dev = ta.stdev(pg_bb_src, pg_bb_length)
    pg_bb_up  = pg_ma_mid + pg_bb_mult*pg_bb_dev
    pg_bb_dn  = pg_ma_mid - pg_bb_mult*pg_bb_dev

    float pg_value = na
    string pg_label_val = ""
    if pg_va_mode=="VWAP" or pg_va_mode=="Anchored VWAP"
        pg_value := nz(pg_anch_vwap, pg_vwap)
        pg_label_val := "VW"
    else
        pg_value := pg_ma_mid
        pg_label_val := "BB"

    pg_above = na(pg_value) ? false : close > pg_value
    pg_below = na(pg_value) ? false : close < pg_value

    [pg_di_p, pg_di_m, pg_adx_val] = f_pg_dmi(pg_adx_len)
    ad_slope_val = f_ad_slope(high, low, close, volume, pg_ad_slope_len)

    pg_raw_buy  = pg_spike and pg_money_in  and pg_above and close>open and pg_ok_buy
    pg_raw_sell = pg_spike and pg_money_out and pg_below and close<open and pg_ok_sell
    pg_confirm  = pg_use_close_confirm ? barstate.isconfirmed : true

    pg_buy_sig_base  := pg_raw_buy  and pg_confirm and (not pg_require_di_align or pg_di_p > pg_di_m) and (not pg_require_ad_confirm or ad_slope_val > 0)
    pg_sell_sig_base := pg_raw_sell and pg_confirm and (not pg_require_di_align or pg_di_m > pg_di_p) and (not pg_require_ad_confirm or ad_slope_val < 0)

    rangeV     = math.max(high - low, syminfo.mintick*5)
    bodyRatio  = math.abs(close - open) / rangeV
    closePos   = (close - low) / rangeV
    closePosSell = (high - close) / rangeV
    vwapDistPct = na(pg_value) ? 0.0 : math.abs(close - pg_value) / close * 100.0
    diDiff     = math.abs(pg_di_p - pg_di_m)

    adx_ok     = pg_adx_val >= pg_hc_min_adx
    di_ok      = (not pg_require_di_align) or diDiff >= pg_hc_min_di_diff
    cmf_ok_buy = pg_cmf >= pg_hc_cmf_pos
    cmf_ok_sel = pg_cmf <= pg_hc_cmf_neg
    body_ok_b  = (bodyRatio*100.0 >= pg_hc_min_body_pct) and (closePos*100.0 >= (100.0 - pg_hc_close_near_pct))
    body_ok_s  = (bodyRatio*100.0 >= pg_hc_min_body_pct) and (closePosSell*100.0 >= (100.0 - pg_hc_close_near_pct))
    vwap_ok    = vwapDistPct >= pg_hc_vwap_dist_pct

    strongAccum  = (pg_cmf >= pg_hc_cmf_pos) and (ad_slope_val > 0) and pg_above
    negDayBlock  = pg_hc_neg_day_rule and (dayChangePct < 0) and (not strongAccum)
    buyHC := adx_ok and di_ok and cmf_ok_buy and pg_above and body_ok_b and vwap_ok and not negDayBlock
    selHC := adx_ok and di_ok and cmf_ok_sel and pg_below and body_ok_s and vwap_ok

    pg_buy_sig  = pg_hc_enable ? (pg_buy_sig_base  and buyHC) : pg_buy_sig_base
    pg_sell_sig = pg_hc_enable ? (pg_sell_sig_base and selHC)  : pg_sell_sig_base

    pg_trend_ema = ta.ema(close, pg_trend_len)
    pg_trend_stat= etiketDil=="TR" ? (close>pg_trend_ema ? "YUK" : "DUS") : (close>pg_trend_ema ? "UP" : "DOWN")
    [pg_macd, pg_macd_sig, pg_hist] = ta.macd(close, pg_fast_len, pg_slow_len, pg_signal_len)
    pg_macd_stat = etiketDil=="TR" ? (pg_macd>pg_macd_sig ? "POZ" : "NEG") : (pg_macd>pg_macd_sig ? "POS" : "NEG")
    pg_adx_interp= etiketDil=="TR" ? (pg_adx_val > pg_adx_threshold ? "GT" : "ZAY") : (pg_adx_val > pg_adx_threshold ? "ST" : "WEAK")
    pg_atr       = ta.atr(pg_atr_len)
    pg_vdiff     = na(pg_value)?na:(close-pg_value)

    string pg_bb_pos = ""
    if pg_va_mode=="MA+Bollinger"
        pg_bb_pos := etiketDil=="TR" ? (close > pg_bb_up ? "ÜST" : (close < pg_bb_dn ? "ALT" : "İÇ"))
                                     : (close > pg_bb_up ? "ABOVE" : (close < pg_bb_dn ? "BELOW" : "IN"))

    string __pg_val_line_tr = ""
    string __pg_val_line_en = ""
    if pg_va_mode=="MA+Bollinger"
        __pg_val_line_tr := "\nBB Konumu: " + pg_bb_pos
        __pg_val_line_en := "\nBB Position: " + pg_bb_pos
    else
        __pg_val_line_tr := "\nDeğer: " + pg_label_val + (not na(pg_vdiff) ? "  Δ: " + str.tostring(pg_vdiff, "#.####") : "")
        __pg_val_line_en := "\nValue: " + pg_label_val + (not na(pg_vdiff) ? "  Δ: " + str.tostring(pg_vdiff, "#.####") : "")

    string pg_ctx_tr =
          "TR:" + pg_trend_stat +
          "\nMACD: " + pg_macd_stat +
          "\nADX: " + str.tostring(pg_adx_val, "#.##") + " (" + pg_adx_interp + ")" +
          "\nATR: " + str.tostring(pg_atr, "#.##") +
          "\nCMF: " + str.tostring(pg_cmf, "#.###") +
          __pg_val_line_tr

    string pg_ctx_en =
          "TR:" + pg_trend_stat +
          "\nMACD: " + pg_macd_stat +
          "\nADX: " + str.tostring(pg_adx_val, "#.##") + " (" + pg_adx_interp + ")" +
          "\nATR: " + str.tostring(pg_atr, "#.##") +
          "\nCMF: " + str.tostring(pg_cmf, "#.###") +
          __pg_val_line_en

    pg_ctx_for_unified_buy := (etiketDil=="TR" ? pg_ctx_tr : pg_ctx_en)
    PG_CTX_TR := pg_ctx_tr
    PG_CTX_EN := pg_ctx_en

    string hdrB_tr = "", hdrB_en = "", valueLine_tr = "", valueLine_en = "", body_tr = "", body_en = "", txtB = ""
    // string hdrS_tr = "", hdrS_en = "", body_tr_s = "", body_en_s = "", txtS = ""

    canSendNow = true
    pg_buy_blocked_pct = pg_suppress_buy_if_daily_up and (dayChangePct >= pg_daily_up_pct_threshold)
    pg_currDay = str.format("{0}-{1}-{2}", year(time), month(time), dayofmonth(time))

    allowChartBuy  = f_pg_allow(pg_enable_alerts and pg_chart_also_send and pg_buy_sig  and not pg_buy_blocked_pct, pg_dayBuy,  pg_tBuy,  pg_daily_once, pg_cooldown_minutes, time, pg_currDay)
    // allowChartSell = f_pg_allow(pg_enable_alerts and pg_chart_also_send and pg_sell_sig, pg_daySell, pg_tSell, pg_daily_once, pg_cooldown_minutes, time, pg_currDay)


    if canSendNow and allowChartBuy
        hdrB_tr := "💰 PG GİRİŞ — " + syminfo.ticker + " [" + f_tf_label(timeframe.period) + "]"
        hdrB_en := "💰 PG IN — " + syminfo.ticker + " [" + f_tf_label(timeframe.period) + "]"
        valueLine_tr := pg_va_mode=="MA+Bollinger" ? "\nBB Konumu: " + pg_bb_pos : "\nDeğer: " + pg_label_val + (not na(pg_vdiff) ? "  Δ: " + str.tostring(pg_vdiff, "#.####") : "")
        valueLine_en := pg_va_mode=="MA+Bollinger" ? "\nBB Position: " + pg_bb_pos : "\nValue: " + pg_label_val + (not na(pg_vdiff) ? "  Δ: " + str.tostring(pg_vdiff, "#.####") : "")
        prevNotePG = f_prev_bullish_note()
        body_tr := "\nFiyat: " + fmtMint(close) + "\nTR:" + pg_trend_stat + "\nMACD: " + pg_macd_stat + "\nADX: " + str.tostring(pg_adx_val, "#.##") + " (" + pg_adx_interp + ")\nATR: " + str.tostring(pg_atr, "#.##") + "\nCMF: " + str.tostring(pg_cmf, "#.###") + valueLine_tr + prevNotePG
        body_en := "\nPrice: " + fmtMint(close) + "\nTR:" + pg_trend_stat + "\nMACD: " + pg_macd_stat + "\nADX: " + str.tostring(pg_adx_val, "#.##") + " (" + pg_adx_interp + ")\nATR: " + str.tostring(pg_atr, "#.##") + "\nCMF: " + str.tostring(pg_cmf, "#.###") + valueLine_en + prevNotePG
        txtB := (etiketDil=="TR" ? hdrB_tr + body_tr : hdrB_en + body_en)
        send_event("PG_CHART_BUY_"+str.tostring(bar_index), txtB, f_pg_chat(true), alert.freq_once_per_bar_close)
        pg_dayBuy := pg_currDay
        pg_tBuy   := time
        [lastBullishTime, lastBullishPrice, lastBullishTextTR, lastBullishTextEN, lastBullishTF] = f_record_bullish("PG GİRİŞ","PG IN", f_tf_label(timeframe.period))

    // PG EXIT disabled
    // if canSendNow and allowChartSell
    //     hdrS_tr := "💨 PG ÇIKIŞ — " + syminfo.ticker + " [" + f_tf_label(timeframe.period) + "]"
    //     hdrS_en := "💨 PG OUT — " + syminfo.ticker + " [" + f_tf_label(timeframe.period) + "]"
    //     valueLine_tr := pg_va_mode=="MA+Bollinger" ? "\nBB Konumu: " + pg_bb_pos : "\nDeğer: " + pg_label_val + (not na(pg_vdiff) ? "  Δ: " + str.tostring(pg_vdiff, "#.####") : "")
    //     valueLine_en := pg_va_mode=="MA+Bollinger" ? "\nBB Position: " + pg_bb_pos : "\nValue: " + pg_label_val + (not na(pg_vdiff) ? "  Δ: " + str.tostring(pg_vdiff, "#.####") : "")
    //     body_tr_s := "\nFiyat: " + fmtMint(close) + "\nTR:" + pg_trend_stat + "\nMACD: " + pg_macd_stat + "\nADX: " + str.tostring(pg_adx_val, "#.##") + " (" + pg_adx_interp + ")\nATR: " + str.tostring(pg_atr, "#.##") + "\nCMF: " + str.tostring(pg_cmf, "#.###") + valueLine_tr
    //     body_en_s := "\nPrice: " + fmtMint(close) + "\nTR:" + pg_trend_stat + "\nMACD: " + pg_macd_stat + "\nADX: " + str.tostring(pg_adx_val, "#.##") + " (" + pg_adx_interp + ")\nATR: " + str.tostring(pg_atr, "#.##") + "\nCMF: " + str.tostring(pg_cmf, "#.###") + valueLine_en
    //     txtS := (etiketDil=="TR" ? hdrS_tr + body_tr_s : hdrS_en + body_en_s)
    //     send_event("PG_CHART_SELL_"+str.tostring(bar_index), txtS, f_pg_chat(false), alert.freq_once_per_bar_close)

// ---
// 10) HYBRID POTENTIAL
// ---
var float __barDurationMs = 0.0
if barstate.isnew
    __barDurationMs := nz(time - time[1], time_close - time)
isRT = barstate.isrealtime
barProgressPct = isRT and __barDurationMs > 0 ? (timenow - time) / __barDurationMs * 100.0 : 100.0
barProgressPct := math.min(math.max(barProgressPct, 0.0), 100.0)

var int potBuyStableCount  = 0
var int potSellStableCount = 0
potRawBuy  = buySignal
potRawSell = sellSignal
potBuyStableCount  := potRawBuy  ? potBuyStableCount + 1 : 0
potSellStableCount := potRawSell ? potSellStableCount + 1 : 0

var int potBuyBarSent  = na
var int potSellBarSent = na
hybCooldownMs = eff_hybCooldownMinutes * 60 * 1000
var int potLastBuyTime  = na
var int potLastSellTime = na
potCooldownOkBuy  = eff_hybCooldownMinutes==0 or na(potLastBuyTime)  or (time - potLastBuyTime  > hybCooldownMs)
potCooldownOkSell = eff_hybCooldownMinutes==0 or na(potLastSellTime) or (time - potLastSellTime > hybCooldownMs)

eligiblePotBuy  = enableHybrid and potRawBuy  and htfOkLongLabel  and isRT and barProgressPct >= eff_hybMinProgressPct and potBuyStableCount  >= eff_hybStabilityTicks and (na(potBuyBarSent)  or bar_index != potBuyBarSent)  and potCooldownOkBuy and not combinePotAndConfirm
eligiblePotSell = enableHybrid and potRawSell and htfOkShortLabel and isRT and barProgressPct >= eff_hybMinProgressPct and potSellStableCount >= eff_hybStabilityTicks and (na(potSellBarSent) or bar_index != potSellBarSent) and potCooldownOkSell and not combinePotAndConfirm

// ---
// 11) CONFIRMED EVENTS (Unified Build) + SQZ
// ---
confirmWrap(c)=> (not useCloseConfirm or barstate.isconfirmed)?c:false
evBuy   = confirmWrap(includeBuyFlip        and buySignal          and htfOkLongAlert)
evSell  = confirmWrap(includeSellFlip       and sellSignal         and htfOkShortAlert)
evLInt  = confirmWrap(includeLongIntersect  and longIntersectAlert)
// BANKO KESIŞME AL - Dual mode: Repaint (realtime) + Confirmed (bar close)
// evLInt_Repaint    = includeLongIntersect and longIntersectAlert  // Realtime, no confirmation - DISABLED per user request
evLInt_Confirmed  = confirmWrap(includeLongIntersect and longIntersectAlert)  // Bar close confirmed
evSInt  = confirmWrap(includeShortIntersect and shortIntersectAlert)
evHit1  = confirmWrap(includeHitR1          and hitR1)
evHit2  = confirmWrap(includeHitR2          and hitR2)
evTrail = confirmWrap(includeTrailMove      and trailMoved)
evExit  = confirmWrap(includeExit           and (exitLong or exitShort))
if evLInt or evLInt_Confirmed  // or evLInt_Repaint - REMOVED
    evBuy := false
if evSInt
    evSell := false

string tech_htf = ""
if not enableHTF
    tech_htf := etiketDil=="TR" ? "HTF: Kapalı" : "HTF: Off"
else
    string htfDirStr2 = etiketDil=="TR" ? (htfUp ? "Yukarı" : htfDn ? "Aşağı" : "Yatay") : (htfUp ? "Up" : htfDn ? "Down" : "Flat")
    string slopeStr2  = htfSlopeConfirm ? (etiketDil=="TR" ? (" (Eğim " + (htfSlope >= 0 ? "≥0" : "<0") + ")") : (" (Slope " + (htfSlope >= 0 ? "≥0" : "<0") + ")")) : ""
    tech_htf := "HTF:" + htfDirStr2 + slopeStr2 + " [" + htfModeAlerts + "]"
string st_event = ""
if evLInt
    st_event := etiketDil=="TR" ? "SuperTR:BANKO KESİŞME AL" : "SuperTR:BANKO LONG INTERSECT"
else if evBuy
    st_event := etiketDil=="TR" ? "SuperTR:AL Flip" : "SuperTR:Buy Flip"
else if evSInt
    st_event := etiketDil=="TR" ? "SuperTR:BANKO KESİŞME SAT" : "SuperTR:BANKO SHORT INTERSECT"
else if evSell
    st_event := etiketDil=="TR" ? "SuperTR:SAT Flip" : "SuperTR:Sell Flip"
string slingshot_note = ""
if consUp
    slingshot_note := etiketDil=="TR" ? "SS: Con Up" : "SS: Con Up"
else if consDn
    slingshot_note := etiketDil=="TR" ? "SS: Con Down" : "SS: Con Down"
tech_ctx_for_unified_buy := tech_htf + (st_event!="" ? ("\n" + st_event) : "") + (slingshot_note!="" ? ("\n" + slingshot_note) : "")

currDay = str.format("{0}-{1}-{2}", year(time), month(time), dayofmonth(time))
cooldownMs = eff_cooldownMinutes * 60 * 1000
fAllow(ev, dayRef, tRef)=>
    allow = ev
    if allow and eff_dailyOnce
        allow := dayRef != currDay
    if allow and eff_cooldownMinutes>0
        allow := na(tRef) or time - tRef > cooldownMs
    allow

var string dayBuy  = ""
var string daySell = ""
var string dayLInt = ""
var string daySInt = ""
var string dayR1   = ""
var string dayR2   = ""
var string dayTrail= ""
var string dayExit = ""

var int tBuy   = na
var int tSell  = na
var int tLInt  = na
var int tSInt  = na
var int tR1    = na
var int tR2    = na
var int tTrail = na
var int tExit  = na

allowBuy   = fAllow(evBuy,   dayBuy,   tBuy)   and not buyBlockedByPct
allowSell  = fAllow(evSell,  daySell,  tSell)
allowLInt  = fAllow(evLInt,  dayLInt,  tLInt)  and not buyBlockedByPct
// BANKO KESIŞME AL - CONFIRMED only (REPAINT disabled per user request)
// allowLInt_Repaint   = fAllow(evLInt_Repaint,   dayLInt,  tLInt)  and not buyBlockedByPct  // DISABLED
allowLInt_Confirmed = fAllow(evLInt_Confirmed, dayLInt,  tLInt)  and not buyBlockedByPct
allowSInt  = fAllow(evSInt,  daySInt,  tSInt)
allowHitR1 = fAllow(evHit1,  dayR1,    tR1)
allowHitR2 = fAllow(evHit2,  dayR2,    tR2)
allowTrail = fAllow(evTrail, dayTrail, tTrail)
allowExit  = fAllow(evExit,  dayExit,  tExit)

mgChartFired = eff_includeModule2 and mg_enableAlertsChart and barstate.isconfirmed and strong_buy

if allowBuy
    dayBuy := currDay
    tBuy := time
if allowSell
    daySell := currDay
    tSell := time
if allowLInt
    dayLInt := currDay
    tLInt := time
if allowSInt
    daySInt := currDay
    tSInt := time
if allowHitR1
    dayR1 := currDay
    tR1 := time
if allowHitR2
    dayR2 := currDay
    tR2 := time
if allowTrail
    dayTrail := currDay
    tTrail := time
if allowExit
    dayExit := currDay
    tExit := time

// ---
// SQZ Signal modu — olayları oluştur (1H/4H/1D destekli)
// ---

// 1) SQZ Durumunu Hesaplayan Fonksiyon
f_sqz_state() =>
    _source   = close
    _basis    = ta.sma(_source, sqz_lenBB)
    _dev      = sqz_multBB * ta.stdev(_source, sqz_lenBB)
    _upperBB  = _basis + _dev
    _lowerBB  = _basis - _dev
    _range    = sqz_useTR ? ta.tr(true) : (high - low)
    _rangema  = ta.sma(_range, sqz_lenKC)
    _ma       = ta.sma(_source, sqz_lenKC)
    _upperKC  = _ma + _rangema * sqz_multKC
    _lowerKC  = _ma - _rangema * sqz_multKC
    _sqzOn    = (_lowerBB > _lowerKC) and (_upperBB < _upperKC)
    _sqzOff   = (_lowerBB < _lowerKC) and (_upperBB > _upperKC)
    _sqz_base = close - math.avg(math.avg(ta.highest(high, sqz_lenKC), ta.lowest(low, sqz_lenKC)), ta.sma(close, sqz_lenKC))
    _sqz_val  = ta.linreg(_sqz_base, sqz_lenKC, 0)
    [_sqzOn, _sqzOff, _sqz_val]

// 2) MTF İçin Özel Sinyal Hesaplayıcı + ADX/Trend Bilgisi
// Bu fonksiyon çağrıldığı zaman diliminde Sinyal, ADX ve Trend durumunu aynı anda hesaplar
f_sqz_mtf_logic_with_context(_adxLen, _trendLen) =>
    [_on, _off, _val] = f_sqz_state()
    // Sinyal tespiti (bir önceki barda off değildi, şimdi off ise = çıkış)
    _sigLong  = _off and not _off[1] and (_val > 0)
    _sigShort = _off and not _off[1] and (_val < 0)
    
    // ADX Hesaplama (o TF içinde)
    [di_p, di_m, adx_raw] = ta.dmi(_adxLen, _adxLen)
    
    // Trend Hesaplama (o TF içinde)
    ema_val = ta.ema(close, _trendLen)
    
    [_sigLong, _sigShort, _val, adx_raw, ema_val, close, barstate.isconfirmed]

f_sqz_strength_txt(v) =>
    _abs = math.abs(v)
    _tr  = _abs < 0.05 ? "DUS" : _abs < 0.15 ? "ORT" : "YUK"
    _en  = _tr
    [_tr, _en]

f_adx_txt(val) =>
    _tr = val < 20 ? "ZAY" : val < 40 ? "GT" : "CGT"
    _en = _tr
    [_tr, _en]

f_trend_txt(price, ema) =>
    _tr = price > ema ? "YUK" : "DUS"
    _en = price > ema ? "UP" : "DN"
    [_tr, _en]

// SQZ mesaj gönderimi (GELİŞMİŞ)
f_send_sqz_advanced(tfLabel, _isLong, _close, _sqzVal, _adxVal, _emaVal, _chatId) =>
    // Apply QG if enabled
    bool sendAllowed = true
    if _isLong and buyQG_enable and buyQG_apply_sqz
        sendAllowed := buyqg_quality_pass
    if not _isLong and sellQG_enable and sellQG_apply_sqz
        sendAllowed := sellqg_qpass
    
    [strTR, strEN] = f_sqz_strength_txt(_sqzVal)
    [adxTR, adxEN] = f_adx_txt(_adxVal)
    [trdTR, trdEN] = f_trend_txt(_close, _emaVal)
    
    string hdr = _isLong
         ? (etiketDil=="TR" ? "📊 SQZ " + (_isLong?"↑":"↓") + " — " : "📊 SQZ " + (_isLong?"↑":"↓") + " — ")
         : (etiketDil=="TR" ? "📊 SQZ " + (_isLong?"↑":"↓") + " — "  : "📊 SQZ " + (_isLong?"↑":"↓") + " — ")
    hdr += syminfo.ticker + " [" + tfLabel + "]"
    
    bodyTR = "\nP:" + fmtMint(_close) + 
             "\nSQZ:" + str.tostring(_sqzVal, "#.##") + 
             " M:" + strTR + 
             " ADX:" + str.tostring(_adxVal, "#.#") + " " + trdTR
             
    bodyEN = "\nP:" + fmtMint(_close) + 
             "\nSQZ:" + str.tostring(_sqzVal, "#.##") + 
             " M:" + strEN + 
             " ADX:" + str.tostring(_adxVal, "#.#") + " " + trdEN

    string body = etiketDil=="TR" ? bodyTR : bodyEN
    string _id = "SQZ_" + tfLabel + "_" + (_isLong ? "L" : "S") + "_" + str.tostring(time) + "_" + str.tostring(bar_index)
    
    if sendAllowed
        send_event(_id, hdr + body, _chatId, alert.freq_once_per_bar_close)

// Chart TF hesaplamaları (Mevcut Grafik)
[sqzOn_ch, sqzOff_ch, sqzVal_ch] = f_sqz_state()
[di_p_ch, di_m_ch, adx_ch] = ta.dmi(pg_adx_len, pg_adx_len) // PG ayarını kullanıyoruz (14)
ema_ch = ta.ema(close, pg_trend_len) // PG ayarını kullanıyoruz (50)

// SQZ Chart TF signals disabled to save tokens (only 4H/1D active)
sqz_long_signal  = false  // Disabled: sqz_enable and (sqz_mode=="Signal") and sqzOff_ch and not sqzOff_ch[1] and (sqzVal_ch > 0)
sqz_short_signal = false  // Disabled: sqz_enable and (sqz_mode=="Signal") and sqzOff_ch and not sqzOff_ch[1] and (sqzVal_ch < 0)

// if sqz_enable and (sqz_mode=="Signal") and sqz_long_signal
//     f_send_sqz_advanced(f_tf_label(timeframe.period), true, close, sqzVal_ch, adx_ch, ema_ch, telegramChatIdBuy)

// SQZ short disabled to reduce tokens
// if sqz_enable and (sqz_mode=="Signal") and sqz_short_signal
//     f_send_sqz_advanced(f_tf_label(timeframe.period), false, close, sqzVal_ch, adx_ch, ema_ch, telegramChatIdSell)

// MTF SQZ (4H, 1D) - Gelişmiş Context ile
f_send_sqz_mtf(tf, tfLabel, useTf)=>
    // Skip if requested timeframe is not higher than chart timeframe
    if sqz_enable and (sqz_mode=="Signal") and useTf and f_is_higher_tf(tf)
        // PG'deki uzunluk ayarlarını (14, 50) MTF içine gönderiyoruz
        [mtf_lSig, mtf_sSig, mtf_val, mtf_adx, mtf_ema, mtf_close, tfClosed] =  request.security(syminfo.tickerid, tf, f_sqz_mtf_logic_with_context(pg_adx_len, pg_trend_len), barmerge.gaps_off, barmerge.lookahead_off)

        // ESKİ satır SİLİNECEK (artık gerek yok):
        // tfClosed = request.security(syminfo.tickerid, tf, barstate.isconfirmed, barmerge.gaps_off, barmerge.lookahead_off)

        if tfClosed and mtf_lSig
            f_send_sqz_advanced(tfLabel, true, mtf_close, mtf_val, mtf_adx, mtf_ema, telegramChatIdBuy)
        // if tfClosed and mtf_sSig
        //     f_send_sqz_advanced(tfLabel, false, mtf_close, mtf_val, mtf_adx, mtf_ema, telegramChatIdSell)

// 4H ve 1D için çağır (1H disabled to save tokens)
// f_send_sqz_mtf("60",  "1H", true)
f_send_sqz_mtf("240", "4H", true)
f_send_sqz_mtf("D",   "1D", true)

eventsArr = array.new_string()
if allowLInt
    array.push(eventsArr, TXT_LINT)
if allowSInt
    array.push(eventsArr, TXT_SINT)
if allowBuy
    array.push(eventsArr, TXT_BUY)
if allowSell
    array.push(eventsArr, TXT_SELL)
if mgChartFired
    array.push(eventsArr, TXT_MG_BUY)
if sqz_add_to_unified
    if sqz_long_signal
        array.push(eventsArr, "SQZ LONG RELEASE")
    if sqz_short_signal
        array.push(eventsArr, "SQZ SHORT RELEASE")
if allowHitR1
    array.push(eventsArr, TXT_HIT_R1)
if allowHitR2
    array.push(eventsArr, TXT_HIT_R2)
if allowTrail
    array.push(eventsArr, TXT_TRAIL_UP)
if allowExit
    array.push(eventsArr, TXT_EXIT)

events = ""
if array.size(eventsArr) > 0
    for i = 0 to array.size(eventsArr)-1
        evTxt = array.get(eventsArr, i)
        events := events=="" ? evTxt : events + ", " + evTxt

isBuyLike  = allowBuy or allowLInt or mgChartFired
isSellLike = allowSell or allowSInt
if not isBuyLike and not isSellLike
    if (allowHitR1 or allowHitR2 or allowTrail) and havePosition
        isBuyLike  := lastEntryDir == 1
        isSellLike := lastEntryDir == -1
    else if allowExit
        isBuyLike  := exitLong
        isSellLike := exitShort

useChatId = fChatId(isBuyLike, isSellLike)
// ---
// 11.5) KESİNLİK MASTER GATE
// ---
grpMASTER = "Kesinlik Master Gate"
masterEnable        = input.bool(true,  "Master Gate: (Kesişim + HTF Strict + PG HC + M2/MTF) olmadan UNIFIED gönderme", group=grpMASTER)
//masterReqM2orMTF    = input.bool(true,  "Master Gate: M2 Combined veya MTF teyidi de şart olsun", group=grpMASTER) cok mesaj gelirse true yap yine
masterReqM2orMTF    = input.bool(false,  "Master Gate: M2 Combined veya MTF teyidi de şart olsun", group=grpMASTER)

// HTF Strict kapısı
isHTFStrictSel   = enableHTF and (htfModeAlerts == "Strict")
isHTFStrictLong  = not isHTFStrictSel or htfUp
isHTFStrictShort = not isHTFStrictSel or htfDn

// M2/MG teyidi
hc_m2_ok =
     nz(mt_buyAllowedCombined, false)
  or nz(mt_buyAllowedConf, false)
  or nz(mt_buyAllowedCandle, false)
  or nz(mgChartFired, false)
  or nz(mt_buyAllowedCombined1D, false)
  or nz(mt_buyAllowedConf1D, false)
  or nz(mt_buyAllowedCandle1D, false)

// PG High-Confidence kapısı
pg_hc_long_ok  = eff_pg_enable ? (pg_hc_enable ? nz(buyHC, false) : nz(pg_buy_sig_base, false)) : true
pg_hc_short_ok = eff_pg_enable ? (pg_hc_enable ? nz(selHC,  false) : nz(pg_sell_sig_base,false)) : true

// Kesişim ve tüm kapılar
hc_long_gate  = evLInt and isHTFStrictLong  and pg_hc_long_ok  and (not masterReqM2orMTF or hc_m2_ok)
hc_short_gate = evSInt and isHTFStrictShort and pg_hc_short_ok and (not masterReqM2orMTF or (nz(mt_sellAllowedCombined, false) or nz(mt_sellAllowedCombined1D, false)))

// Unified mesajın izni
canSendUnified = enableUnifiedAlert and (events != "") and (not masterEnable or hc_long_gate or hc_short_gate)

// ---
// 12) HYBRID POTENTIAL SEND
// ---
if hybUseSeparateAlerts and eligiblePotBuy and not buyBlockedByPct
    potHdr  = (etiketDil=="TR" ? "⚠️ [POTANSİYEL AL " : "⚠️ [POTENTIAL BUY ") + syminfo.ticker + "]"
    potBody = (etiketDil=="TR" ? ("Bar İlerlemesi: " + str.tostring(barProgressPct, "#.0") + "%\nFiyat: " + fmtMint(close)) : ("Bar Progress: " + str.tostring(barProgressPct, "#.0") + "%\nPrice: " + fmtMint(close)))
    potMsg  = potHdr + "\n" + potBody
    send_event("POT_BUY_"+str.tostring(bar_index), potMsg, fChatId(true,false), alert.freq_once_per_bar)
    potBuyBarSent := bar_index
    potLastBuyTime := time
    if hybShowPotentialLabel
        label.new(bar_index, close, etiketDil=="TR"?"POT AL":"POT BUY", style=label.style_label_up, color=color.new(color.blue,0), textcolor=color.white, size=size.tiny)

if hybUseSeparateAlerts and eligiblePotSell
    potHdr  = (etiketDil=="TR" ? "⚠️ [POTANSİYEL SAT " : "⚠️ [POTENTIAL SELL ") + syminfo.ticker + "]"
    potBody = (etiketDil=="TR" ? ("Bar İlerlemesi: " + str.tostring(barProgressPct, "#.0") + "%\nFiyat: " + fmtMint(close)) : ("Bar Progress: " + str.tostring(barProgressPct, "#.0") + "%\nPrice: " + fmtMint(close)))
    potMsg  = potHdr + "\n" + potBody
    send_event("POT_SELL_"+str.tostring(bar_index), potMsg, fChatId(false,true), alert.freq_once_per_bar)
    potSellBarSent := bar_index
    potLastSellTime := time
    if hybShowPotentialLabel
        label.new(bar_index, close, etiketDil=="TR"?"POT SAT":"POT SELL", style=label.style_label_down, color=color.new(color.orange,0), textcolor=color.white)

// ---
// 12.5) ERKEN BANKO
// ---
var int earlyBankoBuyLast  = na
var int earlyBankoSellLast = na
earlyBankoCooldownMs = earlyBankoCooldownMin * 60 * 1000

earlyOkTimeBuy  = earlyBankoCooldownMin==0 or na(earlyBankoBuyLast)  or (time - earlyBankoBuyLast  > earlyBankoCooldownMs)
earlyOkTimeSell = earlyBankoCooldownMin==0 or na(earlyBankoSellLast) or (time - earlyBankoSellLast > earlyBankoCooldownMs)

earlyBankoBuy  = earlyBankoEnabled and isRT and (barProgressPct >= earlyBankoMinProgressPct)  and longIntersect_raw  and htfOkLongLabel  and earlyOkTimeBuy
earlyBankoSell = earlyBankoEnabled and isRT and (barProgressPct >= earlyBankoMinProgressPct)  and shortIntersect_raw and htfOkShortLabel and earlyOkTimeSell

if earlyBankoBuy
    idB = "EARLY_BANKO_BUY_" + str.tostring(bar_index)
    prevNoteEB = f_prev_bullish_note()
    msgB = (etiketDil=="TR" ? "⚠️ ERKEN BANKO AL [" : "⚠️ EARLY BANKO BUY [") + syminfo.ticker + "] [" + f_tf_label(timeframe.period) + "] — Fiyat: " + fmtMint(close) + prevNoteEB
    send_event(idB, msgB, fChatId(true,false), alert.freq_once_per_bar)
    earlyBankoBuyLast := time
    [lastBullishTime, lastBullishPrice, lastBullishTextTR, lastBullishTextEN, lastBullishTF] = f_record_bullish("ERKEN BANKO AL", "EARLY BANKO BUY", f_tf_label(timeframe.period))

if earlyBankoSell
    idS = "EARLY_BANKO_SELL_" + str.tostring(bar_index)
    msgS = (etiketDil=="TR" ? "⚠️ ERKEN BANKO SAT [" : "⚠️ EARLY BANKO SELL [") + syminfo.ticker + "] [" + f_tf_label(timeframe.period) + "] — Fiyat: " + fmtMint(close)
    send_event(idS, msgS, fChatId(false,true), alert.freq_once_per_bar)
    earlyBankoSellLast := time

// ---
// 13) UNIFIED MESSAGE — Master Gate ile
// ---
if canSendUnified
    priceStr = fmtMint(close)
    entryStr = havePosition ? fmtMint(lastEntryPrice) : "NA"
    stopStr  = havePosition ? fmtMint(liveStop) : "NA"
    riskStr  = havePosition and riskDist>0 ? fmtMint(riskDist) : "NA"
    r1Str    = (havePosition and showRTargets and not na(lineR1)) ? fmtMint(line.get_y1(lineR1)) : "NA"
    r2Str    = (havePosition and showRTargets and not na(lineR2)) ? fmtMint(line.get_y1(lineR2)) : "NA"
    timeStr  = f_fmt_time(time)
    posDir   = havePosition ? (lastEntryDir==1 ? "LONG" : "SHORT") : "FLAT"
    header   = "📈 [" + syminfo.ticker + "] [" + f_tf_label(timeframe.period) + "]"
    hedefLine = showRTargets ? ((etiketDil=="TR" ? "\nHedef1: " : "\nTarget1: ") + r1Str + (etiketDil=="TR" ? "   Hedef2: " : "   Target2: " ) + r2Str) : ""
    pgBlock  = (unifiedIncludePG and eff_pg_enable and isBuyLike and pg_ctx_for_unified_buy!="") ? ((etiketDil=="TR" ? "\nPG:\n" : "\nPG\n") + pg_ctx_for_unified_buy) : ""
    techBlock= (st_event!="" or slingshot_note!="" or enableHTF) ? ((etiketDil=="TR" ? "\nTEK\n" : "\nTECH\n") + tech_ctx_for_unified_buy) : ""
    prevNoteU = f_prev_bullish_note()
    body = (etiketDil=="TR" ? ("Olay: " + events + "\nFiyat: " + priceStr + "\nPozisyon: " + posDir + "\nGiriş: " + entryStr + "\nStop: " + stopStr + "\nRisk Mesafe: " + riskStr + hedefLine + pgBlock + techBlock + prevNoteU + "\nT:" + timeStr) : ("Event: " + events + "\nPrice: " + priceStr + "\nPosition: " + posDir + "\nEntry: " + entryStr + "\nStop: " + stopStr + "\nRisk Distance: " + riskStr + hedefLine + pgBlock + techBlock + prevNoteU + "\nT:" + timeStr))
    unifiedId = "UNIFIED_"+str.tostring(bar_index)
    freqU = useCloseConfirm ? alert.freq_once_per_bar_close : alert.freq_once_per_bar
    send_event(unifiedId, header + "\n" + body, useChatId, freqU)
    if allowLInt
        [lastBullishTime, lastBullishPrice, lastBullishTextTR, lastBullishTextEN, lastBullishTF] = f_record_bullish("BANKO KESİŞME AL", "BANKO LONG INTERSECT", f_tf_label(timeframe.period))
    else if allowBuy
        [lastBullishTime, lastBullishPrice, lastBullishTextTR, lastBullishTextEN, lastBullishTF] = f_record_bullish("ST AL Flip", "ST Buy Flip", f_tf_label(timeframe.period))
    else if mgChartFired
        [lastBullishTime, lastBullishPrice, lastBullishTextTR, lastBullishTextEN, lastBullishTF] = f_record_bullish("Multi Güçlü AL", "Multi Strong BUY", f_tf_label(timeframe.period))

// BANKO KESIŞME AL - CONFIRMED only (REPAINT disabled per user request)
// All BANKO AL messages go to dedicated chat_id: telegramChatIdMtfBanko
// if allowLInt_Repaint  // DISABLED
//     _bankoReprintMsg = "⚡ BANKO KESİŞME AL [REPAINT]\n[" + syminfo.ticker + "] [" + f_tf_label(timeframe.period) + "]\nFiyat: " + fmtMint(close) + "\n⚠️ Uyarı: Bar kapanmadan önce kaybolabilir!" + f_prev_bullish_note()
//     _bankoReprintId = "BANKO_REPAINT_" + str.tostring(bar_index)
//     send_event(_bankoReprintId, _bankoReprintMsg, telegramChatId, alert.freq_once_per_bar)

if allowLInt_Confirmed
    // Enhanced analytics for BANKO AL
    _banko_volAvg = ta.sma(volume, 20)
    _banko_volRatio = na(_banko_volAvg) or na(volume) ? na : volume / _banko_volAvg
    _banko_rsi = ta.rsi(close, 14)
    _banko_atr = ta.atr(14)
    _banko_atrPct = na(_banko_atr) or na(close) ? na : (_banko_atr / close) * 100
    
    // Format Volume with percentage and category
    _banko_volText = ""
    if na(_banko_volRatio)
        _banko_volText := "Veri yok"
    else
        _banko_volPct = ((_banko_volRatio - 1.0) * 100)
        _banko_volPctStr = (_banko_volPct >= 0 ? "+" : "") + str.tostring(_banko_volPct, "#") + "%"
        if _banko_volRatio > 1.5
            _banko_volText := "GÜÇLÜ (" + _banko_volPctStr + ") ✅"
        else if _banko_volRatio > 1.0
            _banko_volText := "VAR (" + _banko_volPctStr + ") ✅"
        else if _banko_volRatio > 0.8
            _banko_volText := "ORTA (" + _banko_volPctStr + ") ⚠️"
        else
            _banko_volText := "ZAYIF (" + _banko_volPctStr + ") ❌"
    
    // Format Momentum with category
    _banko_momText = ""
    if na(_banko_rsi)
        _banko_momText := "Hesaplanıyor"
    else
        _banko_rsiTrend = _banko_rsi > _banko_rsi[1] ? "↑" : _banko_rsi < _banko_rsi[1] ? "↓" : "→"
        _banko_rsiStr = "RSI " + str.tostring(_banko_rsi, "#") + " " + _banko_rsiTrend
        if _banko_rsi > 60
            _banko_momText := "GÜÇLÜ (" + _banko_rsiStr + ") ✅"
        else if _banko_rsi > 50
            _banko_momText := "ORTA (" + _banko_rsiStr + ") ⚠️"
        else
            _banko_momText := "ZAYIF (" + _banko_rsiStr + ") ❌"
    
    // Format Volatility with description
    _banko_volText2 = ""
    if na(_banko_atrPct)
        _banko_volText2 := "Hesaplanıyor"
    else
        if _banko_atrPct > 4.0
            _banko_volText2 := "YÜKSEK ⚡"
        else if _banko_atrPct > 2.0
            _banko_volText2 := "ORTA 📊"
        else
            _banko_volText2 := "DÜŞÜK 😴"
    
    // Calculate strength grade
    _banko_score = 0
    if not na(_banko_volRatio)
        if _banko_volRatio > 2.0
            _banko_score += 3
        else if _banko_volRatio > 1.5
            _banko_score += 2
        else if _banko_volRatio > 1.2
            _banko_score += 1
    
    if not na(_banko_rsi)
        if _banko_rsi > 60
            _banko_score += 2
        else if _banko_rsi > 55
            _banko_score += 1
    
    if not na(_banko_atrPct) and _banko_atrPct > 3.0
        _banko_score += 1
    
    _banko_grade = _banko_score >= 5 ? "A+ ⭐⭐⭐" : _banko_score >= 3 ? "B ⭐⭐" : "C ⭐"
    
    // Build enhanced message
    _bankoConfMsg = "✓ BANKO KESİŞME AL [CONFIRMED]\n[" + syminfo.ticker + "] [" + f_tf_label(timeframe.period) + "]\nFiyat: " + fmtMint(close) + "\n\n" +
         "📊 Analiz:\n" +
         "Hacim: " + _banko_volText + "\n" +
         "Momentum: " + _banko_momText + "\n" +
         "Volatilite: " + _banko_volText2 + "\n" +
         "Güç: " + _banko_grade + "\n\n" +
         "✅ Kesin sinyal - Bar kapatıldı" + f_prev_bullish_note()
    _bankoConfId = "BANKO_CONFIRMED_" + str.tostring(time)
    send_event(_bankoConfId, _bankoConfMsg, telegramChatIdMtfBanko, alert.freq_once_per_bar_close)
    [lastBullishTime, lastBullishPrice, lastBullishTextTR, lastBullishTextEN, lastBullishTF] = f_record_bullish("BANKO KESİŞME AL", "BANKO LONG INTERSECT", f_tf_label(timeframe.period))

// ---
// 14) MTF ST — Safe Boot ile
// ---
f_mtf_eval() =>
    _tr  = ta.tr(true)
    _atr = altAtrMethod ? ta.sma(_tr, atrLen) : ta.atr(atrLen)
    _mid = hl2
    var float _stU = na
    var float _stD = na
    _upL = _mid - atrMult*_atr
    _dnL = _mid + atrMult*_atr
    _upP = nz(_stU[1], _upL)
    _dnP = nz(_stD[1], _dnL)
    _stU := close[1] > _upP ? math.max(_upL,_upP) : _upL
    _stD := close[1] < _dnP ? math.min(_dnL,_dnP) : _dnL
    var int _dir = 1
    _dir := _dir == -1 and close > _dnP ? 1 : (_dir == 1 and close < _upP ? -1 : _dir)
    _flipUp   = _dir == 1 and _dir[1] == -1
    _flipDown = _dir == -1 and _dir[1] ==  1
    _emaF = ta.ema(close, emaFastLen)
    _emaS = ta.ema(close, emaSlowLen)
    _consUp = _emaF > _emaS and close[1] < _emaF[1] and close > _emaF
    _consDn = _emaF < _emaS and close[1] > _emaF[1] and close < _emaF
    _inWinUp   = eff_confirmWindow==0 ? _flipUp   : ta.barssince(_flipUp)   <= eff_confirmWindow
    _inWinDown = eff_confirmWindow==0 ? _flipDown : ta.barssince(_flipDown) <= eff_confirmWindow
    _evBuy  = (not useCloseConfirm or barstate.isconfirmed) and includeBuyFlip        and _flipUp
    _evSell = (not useCloseConfirm or barstate.isconfirmed) and includeSellFlip       and _flipDown
    // BANKO AL: realtime (no barstate.isconfirmed check)
    _evLInt = includeLongIntersect  and _inWinUp   and _consUp
    // BANKO SAT and others: keep confirmed check
    _evSInt = (not useCloseConfirm or barstate.isconfirmed) and includeShortIntersect and _inWinDown and _consDn
    if _evLInt
        _evBuy := false
    if _evSInt
        _evSell := false
    [_evBuy, _evSell, _evLInt, _evSInt, barstate.isconfirmed, time, close]

sendMtf(tf, tfLabel, useTf)=>
    // Skip if requested timeframe is not higher than chart timeframe
    if eff_mtf_enable and useTf and f_is_higher_tf(tf)
        [b_, s_, l_, k_, tfClosed, mtfTime, mtfClose] = request.security(syminfo.tickerid, tf, f_mtf_eval(), barmerge.gaps_off, barmerge.lookahead_off)

        // tfClosed = request.security(syminfo.tickerid, tf, barstate.isconfirmed, barmerge.gaps_off, barmerge.lookahead_off)
        
        // BANKO AL realtime: fire immediately when l_ is true (no tfClosed check)
        // Only for BANKO AL when mtf_only_banko is true
        bankoAlRealtime = mtf_only_banko and l_
        
        // For non-BANKO mode or for SAT/flip events, wait for tfClosed as before
        if bankoAlRealtime or (tfClosed and (b_ or s_ or l_ or k_))
            buyLike = b_ or l_
            sellLike = s_ or k_
            evStrBuy = ""
            evStrSell = ""
            if mtf_only_banko
                if l_
                    evStrBuy := TXT_LINT
                // k_ (BANKO SAT) should not be sent per user request
            else
                if l_
                    evStrBuy := evStrBuy=="" ? TXT_LINT : evStrBuy + "; " + TXT_LINT
                if b_
                    evStrBuy := evStrBuy=="" ? (etiketDil=="TR"?"AL Flip":"Buy Flip") : evStrBuy + "; " + (etiketDil=="TR"?"AL Flip":"Buy Flip")
                if k_
                    evStrSell := evStrSell=="" ? TXT_SINT : evStrSell + "; " + TXT_SINT
                if s_
                    evStrSell := evStrSell=="" ? (etiketDil=="TR"?"SAT Flip":"Sell Flip") : evStrSell + "; " + (etiketDil=="TR"?"SAT Flip":"Sell Flip")
            
            // BANKO AL alert with proper format: "K - BANKO KESİŞME AL (1H)"
            // Only send when l_ (BANKO AL) is true in BANKO mode
            if mtf_only_banko and l_ and not buyBlockedByPct
                // Use MTF bar time for deduplication instead of bar_index
                // This prevents spam: same mtfTime = same HTF bar = single alert
                id = "MTF_BANKO_AL_"+tfLabel+"_"+str.tostring(mtfTime)
                prevNoteMtf = f_prev_bullish_note()
                
                // Calculate analytics for MTF BANKO AL (using chart TF data for context)
                _mtf_volAvg = ta.sma(volume, 20)
                _mtf_volRatio = na(_mtf_volAvg) or na(volume) ? na : volume / _mtf_volAvg
                _mtf_rsi = ta.rsi(close, 14)
                _mtf_atr = ta.atr(14)
                _mtf_atrPct = na(_mtf_atr) or na(mtfClose) ? na : (_mtf_atr / mtfClose) * 100
                
                // Format Volume with percentage and category
                _mtf_volText = ""
                if na(_mtf_volRatio)
                    _mtf_volText := "Veri yok"
                else
                    _mtf_volPct = ((_mtf_volRatio - 1.0) * 100)
                    _mtf_volPctStr = (_mtf_volPct >= 0 ? "+" : "") + str.tostring(_mtf_volPct, "#") + "%"
                    if _mtf_volRatio > 1.5
                        _mtf_volText := "GÜÇLÜ (" + _mtf_volPctStr + ") ✅"
                    else if _mtf_volRatio > 1.0
                        _mtf_volText := "VAR (" + _mtf_volPctStr + ") ✅"
                    else if _mtf_volRatio > 0.8
                        _mtf_volText := "ORTA (" + _mtf_volPctStr + ") ⚠️"
                    else
                        _mtf_volText := "ZAYIF (" + _mtf_volPctStr + ") ❌"
                
                // Format Momentum with category
                _mtf_momText = ""
                if na(_mtf_rsi)
                    _mtf_momText := "Hesaplanıyor"
                else
                    _mtf_rsiTrend = _mtf_rsi > _mtf_rsi[1] ? "↑" : _mtf_rsi < _mtf_rsi[1] ? "↓" : "→"
                    _mtf_rsiStr = "RSI " + str.tostring(_mtf_rsi, "#") + " " + _mtf_rsiTrend
                    if _mtf_rsi > 60
                        _mtf_momText := "GÜÇLÜ (" + _mtf_rsiStr + ") ✅"
                    else if _mtf_rsi > 50
                        _mtf_momText := "ORTA (" + _mtf_rsiStr + ") ⚠️"
                    else
                        _mtf_momText := "ZAYIF (" + _mtf_rsiStr + ") ❌"
                
                // Format Volatility with description
                _mtf_volText2 = ""
                if na(_mtf_atrPct)
                    _mtf_volText2 := "Hesaplanıyor"
                else
                    if _mtf_atrPct > 4.0
                        _mtf_volText2 := "YÜKSEK ⚡"
                    else if _mtf_atrPct > 2.0
                        _mtf_volText2 := "ORTA 📊"
                    else
                        _mtf_volText2 := "DÜŞÜK 😴"
                
                // Calculate strength grade
                _mtf_score = 0
                if not na(_mtf_volRatio)
                    if _mtf_volRatio > 2.0
                        _mtf_score += 3
                    else if _mtf_volRatio > 1.5
                        _mtf_score += 2
                    else if _mtf_volRatio > 1.2
                        _mtf_score += 1
                
                if not na(_mtf_rsi)
                    if _mtf_rsi > 60
                        _mtf_score += 2
                    else if _mtf_rsi > 55
                        _mtf_score += 1
                
                if not na(_mtf_atrPct) and _mtf_atrPct > 3.0
                    _mtf_score += 1
                
                _mtf_grade = _mtf_score >= 5 ? "A+ ⭐⭐⭐" : _mtf_score >= 3 ? "B ⭐⭐" : "C ⭐"
                
                // Add REALTIME/CONFIRMED label based on tfClosed status
                statusLabel = tfClosed ? " [✓CONFIRMED]" : " [⚡REALTIME]"
                
                // Build enhanced message with analytics
                msg = evStrBuy + " (" + tfLabel + ")" + statusLabel + "\n[" + syminfo.ticker + "]\nFiyat: " + fmtMint(mtfClose) + 
                      "\n\n📊 Analiz:\n" +
                      "Hacim: " + _mtf_volText + "\n" +
                      "Momentum: " + _mtf_momText + "\n" +
                      "Volatilite: " + _mtf_volText2 + "\n" +
                      "Güç: " + _mtf_grade +
                      (tfClosed ? "\n\n✅ Kesin sinyal - Bar kapatıldı" : "") +
                      prevNoteMtf
                
                // alert.freq_once_per_bar for realtime; dedup handled by send_event with mtfTime in id
                // MTF BANKO alerts sent to dedicated chat ID
                send_event(id, msg, telegramChatIdMtfBanko, alert.freq_once_per_bar)
                [lastBullishTime, lastBullishPrice, lastBullishTextTR, lastBullishTextEN, lastBullishTF] = f_record_bullish("BANKO KESİŞME AL", "BANKO LONG INTERSECT", tfLabel)
            // For non-BANKO mode, handle other events normally
            if not mtf_only_banko
                if buyLike and not buyBlockedByPct and evStrBuy!=""
                    id = "MTF_ST_"+tfLabel+"_BUY_"+str.tostring(mtfTime)
                    prevNoteMtf = f_prev_bullish_note()
                    msg = (etiketDil=="TR"?"🚀 MTF AL [" : "🚀 MTF BUY [") + syminfo.ticker + "] " + tfLabel + ": " + evStrBuy + "\nFiyat: " + fmtMint(mtfClose) + prevNoteMtf
                    send_event(id, msg, telegramChatIdBuy, alert.freq_once_per_bar_close)
                    [lastBullishTime, lastBullishPrice, lastBullishTextTR, lastBullishTextEN, lastBullishTF] = f_record_bullish("MTF AL", "MTF BUY", tfLabel)
                // MTF SAT disabled to reduce tokens
                // if sellLike and evStrSell!=""
                //     id2 = "MTF_ST_"+tfLabel+"_SELL_"+str.tostring(mtfTime)
                //     msg2 = (etiketDil=="TR"?"🔻 MTF SAT [" : "🔻 MTF SELL [") + syminfo.ticker + "] " + tfLabel + ": " + evStrSell + "\nFiyat: " + fmtMint(mtfClose)
                //     send_event(id2, msg2, telegramChatIdSell, alert.freq_once_per_bar_close)
            // Note: BANKO SAT (k_) intentionally not sent in BANKO mode per user request

sendMtf("60","1H", mtf_use_1h)
sendMtf("120","2H", mtf_use_2h)
sendMtf("240","4H", mtf_use_4h)
sendMtf("D","1D", mtf_use_1d)

// ---
// 15) MODÜL-2 4H / 1D Mesajlar
// ---
build_pg_value_lines() =>
    string valueLine_tr = ""
    string valueLine_en = ""
    if pg_va_mode=="MA+Bollinger"
        valueLine_tr := "\nBB: " + (close > (ta.sma(pg_bb_src, pg_bb_length) + pg_bb_mult*ta.stdev(pg_bb_src, pg_bb_length)) ? "ÜST" : (close < (ta.sma(pg_bb_src, pg_bb_length) - pg_bb_mult*ta.stdev(pg_bb_src, pg_bb_length)) ? "ALT" : "İÇ"))
        valueLine_en := "\nBB: " + (close > (ta.sma(pg_bb_src, pg_bb_length) + pg_bb_mult*ta.stdev(pg_bb_src, pg_bb_length)) ? "ABOVE" : (close < (ta.sma(pg_bb_src, pg_bb_length) - pg_bb_mult*ta.stdev(pg_bb_src, pg_bb_length)) ? "BELOW" : "IN"))
    else
        float pg_value_here = nz(ta.vwap(pg_vwap_source))
        string pg_label_val = "VW"
        valueLine_tr := "\nDeğer: " + pg_label_val + (not na(pg_value_here) ? "  Δ: " + str.tostring(close - pg_value_here, "#.####") : "")
        valueLine_en := "\nValue: " + pg_label_val + (not na(pg_value_here) ? "  Δ: " + str.tostring(close - pg_value_here, "#.####") : "")
    [valueLine_tr, valueLine_en]

// 4H — BUY BLOKLARI
if eff_includeModule2
    if mt_sendCombinedAlerts and mt_buyAllowedCombined
        idB = "M2_4H_COMBINED_BUY_" + str.tostring(bar_index)
        [valTR, valEN] = build_pg_value_lines()
        [tgTR, tgEN]   = f_target_block_buy(close, (trailStopEnabled and havePosition and not na(liveStop) ? liveStop : stUp))
        hdrTR = "🟢 M2 Kombine AL [" + syminfo.ticker + "] [4H]"
        hdrEN = "🟢 M2 Combined BUY [" + syminfo.ticker + "] [4H]"
        techCtxM2 = tech_ctx_for_unified_buy != "" ? tech_ctx_for_unified_buy : f_quick_tech_ctx()
        techTR = "\nTEK\n" + techCtxM2
        techEN = "\nTECH\n" + techCtxM2
        prevNoteM2 = f_prev_bullish_note()
        bodyTR = "\nRAPOR\nFiyat: " + fmtMint(close) + tgTR + (unifiedIncludePG and eff_pg_enable ? ("\nPG:\n" + PG_CTX_TR) : "") + (etiketDil=="TR"?valTR:valEN) + techTR + prevNoteM2
        bodyEN = "\nReport\nPrice: " + fmtMint(close) + tgEN + (unifiedIncludePG and eff_pg_enable ? ("\nPG\n" + PG_CTX_EN) : "") + (etiketDil=="TR"?valTR:valEN) + techEN
        msgB = (etiketDil=="TR" ? hdrTR + bodyTR : hdrEN + bodyEN)
        send_event(idB, msgB, fChatId(true,false), alert.freq_once_per_bar_close)
        [lastBullishTime, lastBullishPrice, lastBullishTextTR, lastBullishTextEN, lastBullishTF] = f_record_bullish("M2 Kombine AL", "M2 Combined BUY", "4H")

    if mt_sendConfirmedAlerts and mt_buyAllowedConf and not mt_buyAllowedCombined
        idB2 = "M2_4H_CONF_BUY_" + str.tostring(bar_index)
        [valTR2, valEN2] = build_pg_value_lines()
        [tgTR2, tgEN2]   = f_target_block_buy(close, (trailStopEnabled and havePosition and not na(liveStop) ? liveStop : stUp))
        hdrTR2 = "🟢 M2 Onaylı AL [" + syminfo.ticker + "] [4H]"
        hdrEN2 = "🟢 M2 Confirmed BUY [" + syminfo.ticker + "] [4H]"
        techCtxM2b = tech_ctx_for_unified_buy != "" ? tech_ctx_for_unified_buy : f_quick_tech_ctx()
        techTR2 = "\nTEK\n" + techCtxM2b
        techEN2 = "\nTECH\n" + techCtxM2b
        prevNoteM2b = f_prev_bullish_note()
        bodyTR2 = "\nRAPOR\nFiyat: " + fmtMint(close) + tgTR2 + (unifiedIncludePG and eff_pg_enable ? ("\nPG:\n" + PG_CTX_TR) : "") + (etiketDil=="TR"?valTR2:valEN2) + techTR2 + prevNoteM2b
        bodyEN2 = "\nReport\nPrice: " + fmtMint(close) + tgEN2 + (unifiedIncludePG and eff_pg_enable ? ("\nPG\n" + PG_CTX_EN) : "") + (etiketDil=="TR"?valTR2:valEN2) + techEN2
        msgB2 = (etiketDil=="TR" ? hdrTR2 + bodyTR2 : hdrEN2 + bodyEN2)
        send_event(idB2, msgB2, fChatId(true,false), alert.freq_once_per_bar_close)
        [lastBullishTime, lastBullishPrice, lastBullishTextTR, lastBullishTextEN, lastBullishTF] = f_record_bullish("M2 Onaylı AL", "M2 Confirmed BUY", "4H")

    if mt_sendCandleAlerts and mt_buyAllowedCandle
        idBC = "M2_4H_CANDLE_BUY_" + str.tostring(bar_index)
        [valTR3, valEN3] = build_pg_value_lines()
        [tgTR3, tgEN3]   = f_target_block_buy(close, (trailStopEnabled and havePosition and not na(liveStop) ? liveStop : stUp))
        hdrTR3 = "🕯️ M2 Candle Close AL [" + syminfo.ticker + "] [4H]"
        hdrEN3 = "🕯️ M2 Candle Close BUY [" + syminfo.ticker + "] [4H]"
        techCtxM2c = tech_ctx_for_unified_buy != "" ? tech_ctx_for_unified_buy : f_quick_tech_ctx()
        techTR3 = "\nTEK\n" + techCtxM2c
        techEN3 = "\nTECH\n" + techCtxM2c
        prevNoteM2c = f_prev_bullish_note()
        bodyTR3 = "\nRAPOR\nFiyat: " + fmtMint(close) + tgTR3 + (unifiedIncludePG and eff_pg_enable ? ("\nPG:\n" + PG_CTX_TR) : "") + (etiketDil=="TR"?valTR3:valEN3) + techTR3 + prevNoteM2c
        bodyEN3 = "\nReport\nPrice: " + fmtMint(close) + tgEN3 + (unifiedIncludePG and eff_pg_enable ? ("\nPG\n" + PG_CTX_EN) : "") + (etiketDil=="TR"?valTR3:valEN3) + techEN3
        msgBC = (etiketDil=="TR" ? hdrTR3 + bodyTR3 : hdrEN3 + bodyEN3)
        send_event(idBC, msgBC, fChatId(true,false), alert.freq_once_per_bar_close)

    if mt_enableEarlyAlerts and mt_buyAllowedEarly
        idBE = "M2_4H_EARLY_BUY_" + str.tostring(bar_index)
        prevNoteM2e = f_prev_bullish_note()
        msgBE = (etiketDil=="TR" ? "⚠️ M2 ERKEN AL [" : "⚠️ M2 Early BUY [") + syminfo.ticker + "] [4H] — Fiyat: " + fmtMint(close) + prevNoteM2e
        send_event(idBE, msgBE, fChatId(true,false), alert.freq_once_per_bar)

// 4H SELL
if mt_sendCombinedAlerts and mt_sellAllowedCombined
    idS = "M2_4H_COMBINED_SELL_" + str.tostring(bar_index)
    [valTRs, valENs] = build_pg_value_lines()
    [tgTRs, tgENs]   = f_target_block_sell(close, (trailStopEnabled and havePosition and not na(liveStop) ? liveStop : stDn))
    hdrTRs = "🔻 M2 Kombine SAT [" + syminfo.ticker + "] 4H"
    hdrENs = "🔻 M2 Combined SELL [" + syminfo.ticker + "] 4H"
    techCtxM2s = tech_ctx_for_unified_buy != "" ? tech_ctx_for_unified_buy : f_quick_tech_ctx()
    techTRs = "\nTEK:" + techCtxM2s
    techENs = "\nTECH:" + techCtxM2s
    bodyTRs = "\nP:" + fmtMint(close) + tgTRs + (unifiedIncludePG and eff_pg_enable ? ("\nPG:\n" + PG_CTX_TR) : "") + (etiketDil=="TR"?valTRs:valENs) + techTRs
    bodyENs = "\nP:" + fmtMint(close) + tgENs + (unifiedIncludePG and eff_pg_enable ? ("\nPG:\n" + PG_CTX_EN) : "") + (etiketDil=="TR"?valTRs:valENs) + techENs
    msgS = (etiketDil=="TR" ? hdrTRs + bodyTRs : hdrENs + bodyENs)
    send_event(idS, msgS, fChatId(false,true), alert.freq_once_per_bar_close)

// SELL — Onaylı
if mt_sendConfirmedAlerts and mt_sellAllowedConf and not mt_sellAllowedCombined
    idS2 = "M2_4H_CONF_SELL_" + str.tostring(bar_index)
    [valTRs2, valENs2] = build_pg_value_lines()
    [tgTRs2, tgENs2]   = f_target_block_sell(close, (trailStopEnabled and havePosition and not na(liveStop) ? liveStop : stDn))
    hdrTRs2 = "🔻 M2 Onaylı SAT [" + syminfo.ticker + "] 4H"
    hdrENs2 = "🔻 M2 Confirmed SELL [" + syminfo.ticker + "] 4H"
    techCtxM2s2 = tech_ctx_for_unified_buy != "" ? tech_ctx_for_unified_buy : f_quick_tech_ctx()
    techTRs2 = "\nTEK:" + techCtxM2s2
    techENs2 = "\nTECH:" + techCtxM2s2
    bodyTRs2 = "\nP:" + fmtMint(close) + tgTRs2 + (unifiedIncludePG and eff_pg_enable ? ("\nPG:\n" + PG_CTX_TR) : "") + (etiketDil=="TR"?valTRs2:valENs2) + techTRs2
    bodyENs2 = "\nP:" + fmtMint(close) + tgENs2 + (unifiedIncludePG and eff_pg_enable ? ("\nPG:\n" + PG_CTX_EN) : "") + (etiketDil=="TR"?valTRs2:valENs2) + techENs2
    msgS2 = (etiketDil=="TR" ? hdrTRs2 + bodyTRs2 : hdrENs2 + bodyENs2)
    send_event(idS2, msgS2, fChatId(false,true), alert.freq_once_per_bar_close)

// 1D — BUY BLOKLARI
if eff_includeModule2
    // BUY — Kombine
    if mt_sendCombinedAlerts and mt_buyAllowedCombined1D
        idBD = "M2_1D_COMBINED_BUY_" + str.tostring(bar_index)
        [valTRd, valENd] = build_pg_value_lines()
        [tgTRd, tgENd]   = f_target_block_buy(close, (trailStopEnabled and havePosition and not na(liveStop) ? liveStop : stUp))
        hdrTRd = "🟢 M2 Kombine AL [" + syminfo.ticker + "] [1D]"
        hdrENd = "🟢 M2 Combined BUY [" + syminfo.ticker + "] [1D]"
        techCtxD = tech_ctx_for_unified_buy != "" ? tech_ctx_for_unified_buy : f_quick_tech_ctx()
        techTRd = "\nTEK:" + techCtxD
        techENd = "\nTECH:" + techCtxD
        prevNoteD = f_prev_bullish_note()
        bodyTRd = "\nP:" + fmtMint(close) + tgTRd + (unifiedIncludePG and eff_pg_enable ? ("\nPG:\n" + PG_CTX_TR) : "") + (etiketDil=="TR"?valTRd:valENd) + techTRd + prevNoteD
        bodyENd = "\nP:" + fmtMint(close) + tgENd + (unifiedIncludePG and eff_pg_enable ? ("\nPG:\n" + PG_CTX_EN) : "") + (etiketDil=="TR"?valTRd:valENd) + techENd
        msgBD = (etiketDil=="TR" ? hdrTRd + bodyTRd : hdrENd + bodyENd)
        send_event(idBD, msgBD, fChatId(true,false), alert.freq_once_per_bar_close)
        [lastBullishTime, lastBullishPrice, lastBullishTextTR, lastBullishTextEN, lastBullishTF] = f_record_bullish("M2 Kombine AL", "M2 Combined BUY", "1D")

    // BUY — Onaylı
    if mt_sendConfirmedAlerts and mt_buyAllowedConf1D and not mt_buyAllowedCombined1D
        idB2D = "M2_1D_CONF_BUY_" + str.tostring(bar_index)
        [valTR2d, valEN2d] = build_pg_value_lines()
        [tgTR2d, tgEN2d]   = f_target_block_buy(close, (trailStopEnabled and havePosition and not na(liveStop) ? liveStop : stUp))
        hdrTR2d = "🟢 M2 Onaylı AL [" + syminfo.ticker + "] [1D]"
        hdrEN2d = "🟢 M2 Confirmed BUY [" + syminfo.ticker + "] [1D]"
        techCtxM2bd = tech_ctx_for_unified_buy != "" ? tech_ctx_for_unified_buy : f_quick_tech_ctx()
        techTR2d = "\n--- TEK ---\n" + techCtxM2bd
        techEN2d = "\n--- TECH ---\n" + techCtxM2bd
        prevNoteM2bd = f_prev_bullish_note()
        bodyTR2d = "\nRAPOR\nP:" + fmtMint(close) + tgTR2d + (unifiedIncludePG and eff_pg_enable ? ("\nPG:\n" + PG_CTX_TR) : "") + (etiketDil=="TR"?valTR2d:valEN2d) + techTR2d + prevNoteM2bd
        bodyEN2d = "\nReport\nP:" + fmtMint(close) + tgEN2d + (unifiedIncludePG and eff_pg_enable ? ("\nPG:\n" + PG_CTX_EN) : "") + (etiketDil=="TR"?valTR2d:valEN2d) + techEN2d
        msgB2D = (etiketDil=="TR" ? hdrTR2d + bodyTR2d : hdrEN2d + bodyEN2d)
        send_event(idB2D, msgB2D, fChatId(true,false), alert.freq_once_per_bar_close)

    // BUY — Candle close
    if mt_sendCandleAlerts and mt_buyAllowedCandle1D
        idBCD = "M2_1D_CANDLE_BUY_" + str.tostring(bar_index)
        [valTR3d, valEN3d] = build_pg_value_lines()
        [tgTR3d, tgEN3d]   = f_target_block_buy(close, (trailStopEnabled and havePosition and not na(liveStop) ? liveStop : stUp))
        hdrTR3d = "🕯️ M2 Candle Close AL [" + syminfo.ticker + "] [1D]"
        hdrEN3d = "🕯️ M2 Candle Close BUY [" + syminfo.ticker + "] [1D]"
        techCtxM2cd = tech_ctx_for_unified_buy != "" ? tech_ctx_for_unified_buy : f_quick_tech_ctx()
        techTR3d = "\n--- TEK ---\n" + techCtxM2cd
        techEN3d = "\n--- TECH ---\n" + techCtxM2cd
        prevNoteM2cd = f_prev_bullish_note()
        bodyTR3d = "\nRAPOR\nP:" + fmtMint(close) + tgTR3d + (unifiedIncludePG and eff_pg_enable ? ("\nPG:\n" + PG_CTX_TR) : "") + (etiketDil=="TR"?valTR3d:valEN3d) + techTR3d + prevNoteM2cd
        bodyEN3d = "\nReport\nP:" + fmtMint(close) + tgEN3d + (unifiedIncludePG and eff_pg_enable ? ("\nPG:\n" + PG_CTX_EN) : "") + (etiketDil=="TR"?valTR3d:valEN3d) + techEN3d
        msgBCD = (etiketDil=="TR" ? hdrTR3d + bodyTR3d : hdrEN3d + bodyEN3d)
        send_event(idBCD, msgBCD, fChatId(true,false), alert.freq_once_per_bar_close)

// 1D SELL
if mt_sendCombinedAlerts and mt_sellAllowedCombined1D
    idSD = "M2_1D_COMBINED_SELL_" + str.tostring(bar_index)
    [valTRsd, valENsd] = build_pg_value_lines()
    [tgTRsd, tgENsd]   = f_target_block_sell(close, (trailStopEnabled and havePosition and not na(liveStop) ? liveStop : stDn))
    hdrTRsd = "🔻 M2 Kombine SAT [" + syminfo.ticker + "] 1D"
    hdrENsd = "🔻 M2 Combined SELL [" + syminfo.ticker + "] 1D"
    techCtxM2sd = tech_ctx_for_unified_buy != "" ? tech_ctx_for_unified_buy : f_quick_tech_ctx()
    techTRsd = "\nTEK:" + techCtxM2sd
    techENsd = "\nTECH:" + techCtxM2sd
    bodyTRsd = "\nP:" + fmtMint(close) + tgTRsd + (unifiedIncludePG and eff_pg_enable ? ("\nPG:\n" + PG_CTX_TR) : "") + (etiketDil=="TR"?valTRsd:valENsd) + techTRsd
    bodyENsd = "\nP:" + fmtMint(close) + tgENsd + (unifiedIncludePG and eff_pg_enable ? ("\nPG:\n" + PG_CTX_EN) : "") + (etiketDil=="TR"?valTRsd:valENsd) + techENsd
    msgSD = (etiketDil=="TR" ? hdrTRsd + bodyTRsd : hdrENsd + bodyENsd)
    send_event(idSD, msgSD, fChatId(false,true), alert.freq_once_per_bar_close)

// SELL — Onaylı (1D)
if mt_sendConfirmedAlerts and mt_sellAllowedConf1D and not mt_sellAllowedCombined1D
    idS2D = "M2_1D_CONF_SELL_" + str.tostring(bar_index)
    [valTRs2d, valENs2d] = build_pg_value_lines()
    [tgTRs2d, tgENs2d]   = f_target_block_sell(close, (trailStopEnabled and havePosition and not na(liveStop) ? liveStop : stDn))
    hdrTRs2d = "🔻 M2 Onaylı SAT [" + syminfo.ticker + "] 1D"
    hdrENs2d = "🔻 M2 Confirmed SELL [" + syminfo.ticker + "] 1D"
    techCtxM2s2d = tech_ctx_for_unified_buy != "" ? tech_ctx_for_unified_buy : f_quick_tech_ctx()
    techTRs2d = "\nTEK:" + techCtxM2s2d
    techENs2d = "\nTECH:" + techCtxM2s2d
    bodyTRs2d = "\nP:" + fmtMint(close) + tgTRs2d + (unifiedIncludePG and eff_pg_enable ? ("\nPG:\n" + PG_CTX_TR) : "") + (etiketDil=="TR"?valTRs2d:valENs2d) + techTRs2d
    bodyENs2d = "\nP:" + fmtMint(close) + tgENs2d + (unifiedIncludePG and eff_pg_enable ? ("\nPG:\n" + PG_CTX_EN) : "") + (etiketDil=="TR"?valTRs2d:valENs2d) + techENs2d
    msgS2D = (etiketDil=="TR" ? hdrTRs2d + bodyTRs2d : hdrENs2d + bodyENs2d)
    send_event(idS2D, msgS2D, fChatId(false,true), alert.freq_once_per_bar_close)

// ---
// 16) VISUAL LABELS + ALERT CONDITIONS
// ---
if showSTSignals and buySignal and entryConfirmed(true) and htfOkLongLabel
    label.new(bar_index, stUp, TXT_BUY, style=label.style_label_up, color=color.new(color.green,0), textcolor=color.white)
if showSTSignals and sellSignal and entryConfirmed(true) and htfOkShortLabel
    label.new(bar_index, stDn, TXT_SELL, style=label.style_label_down, color=color.new(color.red,0), textcolor=color.white)
if longIntersectLabel and entryConfirmed(true)
    label.new(bar_index, low, TXT_LINT, style=label.style_label_up, color=color.new(color.teal,0), textcolor=color.white)
if shortIntersectLabel and entryConfirmed(true)
    label.new(bar_index, high, TXT_SINT, style=label.style_label_down, color=color.new(color.maroon,0), textcolor=color.white)

// SQZ görsel işaretler (kapalı - token tasarrufu)
// plotshape(sqz_enable and sqzOff and (sqz_val>0),  title="SQZ L", style=shape.circle, location=location.belowbar, color=color.new(color.lime, 0), size=size.tiny)
// plotshape(sqz_enable and sqzOff and (sqz_val<0),  title="SQZ S", style=shape.circle, location=location.abovebar, color=color.new(color.red, 0),  size=size.tiny)

// ---
// DT MODÜLÜ — Çift / Üçlü Dip–Tepe + MOST (saf ek analiz)
// Kaynak: ikiliucludipmitmovearesat.txt (v6'dan v5'e port)
// Hiçbir mevcut V61 ayarını DEĞİŞTİRMEZ, sadece ekler.
// ---

//----------------------------------------------------
// DT Inputs (formasyon + MOST)
//----------------------------------------------------
grpDT = "DT — Çift/Üçlü Dip & Tepe + MOST"

// DT Module - Minimal AL-only implementation (token-optimized)
dt_enable           = input.bool(true, "DT Çift/Üçlü Dip AL Aktif", group=grpDT)  // Changed to true - enable by default
dt_x                = input.int(14, "DT Pivot Uzunluğu", minval=3, group=grpDT)
dt_tolPct           = input.float(1.0, "DT Tolerans %", step=0.1, minval=0.0, group=grpDT)

// Minimal DT calculation - AL patterns only
var dt_confDB = false
var dt_confTB = false
if dt_enable
    dt_atr = ta.atr(14)
    dt_ph = ta.pivothigh(close, dt_x, dt_x)
    dt_pl = ta.pivotlow(close, dt_x, dt_x)
    
    // Simple double/triple bottom detection
    if not na(dt_pl)
        _lookback = 30
        _bottomCount = 0
        _firstBottom = dt_pl
        for i = 1 to _lookback
            if not na(ta.pivotlow(close, dt_x, dt_x)[i])
                _priorLow = ta.pivotlow(close, dt_x, dt_x)[i]
                if math.abs(_priorLow - _firstBottom) <= (_firstBottom * dt_tolPct / 100.0 + dt_atr)
                    _bottomCount += 1
        
        dt_confDB := _bottomCount >= 1 and close > _firstBottom  // Double bottom
        dt_confTB := _bottomCount >= 2 and close > _firstBottom  // Triple bottom
    else
        dt_confDB := false
        dt_confTB := false
else
    dt_confDB := false
    dt_confTB := false

// DT Labels
if dt_enable and dt_confDB and barstate.isconfirmed
    label.new(bar_index, low, "Çift Dip AL", style=label.style_label_up, color=color.new(color.green, 0), textcolor=color.white, size=size.small)
if dt_enable and dt_confTB and barstate.isconfirmed
    label.new(bar_index, low, "Üçlü Dip AL", style=label.style_label_up, color=color.new(color.lime, 0), textcolor=color.white, size=size.small)

// DT alertconditions (AL only)
alertcondition(dt_confDB and dt_enable, title="DT Çift Dip AL", message="DT Çift Dip AL onaylandı.")
alertcondition(dt_confTB and dt_enable, title="DT Üçlü Dip AL", message="DT Üçlü Dip AL onaylandı.")
// dt_volZLen          = input.int(20, "DT Hacim ZScore Periyodu", minval=2, group=grpDT)
// dt_volZTh           = input.float(1.0, "DT Hacim ZScore Eşiği", step=0.1, minval=0.0, group=grpDT)
// dt_volRequireBoth   = input.bool(false, "DT Hem MA*Çarpan hem ZScore gereksin", group=grpDT)
// useRealtimeBreak = input.bool(true, "DT: Bar kapanışını bekleme (high/low kırılım + realtime)", group=grpDT)
// dt_showPotential    = input.bool(false, "DT Potansiyel Etiketleri Göster (POT)", group=grpDT)
// dt_showNeckLines    = input.bool(true, "DT Boyun Çizgisi Göster", group=grpDT)
// dt_drawNecksOnlyOnConf = input.bool(true, "DT Boyun Çizgisi Yalnızca Onayda Çiz", group=grpDT)
// dt_limitNeckExtendBars = input.int(80, "DT Boyun Çizgisi Uzatma (bar)", minval=1, group=grpDT)
// dt_minProfitPct     = input.float(4.0, "DT Minimum Kar Potansiyeli %", step=0.5, minval=0.0, group=grpDT)
// dt_cBull            = input.color(color.lime, "DT Al (Dip) Rengi", group=grpDT)
// dt_cBear            = input.color(color.red, "DT Sat (Tepe) Rengi", group=grpDT)
// dt_cNeck            = input.color(color.orange, "DT Boyun Çizgi Rengi", group=grpDT)
// dt_confirmationCooldown = input.int(6, "DT Onay Sonrası Bekleme (bar)", minval=0, group=grpDT)
// dt_minRRtoShow          = input.float(1.2, "DT Gösterim için Min RR", step=0.1, group=grpDT)

// ---
// FO — Forecast Oscillator BUY-only Alert Module
// ---
grpFO = "FO — Forecast Oscillator"
fo_enable            = input.bool(true, "FO Module Enable", group=grpFO)  // Changed to true - enable by default
fo_chat_id           = input.string("", "FO Telegram chat_id (boş=DEFAULT)", group=grpFO)
fo_lenFosc           = input.int(14, "FO Length (Forecast Oscillator)", minval=1, group=grpFO)
fo_lenTrend          = input.int(50, "FO Trend Length (LinReg)", minval=1, group=grpFO)
fo_lenRSI            = input.int(14, "FO RSI Length", minval=1, group=grpFO)
fo_lenVol            = input.int(20, "FO Volume SMA Length", minval=1, group=grpFO)
fo_vol_hard_gate     = input.bool(false, "FO Volume Hard Gate (true=block signal, false=info only)", group=grpFO)
fo_lenATR            = input.int(14, "FO ATR Length", minval=1, group=grpFO)
fo_slMult            = input.float(1.0, "FO Stop Loss ATR Multiplier", step=0.1, minval=0.1, group=grpFO)
fo_rr1               = input.float(1.0, "FO Target1 R-Multiple", step=0.25, minval=0.1, group=grpFO)
fo_rr2               = input.float(2.0, "FO Target2 R-Multiple", step=0.25, minval=0.1, group=grpFO)
fo_cooldownBars      = input.int(10, "FO Cooldown Bars (min gap between signals)", minval=0, group=grpFO)
fo_use_xu100         = input.bool(true, "FO Use XU100 Market Filter", group=grpFO)
fo_xuLen             = input.int(50, "FO XU100 Trend Length", minval=1, group=grpFO)
fo_confirm_on_close  = input.bool(true, "FO Confirm on Bar Close", group=grpFO)
fo_round_to_mintick  = input.bool(true, "FO Round to mintick", group=grpFO)

// =========================================================================
// FO — Forecast Oscillator Calculation
// =========================================================================
// Declare variables in outer scope (Pine v5 requirement)
var bool fo_finalSignal = false
var float fo_risk = 0.0

if fo_enable
    // 1. Calculate Forecast Oscillator
    fo_hi = ta.highest(high, fo_lenFosc)
    fo_lo = ta.lowest(low, fo_lenFosc)
    fo_fosc = 100 * (close - (fo_hi + fo_lo) / 2) / (fo_hi - fo_lo)
    
    // 2. Trend Filter (Linear Regression uptrend)
    fo_linReg = ta.linreg(close, fo_lenTrend, 0)
    fo_trendUp = fo_linReg > fo_linReg[1]
    
    // 3. RSI Filter
    fo_rsi = ta.rsi(close, fo_lenRSI)
    fo_rsiOK = fo_rsi > 50 and fo_rsi > fo_rsi[1]
    
    // 4. Volume Filter (soft mode by default, hard gate optional)
    fo_volSma = ta.sma(volume, fo_lenVol)
    fo_volOK = volume > fo_volSma
    
    // Apply volume filter based on mode
    fo_volFilter = fo_vol_hard_gate ? fo_volOK : true
    
    // 5. XU100 Market Filter (optional)
    fo_xuTrend = ta.linreg(close, fo_xuLen, 0)
    fo_xuOK = fo_use_xu100 ? (fo_xuTrend > fo_xuTrend[1]) : true
    
    // 6. Crossover Signal
    fo_crossover = ta.crossover(fo_fosc, 0)
    
    // 7. Cooldown Check
    var int fo_lastSignalBar = na
    fo_cooldownOK = na(fo_lastSignalBar) or (bar_index - fo_lastSignalBar) >= fo_cooldownBars
    
    // 8. Combine All Filters
    fo_signal = fo_enable and fo_crossover and fo_trendUp and fo_rsiOK and fo_volFilter and fo_xuOK and fo_cooldownOK
    
    // 9. Confirm on Close (optional)
    fo_finalSignal := fo_confirm_on_close ? (fo_signal and barstate.isconfirmed) : fo_signal
    
    // 10. Update Cooldown
    if fo_finalSignal
        fo_lastSignalBar := bar_index
    
    // 11. Calculate Risk and Targets
    fo_atr = ta.atr(fo_lenATR)
    fo_stop = close - (fo_atr * fo_slMult)
    fo_risk := close - fo_stop
    fo_target1 = close + (fo_risk * fo_rr1)
    fo_target2 = close + (fo_risk * fo_rr2)
    
    // Round to mintick if enabled
    if fo_round_to_mintick
        fo_stop := math.round(fo_stop / syminfo.mintick) * syminfo.mintick
        fo_target1 := math.round(fo_target1 / syminfo.mintick) * syminfo.mintick
        fo_target2 := math.round(fo_target2 / syminfo.mintick) * syminfo.mintick
    
    // 12. Build Alert Message with Volume Info
    if fo_finalSignal
        fo_volRatio = volume / fo_volSma
        fo_volInfo = fo_volOK ? "" : " VOL:ZAYIF(" + str.tostring(fo_volRatio, "#.##") + "x)"
        
        fo_tfStr = timeframe.period
        fo_entryStr = str.tostring(close, "#.##")
        fo_stopStr = str.tostring(fo_stop, "#.##")
        fo_t1Str = str.tostring(fo_target1, "#.##")
        fo_t2Str = str.tostring(fo_target2, "#.##")
        
        fo_msg = "FO_AL|" + syminfo.ticker + "|TF=" + fo_tfStr + "|E=" + fo_entryStr + "|SL=" + fo_stopStr + "|T1=" + fo_t1Str + "|T2=" + fo_t2Str + fo_volInfo
        
        fo_chatId = fo_chat_id == "" ? telegramChatId : fo_chat_id
        fo_eventId = "FO_BUY_" + str.tostring(time)
        
        send_event(fo_eventId, fo_msg, fo_chatId, alert.freq_once_per_bar_close)
else
    // FO disabled - reset variables to prevent errors
    fo_finalSignal := false
    fo_risk := 0.0

// ---
// TURBO AL — High-Momentum Entry System for BIST (1-3 day, +10% target)
// Volume Explosion + Momentum + Breakout = Quick moves
// ---
grpTURBO = "TURBO AL — Momentum Entry"
turbo_enable        = input.bool(true, "TURBO AL Module Enable", group=grpTURBO)  // Changed to true - enable by default
turbo_chat_id       = input.string("", "TURBO Chat ID (boş=default)", group=grpTURBO)
turbo_volMultiple   = input.float(2.0, "Volume Multiplier (min 2x avg)", minval=1.5, step=0.1, group=grpTURBO)
turbo_rsiLen        = input.int(14, "RSI Length", minval=5, group=grpTURBO)
turbo_rsi7Len       = input.int(7, "RSI Fast Length", minval=3, group=grpTURBO)
turbo_rsi7Thresh    = input.float(65, "RSI Fast Threshold", minval=50, step=1, group=grpTURBO)
turbo_emaLen        = input.int(21, "EMA Length", minval=10, group=grpTURBO)
turbo_breakoutLen   = input.int(10, "Breakout Lookback", minval=5, group=grpTURBO)
turbo_atrLen        = input.int(14, "ATR Length", minval=10, group=grpTURBO)
turbo_slMult        = input.float(1.5, "Stop Loss (ATR mult)", minval=0.5, step=0.1, group=grpTURBO)
turbo_tp1Pct        = input.float(7.0, "TP1 %", minval=3, step=0.5, group=grpTURBO)
turbo_tp2Pct        = input.float(12.0, "TP2 %", minval=5, step=0.5, group=grpTURBO)
turbo_cooldown      = input.int(5, "Cooldown Bars", minval=1, group=grpTURBO)

var bool turbo_signal = false
var int turbo_lastSignalBar = -999

if turbo_enable and not safeBoot
    // Filter 1: Volume Explosion (MOST CRITICAL for BIST)
    turbo_volAvg = ta.sma(volume, 20)
    turbo_volLast5Max = ta.highest(volume, 5)[1]
    turbo_volFilter = volume > turbo_volMultiple * turbo_volAvg and volume > 1.5 * turbo_volLast5Max
    
    // Filter 2: Momentum Acceleration
    turbo_rsi14 = ta.rsi(close, turbo_rsiLen)
    turbo_rsi7 = ta.rsi(close, turbo_rsi7Len)
    turbo_rsiCross = ta.crossover(turbo_rsi14, 50)
    turbo_ema21 = ta.ema(close, turbo_emaLen)
    turbo_momentumFilter = turbo_rsiCross and turbo_rsi7 > turbo_rsi7Thresh and close > turbo_ema21
    
    // Filter 3: Price Breakout
    turbo_highestHigh = ta.highest(high, turbo_breakoutLen)[1]
    turbo_atr = ta.atr(turbo_atrLen)
    turbo_range = high - low
    turbo_breakoutFilter = close > turbo_highestHigh and close > open and turbo_range > 1.5 * turbo_atr
    
    // Combine all filters + cooldown
    turbo_cooldownOK = bar_index - turbo_lastSignalBar >= turbo_cooldown
    turbo_signal := turbo_volFilter and turbo_momentumFilter and turbo_breakoutFilter and turbo_cooldownOK and barstate.isconfirmed
    
    // Calculate risk levels when signal fires
    if turbo_signal
        turbo_lastSignalBar := bar_index
        
        // Risk management
        turbo_entry = close
        turbo_sl = turbo_entry - (turbo_slMult * turbo_atr)
        turbo_tp1 = turbo_entry * (1 + turbo_tp1Pct / 100)
        turbo_tp2 = turbo_entry * (1 + turbo_tp2Pct / 100)
        turbo_slPct = ((turbo_entry - turbo_sl) / turbo_entry) * 100
        turbo_rr1 = turbo_tp1Pct / turbo_slPct
        turbo_rr2 = turbo_tp2Pct / turbo_slPct
        
        // Format for display
        turbo_entryStr = str.tostring(turbo_entry, "#.##")
        turbo_slStr = str.tostring(turbo_sl, "#.##")
        turbo_tp1Str = str.tostring(turbo_tp1, "#.##")
        turbo_tp2Str = str.tostring(turbo_tp2, "#.##")
        turbo_slPctStr = str.tostring(turbo_slPct, "#.#")
        turbo_tp1PctStr = str.tostring(turbo_tp1Pct, "#.#")
        turbo_tp2PctStr = str.tostring(turbo_tp2Pct, "#.#")
        turbo_volRatio = str.tostring(volume / turbo_volAvg, "#.#")
        turbo_rsi14Str = str.tostring(turbo_rsi14, "#")
        turbo_rsi7Str = str.tostring(turbo_rsi7, "#")
        
        // Build Turkish message
        turbo_msg = "🚀 TURBO AL - [" + syminfo.ticker + "]\n\n"
        turbo_msg += "📊 Giriş: " + turbo_entryStr + " TL\n"
        turbo_msg += "⛔ Stop: " + turbo_slStr + " TL (-" + turbo_slPctStr + "%)\n"
        turbo_msg += "🎯 TP1 (50%): " + turbo_tp1Str + " TL (+" + turbo_tp1PctStr + "%)\n"
        turbo_msg += "🎯 TP2 (30%): " + turbo_tp2Str + " TL (+" + turbo_tp2PctStr + "%)\n"
        turbo_msg += "⏱️ Time Exit: 3 gün\n\n"
        turbo_msg += "📈 Sinyal Nedenleri:\n"
        turbo_msg += "✅ Hacim patlaması (" + turbo_volRatio + "x ortalama)\n"
        turbo_msg += "✅ RSI momentum dönüşü (14: " + turbo_rsi14Str + ", 7: " + turbo_rsi7Str + ")\n"
        turbo_msg += "✅ " + str.tostring(turbo_breakoutLen) + " günlük direnç kırıldı\n\n"
        turbo_msg += "⚡ Risk: " + turbo_slPctStr + "% | Hedef1: " + turbo_tp1PctStr + "% | R:R = 1:" + str.tostring(turbo_rr1, "#.#") + "\n"
        turbo_msg += "🕐 " + str.format("{0,time,HH:mm}", time) + "\n\n"
        turbo_msg += "#TURBO #MOMENTUM #BIST"
        
        // Send to Telegram
        turbo_eventId = "TURBO_" + syminfo.ticker + "_" + str.tostring(time)
        turbo_chatToUse = turbo_chat_id != "" ? turbo_chat_id : telegramChatId
        send_event(turbo_eventId, turbo_msg, turbo_chatToUse, alert.freq_once_per_bar_close)
else
    turbo_signal := false

// Visualization
plotshape(turbo_signal, "🚀 TURBO", style=shape.labelup, location=location.belowbar, color=color.new(color.orange, 0), size=size.small, text="TURBO", textcolor=color.white)

// ---
// TURBO INTRA 2H — 2-Hour Intraday Momentum Entry (Loosened)
// Target: +6% in 2-12 hours, Optimized for frequent intraday signals
// ---
grpTURBO2H = "TURBO INTRA 2H — Intraday Entry"

// Inputs
turbo2h_enable = input.bool(true, "TURBO INTRA 2H Aktif", group=grpTURBO2H)  // Changed to true - enable by default
turbo2h_chat_id = input.string("", "TURBO 2H Chat ID (boş=default)", group=grpTURBO2H)
turbo2h_volMultiple = input.float(1.5, "Volume Çarpanı", minval=1.0, step=0.1, group=grpTURBO2H)
turbo2h_rsiLen = input.int(14, "RSI Uzunluk", minval=5, group=grpTURBO2H)
turbo2h_rsi7Len = input.int(7, "Hızlı RSI", minval=3, group=grpTURBO2H)
turbo2h_rsi7Thresh = input.float(60, "Hızlı RSI Eşik", minval=50, step=1, group=grpTURBO2H)
turbo2h_emaLen = input.int(21, "EMA Uzunluk", minval=5, group=grpTURBO2H)
turbo2h_breakoutLen = input.int(7, "Breakout Uzunluk", minval=3, group=grpTURBO2H)
turbo2h_atrLen = input.int(14, "ATR Uzunluk", minval=5, group=grpTURBO2H)
turbo2h_slMult = input.float(1.5, "Stop Loss Çarpan", minval=0.5, step=0.1, group=grpTURBO2H)
turbo2h_tp1Pct = input.float(4.0, "TP1 %", minval=1, step=0.5, group=grpTURBO2H)
turbo2h_tp2Pct = input.float(6.0, "TP2 %", minval=1, step=0.5, group=grpTURBO2H)
turbo2h_cooldown = input.int(3, "Cooldown (bars)", minval=0, group=grpTURBO2H)

// TURBO INTRA 2H Logic
var int turbo2h_lastSignalBar = -999
var bool turbo2h_signal = false

if turbo2h_enable and not safeBoot
    // Volume filter (loosened to 1.5x)
    turbo2h_volAvg = ta.sma(volume, 20)
    turbo2h_volMax5 = ta.highest(volume, 5)
    turbo2h_volFilter = volume > turbo2h_volMultiple * turbo2h_volAvg and volume > 1.3 * turbo2h_volMax5[1]
    
    // Momentum filter (loosened thresholds)
    turbo2h_rsi = ta.rsi(close, turbo2h_rsiLen)
    turbo2h_rsi7 = ta.rsi(close, turbo2h_rsi7Len)
    turbo2h_ema = ta.ema(close, turbo2h_emaLen)
    turbo2h_momentumFilter = turbo2h_rsi > 50 and turbo2h_rsi7 > turbo2h_rsi7Thresh and close > turbo2h_ema
    
    // Breakout filter (7-day lookback)
    turbo2h_highest = ta.highest(high, turbo2h_breakoutLen)[1]
    turbo2h_atr = ta.atr(turbo2h_atrLen)
    turbo2h_breakoutFilter = close > turbo2h_highest and close > open and (high - low) > 1.3 * turbo2h_atr
    
    // Cooldown check
    turbo2h_cooldownOK = bar_index - turbo2h_lastSignalBar > turbo2h_cooldown
    
    // Combined signal
    turbo2h_signal := turbo2h_volFilter and turbo2h_momentumFilter and turbo2h_breakoutFilter and turbo2h_cooldownOK and barstate.isconfirmed
    
    // Calculate levels
    turbo2h_entry = close
    turbo2h_sl = turbo2h_entry - (turbo2h_slMult * turbo2h_atr)
    turbo2h_tp1 = turbo2h_entry * (1 + turbo2h_tp1Pct / 100)
    turbo2h_tp2 = turbo2h_entry * (1 + turbo2h_tp2Pct / 100)
    turbo2h_slPct = ((turbo2h_entry - turbo2h_sl) / turbo2h_entry) * 100
    turbo2h_rr1 = turbo2h_tp1Pct / turbo2h_slPct
    
    // Send alert
    if turbo2h_signal
        turbo2h_lastSignalBar := bar_index
        
        // Volume ratio for message
        turbo2h_volRatio = volume / turbo2h_volAvg
        
        // Build message
        turbo2h_msg = "🚀 TURBO INTRA 2H - [" + syminfo.ticker + "]\n\n" +
             "📊 Giriş: " + fmtMint(turbo2h_entry) + " TL\n" +
             "⛔ Stop: " + fmtMint(turbo2h_sl) + " TL (-" + str.tostring(turbo2h_slPct, "#.#") + "%)\n" +
             "🎯 TP1 (60%): " + fmtMint(turbo2h_tp1) + " TL (+" + str.tostring(turbo2h_tp1Pct, "#.#") + "%)\n" +
             "🎯 TP2 (40%): " + fmtMint(turbo2h_tp2) + " TL (+" + str.tostring(turbo2h_tp2Pct, "#.#") + "%)\n" +
             "⏱️ Time Exit: 1 gün (24h)\n\n" +
             "📈 Sinyal Nedenleri:\n" +
             "✅ Hacim patlaması (" + str.tostring(turbo2h_volRatio, "#.#") + "x ortalama)\n" +
             "✅ RSI momentum (14: " + str.tostring(turbo2h_rsi, "#.#") + ", 7: " + str.tostring(turbo2h_rsi7, "#.#") + ")\n" +
             "✅ " + str.tostring(turbo2h_breakoutLen) + " günlük direnç kırıldı\n\n" +
             "⚡ Risk: " + str.tostring(turbo2h_slPct, "#.#") + "% | Hedef1: " + str.tostring(turbo2h_tp1Pct, "#.#") + "% | R:R = 1:" + str.tostring(turbo2h_rr1, "#.#") + "\n" +
             "🕐 " + str.format("{0,time,HH:mm}", time) + "\n\n" +
             "#TURBO2H #INTRADAY #BIST"
        
        // Event ID and chat routing
        turbo2h_eventId = "TURBO2H_" + syminfo.ticker + "_" + str.tostring(time)
        turbo2h_chatToUse = turbo2h_chat_id != "" ? turbo2h_chat_id : telegramChatId
        
        // Send event
        send_event(turbo2h_eventId, turbo2h_msg, turbo2h_chatToUse, alert.freq_once_per_bar_close)
else
    turbo2h_signal := false

// Visualization
plotshape(turbo2h_enable and turbo2h_signal, "🚀 TURBO 2H", style=shape.labelup, location=location.belowbar, color=color.new(color.purple, 0), size=size.small, text="2H", textcolor=color.white)

// ---
// ---
// AT — AlphaTrend Confirmed BUY Module with Historical Performance Gate
// REFACTORED: Fix MTF evaluation bug, implement win-rate gate
// ---
grpAT = "AT — AlphaTrend Confirmed BUY"
enableAlphaPerf      = input.bool(true, "AT Module Enable", group=grpAT)  // Changed to true - enable by default
alphaChatId          = input.string("", "AT Telegram chat_id (boş=DEFAULT)", group=grpAT)
alpha_coeff          = input.float(1.0, "AT Multiplier", step=0.1, minval=0.1, group=grpAT)
alpha_AP             = input.int(14, "AT Common Period", minval=1, group=grpAT)
alpha_evalBars_4h    = input.int(90, "AT 4H Eval Bars (~15 days)", minval=1, group=grpAT)
alpha_evalBars_1d    = input.int(15, "AT 1D Eval Bars (15 days)", minval=1, group=grpAT)
alpha_targetPct      = input.float(20.0, "AT Target % (max run-up)", step=0.5, minval=0.1, group=grpAT)
alpha_histMinSamples = input.int(20, "AT Min History Samples", minval=1, group=grpAT)
alpha_histWinRateMin = input.float(0.55, "AT Min Win Rate", step=0.05, minval=0, maxval=1, group=grpAT)
alpha_histMaxSamples = input.int(100, "AT Max History Samples", minval=10, group=grpAT)
alpha_gateWhenInsufficient = input.string("Pass", "AT Gate When Insufficient", options=["Pass","Fail"], group=grpAT)
alpha_sendOn         = input.string("Both", "AT Send alerts on TF", options=["4H","1D","Both"], group=grpAT)
alpha_novolumedata   = input.bool(false, "AT No Volume Data (use RSI)", group=grpAT)
alpha_debug          = input.bool(false, "AT Debug Mode", group=grpAT)
alpha_allowHistoricalAlerts = input.bool(false, "AT Allow Historical Alerts", group=grpAT)

// =========================================================================
// AT — AlphaTrend Engine Function (runs in HTF context)
// =========================================================================
// This function runs inside request.security(), meaning it executes in the
// HTF context (4H or 1D). All evaluation logic must be here to use HTF data.
//
// Returns: [AlphaTrend, confirmedBuy, entryPrice, signalTime, gatePass, 
//           samples, wins, winRate, lastOutcome]
// =========================================================================
f_at_engine(tfKey, coeff, AP, novolumedata, evalBars, targetPct, 
            histMinSamples, histWinRateMin, histMaxSamples, gateWhenInsufficient) =>
    
    // ===== 1. Calculate AlphaTrend Signal (same as before) =====
    _ATR = ta.sma(ta.tr, AP)
    _upT = low - _ATR * coeff
    _downT = high + _ATR * coeff
    
    var float _AlphaTrend = na
    _condition = novolumedata ? ta.rsi(close, AP) >= 50 : ta.mfi(hlc3, AP) >= 50
    _AlphaTrend := _condition ? 
                   (_upT < nz(_AlphaTrend[1]) ? nz(_AlphaTrend[1]) : _upT) : 
                   (_downT > nz(_AlphaTrend[1]) ? nz(_AlphaTrend[1]) : _downT)
    
    // Buy/Sell signals
    _buySignalk = ta.crossover(_AlphaTrend, _AlphaTrend[2])
    _sellSignalk = ta.crossunder(_AlphaTrend, _AlphaTrend[2])
    
    // Bars since signals
    _K1 = ta.barssince(_buySignalk)
    _K2 = ta.barssince(_sellSignalk)
    _O1 = ta.barssince(_buySignalk[1])
    _O2 = ta.barssince(_sellSignalk[1])
    
    // Confirmed BUY (next bar after signal, on closed bar)
    _confirmedBuy = barstate.isconfirmed and _buySignalk[1] and _O1[1] > _K2
    _entryPrice = _confirmedBuy ? close : na
    _signalTime = _confirmedBuy ? time : na
    
    // ===== 2. Evaluation State (HTF context!) =====
    // CRITICAL: These vars persist in HTF context, using HTF bar_index and HTF high
    var float _evalEntry = na
    var int _evalStartBar = na
    var float _evalMaxHigh = na
    var array<float> _history = array.new_float(0)
    
    // ===== 3. Update Ongoing Evaluation =====
    if not na(_evalEntry)
        // Track max high in HTF context (HTF high, not chart high!)
        _evalMaxHigh := math.max(_evalMaxHigh, high)
        
        // Calculate elapsed HTF bars (HTF bar_index, not chart bar_index!)
        _barsElapsed = bar_index - _evalStartBar
        
        // Check if evaluation window complete
        if _barsElapsed >= evalBars
            // Calculate run-up percentage
            _runUpPct = (_evalMaxHigh / _evalEntry - 1) * 100.0
            
            // Add to history (most recent first)
            array.unshift(_history, _runUpPct)
            
            // Trim to max samples
            while array.size(_history) > histMaxSamples
                array.pop(_history)
            
            // Reset evaluation state
            _evalEntry := na
            _evalStartBar := na
            _evalMaxHigh := na
    
    // ===== 4. Calculate Win Rate and Gate =====
    _samples = array.size(_history)
    _wins = 0
    
    // Count wins
    if _samples > 0
        for i = 0 to _samples - 1
            if array.get(_history, i) >= targetPct
                _wins += 1
    
    // Calculate win rate
    _winRate = _samples > 0 ? _wins / _samples : 0.0
    
    // Gate decision
    _gatePass = false
    if _samples >= histMinSamples
        // Sufficient history: check win rate
        _gatePass := _winRate >= histWinRateMin
    else
        // Insufficient history: use configured behavior
        _gatePass := gateWhenInsufficient == "Pass"
    
    // ===== 5. Start New Evaluation on Signal =====
    if _confirmedBuy and not na(_entryPrice)
        _evalEntry := _entryPrice
        _evalStartBar := bar_index  // HTF bar_index!
        _evalMaxHigh := high         // HTF high!
    
    // ===== 6. Prepare Return Values =====
    _lastOutcome = _samples > 0 ? array.get(_history, 0) : na
    
    // Return tuple with all needed data
    [_AlphaTrend, _confirmedBuy, _entryPrice, _signalTime, 
     _gatePass, _samples, _wins, _winRate, _lastOutcome]

// =========================================================================
// Main AlphaTrend Logic
// =========================================================================

// Skip module if safeBoot or not enabled
if enableAlphaPerf and not safeBoot
    
    // -------------------------
    // MTF retrieval for 4H
    // -------------------------
    [at4h_AT, at4h_confBuy, at4h_entry, at4h_time, 
     at4h_gatePass, at4h_samples, at4h_wins, at4h_winRate, at4h_lastOutcome] = 
        request.security(syminfo.tickerid, "240", 
                         f_at_engine("4H", alpha_coeff, alpha_AP, alpha_novolumedata,
                                     alpha_evalBars_4h, alpha_targetPct,
                                     alpha_histMinSamples, alpha_histWinRateMin,
                                     alpha_histMaxSamples, alpha_gateWhenInsufficient),
                         barmerge.gaps_off, barmerge.lookahead_off)
    
    // -------------------------
    // MTF retrieval for 1D
    // -------------------------
    [at1d_AT, at1d_confBuy, at1d_entry, at1d_time,
     at1d_gatePass, at1d_samples, at1d_wins, at1d_winRate, at1d_lastOutcome] = 
        request.security(syminfo.tickerid, "D", 
                         f_at_engine("1D", alpha_coeff, alpha_AP, alpha_novolumedata,
                                     alpha_evalBars_1d, alpha_targetPct,
                                     alpha_histMinSamples, alpha_histWinRateMin,
                                     alpha_histMaxSamples, alpha_gateWhenInsufficient),
                         barmerge.gaps_off, barmerge.lookahead_off)
    
    // -------------------------
    // 4H Alert Processing
    // -------------------------
    if alpha_sendOn == "4H" or alpha_sendOn == "Both"
        // Signal found AND gate passes
        if at4h_confBuy and at4h_gatePass and not na(at4h_entry)
            // Build message
            _winRateStr = str.tostring(at4h_winRate * 100, "#.#")
            _minWinRateStr = str.tostring(alpha_histWinRateMin * 100, "#.#")
            _criterionMsg = "Başarı oranı: %" + _winRateStr + " (min %" + _minWinRateStr + "), Örneklem: " + str.tostring(at4h_samples) + " sinyal"
            
            _msgTitle = "🎯 BAŞARILI 4 SAAT AL (AlphaTrend)"
            _msgBody = "[" + syminfo.ticker + "] 4H\nFiyat: " + fmtMint(at4h_entry) + "\n" + _criterionMsg
            
            if not na(at4h_lastOutcome)
                _msgBody := _msgBody + "\nSon sonuç: +" + str.tostring(at4h_lastOutcome, "#.#") + "%"
            
            _fullMsg = _msgTitle + "\n" + _msgBody
            
            // Chat ID
            _at_chatId = alphaChatId == "" ? telegramChatId : alphaChatId
            
            // Send event
            _eventId = "ATCONF_BUY_4H_" + str.tostring(at4h_time)
            send_event(_eventId, _fullMsg, _at_chatId, alert.freq_once_per_bar_close)
    
    // -------------------------
    // 1D Alert Processing
    // -------------------------
    if alpha_sendOn == "1D" or alpha_sendOn == "Both"
        // Signal found AND gate passes
        if at1d_confBuy and at1d_gatePass and not na(at1d_entry)
            // Build message
            _winRateStr = str.tostring(at1d_winRate * 100, "#.#")
            _minWinRateStr = str.tostring(alpha_histWinRateMin * 100, "#.#")
            _criterionMsg = "Başarı oranı: %" + _winRateStr + " (min %" + _minWinRateStr + "), Örneklem: " + str.tostring(at1d_samples) + " sinyal"
            
            _msgTitle = "🎯 BAŞARILI 1 GÜN AL (AlphaTrend)"
            _msgBody = "[" + syminfo.ticker + "] 1D\nFiyat: " + fmtMint(at1d_entry) + "\n" + _criterionMsg
            
            if not na(at1d_lastOutcome)
                _msgBody := _msgBody + "\nSon sonuç: +" + str.tostring(at1d_lastOutcome, "#.#") + "%"
            
            _fullMsg = _msgTitle + "\n" + _msgBody
            
            // Chat ID
            _at_chatId = alphaChatId == "" ? telegramChatId : alphaChatId
            
            // Send event
            _eventId = "ATCONF_BUY_1D_" + str.tostring(at1d_time)
            send_event(_eventId, _fullMsg, _at_chatId, alert.freq_once_per_bar_close)
    
    // -------------------------
    // Debug Mode (optional)
    // -------------------------
    if alpha_debug
        var table debugTable = table.new(position.top_right, 3, 16, 
                                          border_width=1, border_color=color.gray)
        
        // Header
        table.cell(debugTable, 0, 0, "AlphaTrend Debug", 
                   text_color=color.white, bgcolor=color.blue, text_size=size.normal)
        table.merge_cells(debugTable, 0, 0, 2, 0)
        
        // 4H Section
        table.cell(debugTable, 0, 1, "═══ 4H ═══", bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.merge_cells(debugTable, 0, 1, 2, 1)
        
        table.cell(debugTable, 0, 2, "Confirmed BUY", text_size=size.small)
        table.cell(debugTable, 1, 2, at4h_confBuy ? "✓ YES" : "✗ NO",
                   text_color=at4h_confBuy ? color.green : color.red, text_size=size.small)
        
        table.cell(debugTable, 0, 3, "Samples", text_size=size.small)
        table.cell(debugTable, 1, 3, str.tostring(at4h_samples), text_size=size.small)
        
        table.cell(debugTable, 0, 4, "Wins", text_size=size.small)
        table.cell(debugTable, 1, 4, str.tostring(at4h_wins), text_size=size.small)
        
        table.cell(debugTable, 0, 5, "Win Rate", text_size=size.small)
        _wr4hStr = str.tostring(at4h_winRate * 100, "#.#") + "%"
        table.cell(debugTable, 1, 5, _wr4hStr,
                   text_color=at4h_winRate >= alpha_histWinRateMin ? color.green : color.orange,
                   text_size=size.small)
        
        table.cell(debugTable, 0, 6, "Gate Pass", text_size=size.small)
        table.cell(debugTable, 1, 6, at4h_gatePass ? "✓ PASS" : "✗ FAIL",
                   text_color=at4h_gatePass ? color.green : color.red, text_size=size.small)
        
        table.cell(debugTable, 0, 7, "Last Outcome", text_size=size.small)
        _lo4hStr = not na(at4h_lastOutcome) ? "+" + str.tostring(at4h_lastOutcome, "#.#") + "%" : "N/A"
        table.cell(debugTable, 1, 7, _lo4hStr, text_size=size.small)
        
        // Warning if insufficient
        if at4h_samples < alpha_histMinSamples
            table.cell(debugTable, 0, 8, "⚠️ Insufficient", 
                       text_color=color.orange, bgcolor=color.new(color.yellow, 85), text_size=size.tiny)
            _warn4h = str.tostring(at4h_samples) + "/" + str.tostring(alpha_histMinSamples)
            table.cell(debugTable, 1, 8, _warn4h, text_color=color.orange, text_size=size.tiny)
        
        // 1D Section
        table.cell(debugTable, 0, 9, "═══ 1D ═══", bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.merge_cells(debugTable, 0, 9, 2, 9)
        
        table.cell(debugTable, 0, 10, "Confirmed BUY", text_size=size.small)
        table.cell(debugTable, 1, 10, at1d_confBuy ? "✓ YES" : "✗ NO",
                   text_color=at1d_confBuy ? color.green : color.red, text_size=size.small)
        
        table.cell(debugTable, 0, 11, "Samples", text_size=size.small)
        table.cell(debugTable, 1, 11, str.tostring(at1d_samples), text_size=size.small)
        
        table.cell(debugTable, 0, 12, "Wins", text_size=size.small)
        table.cell(debugTable, 1, 12, str.tostring(at1d_wins), text_size=size.small)
        
        table.cell(debugTable, 0, 13, "Win Rate", text_size=size.small)
        _wr1dStr = str.tostring(at1d_winRate * 100, "#.#") + "%"
        table.cell(debugTable, 1, 13, _wr1dStr,
                   text_color=at1d_winRate >= alpha_histWinRateMin ? color.green : color.orange,
                   text_size=size.small)
        
        table.cell(debugTable, 0, 14, "Gate Pass", text_size=size.small)
        table.cell(debugTable, 1, 14, at1d_gatePass ? "✓ PASS" : "✗ FAIL",
                   text_color=at1d_gatePass ? color.green : color.red, text_size=size.small)
        
        table.cell(debugTable, 0, 15, "Last Outcome", text_size=size.small)
        _lo1dStr = not na(at1d_lastOutcome) ? "+" + str.tostring(at1d_lastOutcome, "#.#") + "%" : "N/A"
        table.cell(debugTable, 1, 15, _lo1dStr, text_size=size.small)
        
        // Warning if insufficient
        if at1d_samples < alpha_histMinSamples
            // Use column 2 for 1D warning
            table.cell(debugTable, 2, 9, "⚠️ Insuff.", 
                       text_color=color.orange, bgcolor=color.new(color.yellow, 85), text_size=size.tiny)
            _warn1d = str.tostring(at1d_samples) + "/" + str.tostring(alpha_histMinSamples)
            table.cell(debugTable, 2, 10, _warn1d, text_color=color.orange, text_size=size.tiny)

// =========================================================================

// =========================================================================

// alertcondition (Unified mantıkta kullanılan final booleanlar)
alertcondition(allowBuy,   title="ST Flip AL (HTF filtreli/Grace)")
alertcondition(allowSell,  title="ST Flip SAT (HTF filtreli)")
alertcondition(allowLInt,  title="BANKO KESİŞME AL (HTF/Grace)")
// BANKO KESIŞME AL - CONFIRMED only (REPAINT disabled per user request)
// alertcondition(allowLInt_Repaint,   title="BANKO KESİŞME AL [REPAINT]")  // DISABLED
alertcondition(allowLInt_Confirmed, title="BANKO KESİŞME AL [CONFIRMED]")
alertcondition(allowSInt,  title="BANKO KESİŞME SAT (HTF)")
alertcondition(allowHitR1, title="Hedef1 (R1) Ulaşıldı")
alertcondition(allowHitR2, title="Hedef2 (R2) Ulaşıldı")
alertcondition(trailMoved, title="Trail Stop Yükseldi")

// SQZ bağımsız sinyal alarmları (Signal modu)
alertcondition(sqz_enable and (sqz_mode=="Signal") and sqzOff and not sqzOff[1] and (sqz_val > 0), title="SQZ Long Release")
// alertcondition(sqz_enable and (sqz_mode=="Signal") and sqzOff and not sqzOff[1] and (sqz_val < 0), title="SQZ Short Release")

// FO Forecast Oscillator BUY signal
alertcondition(fo_finalSignal and fo_risk > 0, title="FO BUY Signal", message="Forecast Oscillator BUY signal fired")
